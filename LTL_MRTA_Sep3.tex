\documentclass[Afour,sageh,times]{sagej}

\usepackage{moreverb,url}
\usepackage{setspace}
\usepackage[colorlinks,bookmarksopen,bookmarksnumbered,citecolor=red,urlcolor=red]{hyperref}
\usepackage[flushleft]{threeparttable}
\usepackage{tikz}
\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=1pt] (char) {#1};}}
\newcommand\BibTeX{{\rmfamily B\kern-.05em \textsc{i\kern-.025em b}\kern-.08em
     T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\newtheorem{thm}{Theorem}[section]
\newtheorem{cor}[thm]{Corollary}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{asmp}[thm]{Assumption}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{problem}{Problem}
\newtheorem{exmp}{Example}
%\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
%\theoremstyle{remark}
\newtheorem{rem}[thm]{Remark}
%\numberwithin{equation}{section}
% MATH -----------------------------------------------------------
\newcounter{listcounter}
\newenvironment{noindlist}
 {\begin{list}{(\alph{listcounter})~~}{\usecounter{listcounter} \labelsep=0em \labelwidth=0em \leftmargin=0em \itemindent=0em}}
 {\end{list}}
\newcounter{mycounter}
%\renewcommand{\themycounter}{\alph{noindlist}}
\newcommand{\norm}[1]{\left\Vert#1\right\Vert}
\newcommand{\abs}[1]{\left\vert#1\right\vert}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\Real}{\mathbb R}
\newcommand{\eps}{\varepsilon}
\newcommand{\To}{\longrightarrow}
\newcommand{\BX}{\mathbf{B}(X)}
\newcommand{\A}{\mathcal{A}}
\newcommand\T{\rule{0pt}{2.9ex}}
\newcommand\B{\rule[-1.4ex]{0pt}{0pt}}
\newcommand{\ltl}{ {\it LTL}$_{-\bigcirc}$ }
\newcommand{\ltlx}{ {\it LTL}$_{-\bigcirc}^\chi$ }
\newcommand{\ltlz}{ {\it LTL}$_{-\bigcirc}^0$ }
\renewcommand{\topfraction}{0.98}
\renewcommand{\textfraction}{0.01}
\renewcommand{\floatpagefraction}{0.97}
\newcommand{\clause}[1]{\mathsf{cls}(#1)}
\newcommand{\cp}[2]{\ccalC_{#1}^{#2}}
\newcommand{\lk}[2]{\ell_{#1}^{(#2)}}
\newcommand{\auto}[1]{\ccalA_{\textup{#1}}}
\newcommand{\autop}{\ccalA_{\phi}}
\newcommand{\vertex}[1]{v_{\textup{#1}}}
\newcommand{\ag}[2]{\langle#1,#2\rangle}
\newcommand{\simplies}{\DOTSB\Longrightarrow}
\newcommand{\minus}{\scalebox{0.75}[1.0]{-}}

\usepackage{stmaryrd}
% The following packages can be found on http:\\www.ctan.org
\usepackage{graphicx} % for pdf, bitmapped graphics files
%% \graphicspath{{figures/}}
\usepackage{bbm}
\usepackage{bm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{epstopdf}

\usepackage[noend,ruled,linesnumbered,resetcount]{algorithm2e}
\SetKwComment{Comment}{$\triangleright$\ } {}
\usepackage{multirow}
\usepackage{rotating}
\usepackage{subfigure}
\usepackage{color}
\usepackage{mysymbol}
\usepackage{url}
\usepackage{ltlfonts}
%\usepackage{caption}
%\usepackage[skip=0.5\baselineskip]{caption}
\usepackage{tabularx,ragged2e,booktabs}
\usepackage[normalem]{ulem}
\usepackage[utf8x]{inputenc}
\usepackage{multirow}
\renewcommand{\ttdefault}{pcr} % selects Courier font
\renewcommand{\ap}[3]{\mathcal{\pi}_{{#1},{#2}}^{#3}}
\newcommand{\aap}[4]{\mathcal{\pi}_{{#1},{#2}}^{#3,#4}}
\newcommand{\Qb}{\mathcal{Q}_{B}}
\newcommand{\qb}{q_{{B}}}
\newcommand{\vect}[1]{\boldsymbol{\mathbf{#1}}}
\newcommand{\wf}{\mathcal{W}_{\text{free}}}
\newcommand{\w}{\mathcal{W}}
\newcommand{\te}[1]{\mathcal{#1}_T}
\newcommand{\x}[1]{\vect{x}^{\text{#1}}}
\newcommand{\q}[2]{{q}_{#1}^{\text{#2}}}
\newcommand{\pn}{\ccalQ_P^{\text{near}}}
\newcommand{\RNum}[1]{\uppercase\expandafter{\romannumeral #1\relax}}
\newcommand{\wn}{\mathcal{W}^{N}}
\newcommand{\state}[1]{(\vect{x}^{#1}, q_B^{#1})}
\newcommand{\statex}[1]{\vect{x}^{#1}}
\newcommand{\stateb}[1]{q_B^{#1}}
\newcommand{\pre}{\text{pre}}
\newcommand{\suf}{\text{suf}}
\newcommand{\ball}[1]{B_{n,!#1}}
\newcommand{\llabel}[1]{L(\vect{x}^{#1})}
\newcommand{\node}[1]{V_{n}^{\text{#1}}}
\newcommand{\colorblue}[1]{\textcolor{blue}{#1}}
\newcommand{\colorred}[1]{\textcolor{red}{#1}}
\newcommand{\ba}{\texttt{int}(\mathcal{B}_{\delta(\vect{x}^0)}(\vect{x}^0))}
\newcommand{\baa}{\mathcal{B}_{\delta(\vect{x}^0)}(\vect{x}^0)}
\newcommand*\diff{\mathop{}\mathrm{d}}
\newcommand{\rrts}{pRRT$^* $}
\newcommand{\rrt}{pRRT}
\newcommand{\grrt}{\ccalG^{\text{TL-RRT}}}
\newcommand{\xx}{\overline{\bbx_{i}\bbx_{i}'}}
\newcommand{\domanda}[1]{\subsubsection*{#1}}
\usepackage[hang,flushmargin]{footmisc}
\makeatletter
\newcommand{\algorithmendnote}[2][\footnotesize]{%
  \let\old@algocf@finish\@algocf@finish% Store algorithm finish macro
  \def\@algocf@finish{\old@algocf@finish% Update finish macro to insert "endnote"
    \leavevmode\rlap{\begin{minipage}{\linewidth}
    #1#2
    \end{minipage}}%
  }%
}
\makeatother

\makeatletter
\newcommand{\pushright}[1]{\ifmeasuring@#1\else\omit\hfill$\displaystyle#1$\fi\ignorespaces}
\newcommand{\pushleft}[1]{\ifmeasuring@#1\else\omit$\displaystyle#1$\hfill\fi\ignorespaces}
\makeatother

\usepackage{amsmath,scalerel}
\newcommand\doverline[1]{\ThisStyle{%
  \setbox0=\hbox{$\SavedStyle\overline{#1}$}%
  \ht0=\dimexpr\ht0-.15ex\relax% CHANGE .15 TO AFFECT SPACING
  \overline{\copy0}%
}}

\makeatletter
  \setbox0\hbox{$\xdef\scriptratio{\strip@pt\dimexpr
    \numexpr(\sf@size*65536)/\f@size sp}$}
\newcommand{\scriptveryshortarrow}[1][3pt]{{%
    \hbox{\rule[\scriptratio\dimexpr\fontdimen22\textfont2-.2pt\relax]
               {\scriptratio\dimexpr#1\relax}{\scriptratio\dimexpr.4pt\relax}}%
   \mkern-4mu\hbox{\let\f@size\sf@size\usefont{U}{lasy}{m}{n}\symbol{41}}}}

\makeatother

\newenvironment{cexmp}
{\addtocounter{exmp}{-1}\begin{exmp}}
  {\end{exmp}}

  \setcounter{secnumdepth}{3}
  % \hypersetup{draft}
  \usepackage{etoolbox}
\makeatletter
\patchcmd\@combinedblfloats{\box\@outputbox}{\unvbox\@outputbox}{}{\errmessage{\noexpand patch failed}}
\makeatother

\usepackage{graphicx,calc}
\newlength\myheight
\newlength\mydepth
\settototalheight\myheight{Xygp}
\settodepth\mydepth{Xygp}
\setlength\fboxsep{0pt}
\newcommand*\inlinegraphics[1]{%
  \settototalheight\myheight{Xygp}%
  \settodepth\mydepth{Xygp}%
  \raisebox{-0.7\mydepth}{\includegraphics[height=\myheight]{#1}}%
}


\newcounter{phase} \setcounter{phase}{0}
\newcounter{subphase}[phase] \setcounter{subphase}{0}

\renewcommand{\thephase}{\Alph{phase}}
\renewcommand{\thesubphase}{(\Alph{phase}$_{\rm{\arabic{subphase}}}$)}

\newenvironment{subphase}[2]%
{
\refstepcounter{subphase}
\paragraph{\thesubphase {} #1:} {#2}
}%
{}

\begin{document}

\runninghead{Luo and Zavlanos}

\author{Xusheng Luo\affilnum{1} and Michael M. Zavlanos\affilnum{1}}

\affiliation{\affilnum{1} Department of Mechanical Engineering and Materials Science, Duke University, Durham, NC 27708, USA}

\corrauth{Xusheng Luo, Department of Mechanical Engineering and Materials Science, Duke University, Durham, NC 27708, USA}

\email{xusheng.luo@duke.edu}

\title{Temporal Logic Task Allocation and Motion Planning in Multi-Robot Systems}

\begin{abstract}
  In this paper, we consider the problem of optimally allocating tasks, expressed as a global Linear Temporal Logic (LTL) specification that does not explicitly assign tasks, to teams of mobile robots. Each robot is capable of one task, and each task may require multiple robots. Given a discrete workspace, our goal is to design paths, sequences of discrete states, for robots that are capable of executing the assigned tasks. To obtain a scalable solution to this complex assignment problem, we propose a hierarchical framework that first synthesizes a high-level plan by exploiting the structure of a relaxed version of the Nondeterministic B$\ddot{\text{u}}$chi Automaton (NBA) that captures the LTL specification, and then convert the plan into executable paths by tackling a sequence of generalized multi-robot path planning instances. Specifically, we first prune the NBA and relax it by removing all negative atomic propositions from the NBA. Then, we decompose the relaxed NBA into simpler sub-NBA. The sequences of edges in these sub-NBA give rise to sequences of subtasks  the robots need to accomplish to satisfy the relaxed NBA. We capture these temporal relations between subtasks using partially ordered sets and formulate a Mixed Integer Linear Problem (MILP) to allocate subtasks to robots subject to these partial order constraints. After obtaining a high-level plan, we return to the original NBA to satisfy the global LTL task. The relaxation is corrected to incorporate ignored negative atomic propositions, and the high-level plan is concretized to produce low-level paths, both of which are achieved by solving a sequence of generalized multi-robot path planning problems. Finally, we provide theoretical analysis on the completeness and soundness of our method and present numerical simulations showing our method can generate robot paths with lower cost, considerably faster than existing methods.

\end{abstract}

\keywords{Temporal logic, formal methods,  multi-robot systems, task allocation, motion planning}
\maketitle
\section{Introduction}

{M}{otion} planning traditionally consists of generating robot trajectories reaching goal regions from starting points while avoiding obstacles \citep{lavalle2006planning}. More recently, {new planning approaches have been proposed that} can handle a richer class of tasks, than the classical point-to-point navigation, and can capture temporal goals. Such tasks can be, e.g., sequencing or coverage \citep{fainekos2005temporal}, data gathering \citep{guo2017distributed}, intermittent communication \citep{kantaros2018distributed}, or persistent surveillance \citep{leahy2016persistent}, and can be captured using formal languages, such as Linear Temporal Logic (LTL) \citep{baier2008principles},  developed in concurrency theory. A survey on formal specifications for robotic systems is available in~\cite{luckcuck2019formal}.

In this paper, we consider a heterogeneous multi-robot system under a global LTL task that requires robots of different types to visit different regions of interest. The specific robot to visit a region is immaterial as long as it is a robot of the desired type. Consider the emergency response as a motivating example. Such LTL can specify tasks like: {\it two robots of type 1 visit region $ A $ to assist in evacuating the injured personnel. Before that, three robots of type 2 must reach the region $ B $ to repair the road for mass evacuation. Furthermore,  no more than two robots  can be present at region $B$ at the same time in order to protect the road base.} In this task, several robots are required to work cooperatively, and be present simultaneously at the same place. Several aspects contribute to the complexity of this problem. First, all robots' tasks are intertwined in the global specification that does not assign tasks explicitly to individual robots. Hence, the global specification needs to be decomposed into multiple tasks. Second,  many ways exist to allocate these smaller tasks to robots with specific capabilities. Third, there can be complex temporal constraints restricting these smaller tasks, including precedent and simultaneous relations. Finally, the solution should scale well with respect to the size of robots and the workspace.


We refer to this problem as the Multi-Robot Task Allocation under temporal logic tasks, in short, LTL-MRTA. A popular control synthesis method, e.g.,~\cite{guo2015multi}, for temporal logic specifications builds a product of the automaton, graphical representation of the specification, and the team model which itself is a product of individual robot model. This method will encounter the notorious state-space explosion as the size of the robot grows. To mitigate the computational burden, we leverage techniques from the formal method, multi-robot task allocation, and multi-robot path planning to propose a hierarchical framework.

Specifically, the high-level component performs task allocation and plan generation. We extract subtasks from the Nondeterministic B$\ddot{\text{u}}$chi Automaton (NBA) by identifying transitions that progress towards task completion. Then, we infer partial order relations capturing the temporal constraints imposed by the LTL, and  we propose a MILP formulation inspired by the vehicle routing problem to allocate subtasks to robots while respecting the temporal order between subtasks. The solution to the MILP can generate a high-level plan for each robot, which is a sequence of essential waypoints that the robot needs to visit along the timeline. To reduce the number of subtasks, we prune the NBA and deal with a sub-NBA at each time.  To leverage the power of MILP, at a high level, we temporally ignore such constraints in the LTL that put a limit on the number of robots in order to achieve linear constraints. This deliberated ignorance is similar to lazy collision checking in the point-to-point motion planning algorithms~\citep{sanchez2003single,hauser2015lazy}, where expensive  collision checking is postponed. Therefore, we also refer to this step as the {\it relaxation} stage. Then the low-level component seeks to concretize the high-level plan into executable paths while taking into account the ignored constraints in the high-level plan. So we refer to this step as the {\it correction} stage. To achieve this, we generate a sequence of generalized multi-robot path planning (GMRPP) problems where each instance of GMRPP deals with one subtask. The concatenation of paths returned by instances of GMRPP satisfies the LTL specification. The extensive simulations show that our method can handle LTL-MRTA problems with order $10^{90}$ states, which outperforms existing methods. Finally, we provide the theoretical guarantee that, with mild assumptions, our hierarchical framework is complete.





\subsection{Related work}
High-level specification for a multi-robot system can be provided in different forms. In~\cite{guo2015multi,tumova2016multi} local specifications are assigned to  each robot. In most works, e.g., \cite{loizou2004automatic,smith2011optimal,saha2014automated,kantaros2015intermittent,kantaros2017sampling,kantaros2018distributedOpt,kantaros2018sampling,kantaros2018temporal,kantaros2020stylus,xluo_CDC19,luo2019abstraction}, global specifications capturing the collective behavior of all robots are given, which explicitly assign tasks to individual robots. Global specifications that do not explicitly assign tasks are considered in~\cite{kloetzer2011multi,shoukry2017linear,moarref2017decentralized,lacerda2019petri}, as in our work.


Multi-robot task allocation problems have long been studied in the robotics literature~\citep{korsah2013comprehensive,nunes2017taxonomy,gini2017multi}. A popular approach is using market-based methods  centering on the concept of auctions~\cite{zavlanos2007distributed,zavlanos2008distributed,zavlanos2008dynamic,michael2008distributed}. Another line of works, e.g.,~\cite{gombolay2013fast,jones2011time} leverages an optimization-based method, such as Mixed Integer Linear Programming (MILP) formulations and genetic algorithms. The typical setting is that tasks to be allocated are pre-defined separately, which is not the case here.


Global temporal logic specifications need to be decomposed in order to allocate tasks to robots.~\cite{tumova2015decomposition,kantaros2016distributed} decompose a global specification directly into local specifications and assign them to individual robots.~\cite{camacho2017non,xluo_CDC19,camacho2019ltl,schillinger2019hierarchical} decompose a global specification into multiple subtasks by exploiting the structure of the finite automata. Particularly,~\cite{camacho2017non} converts temporal planning problems to standard planning problems by defining actions based on the transitions in the NBA.~\cite{xluo_CDC19} identify transitions in a NBA as subtasks and store synthesized plans for subtasks in a library so that they can be reused to efficiently synthesize plans  for new LTL formulas.~\cite{camacho2019ltl} convert formal languages to reward machines that capture the structure of the task to be used for reinforcement learning.~\cite{schillinger2019hierarchical} associate each transition in the automaton with a subtask and use reinforcement learning to execute subtasks under uncertainty. In this work, we follow along this line to recognize each transition in the NBA as a subtask. We further provide the notion of equivalent subtasks, reducing the number of subtasks to be considered.

Next, we present the most relevant temporal logic task allocation methods. As in our work, most works do not explicitly assign tasks to individual robots.~\cite{karaman2011linear} combine the vehicle routing problem with metric temporal logic specifications and leverage MILP to solve it. However, they deal with finite horizon tasks and do not take the low-level executable paths into account. In this sense, they only address the high-level plan in our work.~\cite{chen2011formal,leahy2015distributed} decompose a global automaton to assign an automaton to each robot and then build a synchronous product of automata to synthesize parallel plans. However, the size of the synchronous product grows exponentially with respect to the number of robots. Also, the requirement on parallel plans limits its applicability to cooperative tasks since many tasks lack the parallel executions.%% %% Furthermore, when a request is made to robots of a certain type, all robots of this type are required to participate, whereas here we can allow only a part of the robots to respond.
%% ~\cite{ulusoy2013optimality} continue along this line, but
%% the global specification assigns tasks to individual robots.
~\cite{lacerda2019petri,kloetzer2020path} leverage the Petri net to model the team of homogeneous robots, whereas we consider heterogeneous robots.~\cite{lacerda2019petri} tackle the job allocation under safe temporal logic specification, but they do not consider ``eventually'' operator meaning that the liveliness property that something good will happen in the future cannot be addressed. Additionally, they only solve robot coordination at the task level without considering execution. \cite{kloetzer2020path}  select multiple shortest accepting runs in the NBA and, for each accepting run, find whether an executable plan exists. It remains questionable whether the Petri net can handle heterogeneous robots. \cite{schillinger2018decomposition,schillinger2018simultaneous,faruq2018simultaneous,banks2020multi} automatically decompose the automaton representation of the LTL formula into independent subtasks that can be fulfilled by different robots. However, they only consider LTL formulas that can be satisfied by finite trajectories of robots, limiting the applicability of the proposed method to tasks such as recurrent sequencing and persistent monitoring. Also subtasks subject to precedence relations can only be executed by a single robot.

Common in the above works is that they do not consider cooperative tasks where robots of the same or different types meet somewhere to complete one task, as in our case,  which gives rise to strong synchronization between robots. In our previous works~\citep{kantaros2018sampling,kantaros2020stylus}, a sampling-based planning method named  Stylus$^*$ is proposed which incrementally builds trees to approximate the product of the automaton and the team model. With the powerful biased sampling strategy in~\cite{kantaros2020stylus}, Stylus$^*$ can tackle product automata with order $10^{800}$ states without considering collision avoidance, which outperforms other existing methods~\citep{ulusoy2013optimality,kantaros2017sampling}. However, Stylus$^*$ deals with global LTL specifications that explicitly assign tasks to robots. Although a subset of specifications here we consider can be converted into explicit LTL formulas by enumerating all possible task assignments combinatorially and connecting with ``OR'' operators, which would result in exponentially longer LTL formulas. Furthermore, the biased sampling strategy achieves acceleration by selecting the same assignment throughout, which amounts to no task allocation. With unbiased sampling in~\cite{kantaros2018sampling}, Stylus$^*$ can only handle problems with order $10^{10}$ states, whereas the simulations  show that our method can handle problems with $10^{90}$ states while considering collision avoidance. Compared to model-checkers, like NuSMV~\citep{cimatti2002nusmv}, that focus on finding feasible paths and are incapable of  optimizing cost. As stated in~\cite{kantaros2020stylus}, NuSMV can only  handle problems with $10^{30}$ states, which  performs poorly in  processing exponentially longer LTL formulas generated by explicitly expressing task assignments.


Among other works dealing with cooperative tasks,~\cite{moarref2017decentralized} design specifications capturing the behaviors of homogeneous robotic swarms on the swarm and individual levels, but they can only impose universal or existential constraints, that is, all robots or some robots visit a certain region, thus, incapable of imposing restrictions on the number of robots that should be present at one place at the same time or put a limit on the number of present robots.~\cite{sahin2017provably,sahin2017synchronous,sahin2019multirobot} employ the counting linear temporal logic (cLTL+/cLTL) to capture constraints on the number of robots that must be present in different regions. They propose an Integer Linear Programming (ILP) formulation inspired by Bounded Model Checking techniques~\citep{biere2006linear}. These methods only focus on the feasibility of the resulting paths, whereas our  method can keep updating the best result  by searching for more satisfying paths. %% Furthermore, cLTL+/cLTL cannot specify such tasks where two different regions need to be visited by the same fleet of robots sequentially, as demonstrated in Section~\ref{sec:sim}.
Along this line, \cite{JoLeVaSaSeTrBe-ISRR-2019} extend to capture the time duration of task completion. The low-level planning are conducted sequentially by planning for one single robot at a time and afterwards treating the planned robots as obstacles, whereas we can generate paths for all robots at the same time. Furthermore, the size of the workspace has a significant effect on the computation time of this line of work. To mitigate this issue,~\cite{sahin2019multi} propose a hierarchical framework that first abstracts the workspace by aggregating states with the same observations. As shown in Section~\ref{sec:sim}, our proposed method  scales better than the method in \cite{sahin2019multi}, with less runtimes and smaller cost. Also, we show the completeness of our proposed method which, however, is not guaranteed in~\cite{sahin2019multi}.

%% Finally, our contributions can be summarized as follows: (1) We propose a hierarchical framework where the high-level component optimally allocates subtasks to robots and obtain a high-level plan for each robot, which guides the low-level path generation.
%%  (2) We decompose the global specification into multiple subtasks and infer a partial order to capture their relations.   (3) We provide theoretical analysis to demonstrate the completeness and soundness of our method. (4) We conduct extensive simulations to show the efficacy and scalability of our method.

The rest of the paper is organized as follows. %% %% In Section~\ref{sec:prel}, we provide a brief overview of LTL and then,
In Section~\ref{sec:preliminaries} and~\ref{sec:problem} we present preliminaries and the problem formulation, respectively. We describe the high-level component in  Section~\ref{sec:app} and \ref{sec:solution}, where we process the NBA, identify subtasks from the NBA and infer temporal orders between them in Section~\ref{sec:app} and formulate the MILP to obtain the high-level plan in Section~\ref{sec:solution}, respectively. Furthermore, we examine their correctness and completeness  in Section~\ref{sec:correctness}. Simulation results and conclusion remarks are presented in Sections~\ref{sec:sim} and~\ref{sec:conclusion}, respectively. For better understanding, the low-level component, based on existing multi-robot path planning techniques, to obtain the executable paths that satisfies the specification is studied in Appendix~\ref{sec:solution2mrta}.



\section{Preliminaries}\label{sec:preliminaries}
\subsection{Linear temporal logic}\label{sec:ltl}
In this part, we describe Linear Temporal Logic (LTL) by presenting its syntax and semantics. Also, we briefly review the preliminaries of automata-based LTL model checking.
Linear temporal logic~\citep{baier2008principles} is composed of a set of atomic propositions $\mathcal{AP}$, the boolean operators, conjunction $\wedge$ and negation $\neg$, and temporal operators, next $\bigcirc$ and until $\mathcal{U}$. LTL formulas over $\mathcal{AP}$ follow the grammar $$\phi:=\top~|~\pi~|~\phi_1\wedge\phi_2~|~\neg\phi~|~\bigcirc\phi~|~\phi_1~\mathcal{U}~\phi_2,$$ where $\top$ is unconditionally true.   Other temporal operators, e.g., \textit{eventually} $\lozenge$, \textit{always} $\square$, can be derived from $\mathcal{U}$, where $\Diamond \phi$ means $\phi$ will be satisfied sometime in the future, and $\square \phi$ means $\phi$ is always satisfied from now on. %% In this paper, we restrict our attention to LTL that excludes the ``next'' temporal operator, denoted by LTL$_{-X}$ in \cite{kloetzer2008fully}, since the property of asymptotic optimality requires the path generated by the planning algorithm to completely coincide with the optimal path, whereas the ``next'' operator violates the continuity of the underlying path.

An infinite \textit{word} $w$ over the alphabet $2^{\mathcal{AP}}$, the power set of the set of atomic propositions, is defined as an infinite sequence  $w=\sigma_0\sigma_1\ldots\in (2^{\mathcal{AP}})^{\omega}$, where $\omega$ denotes an infinite repetition and $\sigma_k\in2^{\mathcal{AP}}$, $\forall k\in\mathbb{N}$. The language $\texttt{Words}(\phi)=\left\{w|w\models\phi\right\}$ is defined as the set of words that satisfy the LTL formula $\phi$, where $\models\subseteq (2^{\mathcal{AP}})^{\omega}\times\phi$ is the satisfaction relation. An LTL $\phi$ can be translated into an NBA  defined as follows \citep{vardi1986automata}:
\begin{defn}[(NBA)]\label{def:nba}
  A \textit{Nondeterministic B$\ddot{\text{u}}$chi Automaton} $B$ is  a tuple $B=\left(\ccalQ_{B}, \ccalQ_{B}^0,\Sigma,\rightarrow_B,\mathcal{Q}_B^F\right)$, where $\ccalQ_{B}$ is the set of states; $\ccalQ_{B}^0\subseteq\ccalQ_{B}$ is a set of initial states; $\Sigma=2^{\mathcal{AP}}$ is an alphabet;  $\rightarrow_{B}\subseteq\ccalQ_{B}\times \Sigma\times\ccalQ_{B}$ is the transition relation;
%% For a transition $(q_B,\pi,q'_B)\in\rightarrow_{B}$, $\pi\in \Sigma$ is called a state label if $q_B=q'_B$, otherwise a transition label;
and $\ccalQ_B^F\subseteq\ccalQ_{B}$ is a set of accepting states.
\end{defn}


An \textit{infinite run} $\rho_B$ of $B$ over an infinite word $w=\sigma_0\sigma_1\sigma_2\dots$, $\sigma_k\in\Sigma$, $\forall k\in\mathbb{N}$, is a sequence $\rho_B=q_B^0q_B^1q_B^2\dots$ such that $q_B^0\in\ccalQ_B^0$ and $(q_B^{k},\sigma_k,q_B^{k+1})\in\rightarrow_{B}$, $\forall k\in\mathbb{N}$.
%% , where we call $\pi_k$ a \textit{state label} if $q_B^k=q_B^{k+1}$, otherwise a \textit{transition label} if $q_B^k \not= q_B^{k+1}$.
An infinite run $\rho_B$ is called \textit{accepting} if $\texttt{Inf}(\rho_B)\cap\ccalQ_B^F\neq\varnothing$, where $\texttt{Inf}(\rho_B)$ represents the set of states that appear in $\rho_B$ infinitely often. An accepting run can be written in the prefix-suffix structure such that the prefix part (connecting an initial state to an  accepting state) is traversed only once and the suffix part, a cycle around the accepting state, is traversed infinitely often.
The words $\sigma$ that induce an accepting run of $B$ constitute the accepted language of $B$, denoted by $\ccalL_B$.~\cite{baier2008principles} proved that the accepted language of $B$ is equivalent to the words of $\phi$, i.e., $\ccalL_B=\texttt{Words}(\phi)$.

\subsection{Partial orders}\label{sec:partial}
A finite partially ordered set or poset $P = (X, <_P )$  is a pair consisting of a finite base set $X$ and a binary relation $<_P \subseteq X \times X$ that is reflexive, antisymmetric, and transitive. Let  $x, y \in X$ be two distinct elements. We write $x <_P y$ if $(x,y) \in <_P$, and $x \|_P y$ if  $x$ and $y$ are incomparable. Moreover, we say $x$ is covered by $y$ or $y$ covers $x$, denoted by $x \prec_P y$, if $x<_P  y$ and there is no distinct $z \in X$ such that $x  <_P  z <_P y$. An antichain is a subset of a poset  in which any two distinct elements   are incomparable. The width of a poset is the cardinality of a maximal antichain. Similarly, the height of a poset is defined as  cardinality of a chain. Similarly, a chain is a subset of a poset  in which any two distinct elements are comparable. The height of a poset is the cardinality of a maximal chain.

A linear order $L_X=(X, <_L)$ is a poset such that $x <_L y$, $x = y$ or $y <_L x$ holds for any pair of  $x, y \in X$. A linear extension  $L_P = (X, <_L)$  of a poset $P$ is a linear order such that $x <_L y$ if $x <_P y$, i.e., a linear order that preserves the partial order.
We define $\ccalL_P$ as the set of all linear extensions of a poset $P$. Note that a poset and its linear extensions share the same base set $X_P$. Given a collection of linear orders $\Xi$, the poset cover problem focuses on reconstructing a single poset $P$ or a set of posets $P = \{P_1,\ldots,P_k\}$ such that $L_P = \Xi$ or $\cup_{i=1}^k L_{P_i} = \Xi$. As shown in~\cite{heath2013poset}, the poset cover problem is NP-complete. Moreover, the partial cover problem focuses on finding a single poset $P$ such that $\ccalL_P$ contains the maximum number of linear orders in $\Xi$, i.e., $\ccalL_P \subseteq \Xi$ and   $\nexists P'$ s.t. $\ccalL_{P'} \subseteq \Xi$ and $|\ccalL_{P'}| > |\ccalL_{P}|$.~\cite{heath2013poset} showed that the partial cover problem can be solved in polynomial time.



\section{Problem Formulation and Outline}\label{sec:problem}
In this section, we introduce the problem formulation and then provide the outline of our proposed method.
\subsection{Transition system}\label{sec:ts}
Consider a discrete workspace containing regions of interest and obstacles, where each region or obstacle can span multiple free cells. We define $l\in \mathbb{N}^+$ labeled regions of interest in free space and denote by $\mathcal{L}=\{\ell_k\}_{k\in[l]}$ the set of these regions, where $[l]$ is the shorthand notation for $\{1, \ldots, l\}$
We refer to a free cell in the workspace as the region-free cell if it is not inside any region, and a path connecting two different regions as the label-free path if it only passes through region-free cells.  We represent the workspace by a graph $E = (S, \to_E)$ where $S$ is the finite set of vertices corresponding to free cells and $\to_{E} \subseteq S \times S$ captures the adjacency relation.

 Given the workspace $E$, we consider a team of $n$ heterogeneous robots with different capabilities. We assume that these robots belong to $m$ types and every robot belongs to exactly one type. Moreover, let $\mathcal{K}_j, j\in[m]$,  denote the set that  collects all robots of type $j$, so that $\sum_{j\in [m]} |\ccalK_j| = n$ and $\ccalK_{j} \cap \ccalK_{j'} = \emptyset$ if $j \not= j'$, where $|\cdot|$ is the cardinality of a set. We collect all $n$ robots in the set $\ccalR$, i.e. $\ccalR = \{\ccalK_j\}_{j\in [m]}$. Finally, we define $[r,j]$ to represent robot $r$ of type $j$, where $r\in \ccalK_j, j\in [m]$. To capture the mobility of robot $[r,j]$ in the workspace, we define its transition system (TS) as follows:

\begin{defn}[(TS)]\label{def:ts}
  A transition system for robot $[r,j]$ is a tuple $\textup{TS}_{r,j} = \{S, s_{r,j}^0, \to_{r,j}, \Pi_{r,j}, L_{r,j}\}$ where: (a) $S$ is the set of locations of robot $[r,j]$, and we denote by $s_{r,j}^t \in S$ its location at time $t$; (b) $s_{r,j}^0$ is the initial location; (c) $\to_{r,j} \subseteq \to_{E} \cup_{s\in S} \{(s,s)\} $ is the transition relation, that is, robot is allowed to remain idle or move between adjacent cells; (d) $\Pi_{r,j} = \cup_{k\in [l]}\{p_{r,j}^k\} \cup \{\epsilon\}$ where the atomic proposition $p_{r,j}^{k}$ is true if robot $[r,j]$ is at region $\ell_k$, and $\epsilon$ means empty label; and (e) $L_{r,j}: S \to {\Pi_{r,j}} $ is the labeling function that returns the atomic proposition  satisfied at location $s_{r,j}^t$.
\end{defn}

Given the definition of a transition system, we define the product transition system (PTS), which captures all possible combinations of robot behaviors, as follows:
\begin{defn}[(PTS)]\label{def:pts}
  Given $n$ transition systems \textup{TS}$_{r,j} = \{S, s_{r,j}^0, \to_{r,j}, \Pi_{r,j}, L_{r,j}\}$, the product transition system  is a tuple $\textup{PTS} = (S^n, s^0, \to, \Pi, L)$ where (a) $S^n = S\times \cdots \times S$ is the finite set of collective locations. We let $s^t \in S^n$ collect all robot locations at time $t$%% , which requires that no more than one robots occupy the same free cell
  ; (b) $s^0$ is the initial locations of robots; (c) $\to \subseteq S^n \times S^n$ is the transition relation in which each robot follows its individual transition relation, i.e., $(s^t, s^{t+1}) \in \to$ if $s^t_{r,j}\rightarrow_{r,j} s^{t+1}_{r,j}$ for all $r\in \ccalK_j, \forall \,j \in [m]$;
  %% Specifically, $(s^t, s^{t+1}) \in \to$ if $s^t_{r,j}\rightarrow_{r,j} s^{t+1}_{r,j}$ for all $r\in \ccalK_j, \forall \,j \in [m]$ and there do not exist any two robots $[r,j]$ and $[r',j']$ such that $s^{t+1}_{r,j} = s^{t}_{r',j'}$ and $s^{t+1}_{r',j'} = s^{t}_{r,j}$. In words, each robot follows its transition relation and no two robots switch their locations;
  (d) $\Pi = \cup_{i\in[|\ccalK_j|], j\in [m], k\in [l]}\{\pi_{i,j}^k\} \cup \{\epsilon\}$, where the atomic proposition $\ap{i}{j}{k}$ is true if at least $i$ robots of type $j$, denoted by $\ag{i}{j}$, are at region $\ell_k$ at time $t$, i.e., $\ap{i}{j}{k} \Leftrightarrow |\{r\in \ccalK_j: L_{r,j}(s_{r,j}^t) = p_{r,j}^k \}| \geq i$; (e) and $L: S^n \to 2^{\Pi}$ is the labeling function that returns the set of atomic propositions satisfied by all robots at time $t$.
\end{defn}
\subsection{Task specification}
In this paper, we consider MRTA problems where the tasks are globally described by a fragment of LTL formulas called \ltl that exclude the operator ``next''. Consider the formula $\bigcirc \ap{i}{j}{k}$ that enforces $\ap{i}{j}{k}$ to be true at the next immediate step, which equivalently requires $\langle i,j \rangle$ to stay next to or at region $\ell_k$ at the current step. This requirement is time-critical and can be easily violated if robots are allowed to stutter~\citep{sahin2019multirobot}. Furthermore, we consider tasks where the same fleet of robots of certain types needs to visit different regions in sequence, e.g., to deliver objects between different workshops. To capture such tasks, we  define {\it induced} atomic propositions over $\Pi$ (see Definition~\ref{def:pts})  as follows:

\begin{defn}[(Induced atomic propositions)]
   For each atomic proposition $\ap{i}{j}{k} \in \Pi$, we define an infinite set of  {induced} atomic propositions $\{\ap{i}{j}{k,\chi}\}_{\chi\in \mathbb{N}}$, where $\chi$ is a connector that binds the truth of  atomic propositions with identical $i, j$ and $\chi$. Specifically, when $\chi=0$, $\ap{i}{j}{k,\chi}$ is equivalent to $\ap{i}{j}{k}$, whose truth is state-dependent. When $\chi \neq 0$, the truth of $\ap{i}{j}{k,\chi}$ is state-and-path-dependent, additionally depending on other induced atomic propositions that share the same $i,j$ and $\chi$. That is, both $\ap{i}{j}{k,\chi}$ and $\ap{i}{j}{k',\chi}$  with $\chi\not=0$, are true if it is the same $i$ robots of type $j$ that visit regions $\ell_k$ and $\ell_{k'}$. Furthermore, the truth of the negative atomic proposition  $\neg \ap{i}{j}{k,\chi}$ is equivalent to its basic counterpart $\neg \ap{i}{j}{k}$, i.e., less than $\ag{i}{j}$ are at region $\ell_k$.
\end{defn}
Let $\ccalA\ccalP$ collect all basic and induced atomic propositions and we denote by $\Sigma=2^{\ccalA\ccalP}$ its power set.  For the rest of this work, we omit the superscript $\chi$ when $\chi=0$. We denote by \ltlx and \ltlz the set of formulas defined over the set of basic and  induced atomic propositions and only the set of basic atomic propositions, respectively; \ltlz$\subset$ {\it LTL}$_{-\bigcirc}^\chi$.  Works exist addressing \ltlz formulas \citep{sahin2017provably,sahin2017synchronous,sahin2019multirobot}. However, to the best of my knowledge, this is the first work addressing \ltlx formulas. Next, we introduce the notion of {\it valid} temporal logic tasks.
 \begin{defn}[(Valid temporal logic task)]\label{defn:valid}
A temporal logic task specified by a\ltlx formula defined over $\ccalA\ccalP$ is valid if atomic propositions with the same nonzero connector $\chi$ involve the same number of robots of the same type.
 \end{defn}

 \begin{figure}[!t]
    \centering
    \includegraphics[width=0.5\linewidth]{gridworld.pdf}
    \caption{Illustration of the workspace and robot initial locations for the emergency response tasks; see Example~\ref{exmp:1}.}\label{fig:workspace}
\end{figure}
\begin{exmp}[(Emergency response)]\label{exmp:1}
 Consider an emergency response scenario (see Fig.~\ref{fig:workspace}) where three robots of type 1 (indicated by \inlinegraphics{star.pdf}) and two robots of type 2 (indicated by \inlinegraphics{bluedot.pdf}) are located at region $\ell_1$, $\ell_2$ is an office building where personnel got injured, $\ell_4$ is the damaged road that leads to the open area $\ell_3$, and region $\ell_5$ is another open area. We consider the following two rescue tasks: {\it (i)} \label{task:i} two robots of type 1 visit building $\ell_2$ to transport injured personnel to the safe open area $\ell_3$, and one robot of type 2 visits $\ell_4$ to clear the road before robots of type 1 reach the safe area $\ell_3$. {\it (ii)} \label{task:ii} One robot of type 1 travels between the building $\ell_2$ and the open area $\ell_3$ back and forth to transport valuable equipment. The considered tasks are complex compared to the conventional task allocation in the sense that temporal terms exist like ``before'' and ``back and forth''.

\end{exmp}


 \begin{cexmp} [(Valid and invalid formulas)]
Observe that in Fig.~\ref{fig:workspace}, the satisfied atomic propositions in $\Sigma$ are $\ap{3}{1}{1}$ and $\ap{2}{2}{1}$.   The valid formulas to specify the tasks \hyperref[task:i]{\it (i)} and \hyperref[task:ii]{\it (ii)} are: $\phi_1 = \lozenge \left(\left(\ap{2}{1}{2,1}\wedge \neg \ap{2}{1}{3}\right) \wedge  \lozenge \ap{2}{1}{3,1}\right)  \wedge \lozenge \ap{1}{2}{4} \wedge \neg \ap{2}{1}{3} \,\mathcal{U}\, \ap{1}{2}{4}$ and $ \phi_2 = \square \lozenge \left(\ap{1}{1}{2,1} \wedge \lozenge \ap{1}{1}{3,1}\right)$, respectively. However, formulas $\lozenge \left(\ap{1}{1}{2,1} \wedge \lozenge \ap{2}{1}{3,1}\right)$ and $\lozenge \left(\ap{2}{2}{2,1} \wedge \lozenge \ap{2}{1}{3,1}\right)$ are two invalid formulas due to different number $i$ of robots and robot types $j$, respectively.
 \end{cexmp}
A $h$-length path $\tau = s^0 \ldots s^h$ that captures the collective behavior of the team is such that $s^{t-1}\to s^{t}, \forall t\in[h]$. Given a valid\ltlx formula $\phi$, a  path $\tau$ that satisfies $\phi$ can be written in a prefix-suffix structure $\tau=\tau^{\text{pre}}[\tau^{\text{suf}}]^\omega$, where the prefix part  $\tau^{\text{pre}}=s^0 \dots s^{h_1}$ is executed once followed by the indefinite execution of the suffix part $\tau^{\text{suf}}=s^{h_1} \dots s^{h_1+h_2} s^{h_1+h_2+1}$, where $s^{h_1+h_2+1}=s^{h_1}$ \citep{baier2008principles}. We say a path $\tau$ satisfies $\phi$ if (a) the trace, defined as $\texttt{trace}(\tau):=L(s^0)\dots L(s^{h_1})[L(s^{h_1})\dots L(s^{h_1+h_2+1})]^{\omega}$,  belongs to $\texttt{Words}(\phi^0)$, where $\phi^0$ is obtained by replacing all induced atomic propositions in $\phi$ with their counterparts with zero connector; (b) it is the same $\ag{i}{j}$ that satisfy the induced atomic propositions $\ap{i}{j}{k,\chi}$ in $\phi$ that sharing the same nonzero connector $\chi$. In other words, not only do the satisfaction conditions restrict the label of the path, as in (a); but differentiate which robots participate in the satisfaction of induced atomic propositions, as in (b). If $\phi \in \textit{LTL}_{-\bigcirc}^0$, the satisfaction conditions only include (a).

\subsection{Problem Formulation}
Given a $h$-length path $\tau_{r,j} = s_{r,j}^0, s_{r,j}^1, \ldots, s_{r,j}^h$  for robot $[r,j]$, we define the cost of $\tau_{r,j}$  as $J(\tau_{r,j}) = \sum_{t=0}^{h-1} d(s_{r,j}^{t}, s_{r,j}^{t+1})$, where $d: S\times S \to \mathbb{R}^+\cup\{0\}$ is a cost function that maps a pair of free cells to a non-negative value, e.g., traveling distance. The cost of the path $\tau$ that combines all robot paths $\tau_{r,j}$ of length $h$ can be defined as
\begin{align}
  J(\tau) = \sum_{{r \in \ccalK_j, j \in [m]}} J(\tau_{r,j}),
\end{align}
For  plans written in prefix-suffix form, we get
\begin{align}\label{eq:cost}
J(\tau) = \beta J(\tau^{\text{pre}}) + (1-\beta) J(\tau^{\text{suf}}),
\end{align}
where $\beta\in [0,1]$ is a user-specified parameter. Finally,  the problem addressed in this paper can be  formulated as follows:
\begin{problem}\label{prob:1}
  Consider  a discrete workspace with labeled regions and obstacles, a team of $n$ robots of $m$ types, and a valid formula $\phi\in \textit{LTL}_{-\bigcirc}^\chi$. Plan a path for each robot such that the specification $\phi$ is satisfied, and the sum of the path costs in~\eqref{eq:cost} is minimized.
\end{problem}

We refer to Problem~\ref{prob:1} as multi-robot task allocation under LTL specifications, in short, LTL-MRTA, which is a single-task robot and multi-robot task (ST-MR) problem, where a robot is capable of one task, and a task may require multiple robots. Since the ST-MR problem is NP-hard~\citep{korsah2013comprehensive,nunes2017taxonomy}, so is the LTL-MRTA problem. Consequently, a non-hierarchical method  will be impractical for large-scale applications \citep{sahin2017provably,sahin2017synchronous}. In this work, we propose an hierarchical framework  to solve LTL-MRTA efficiently. To achieve the completeness of the hierarchical framework, next we  make  assumptions on the workspace and NBA translated from the specifications.

\subsection{Assumptions}
\subsubsection{Workspace:}
 The following assumption states that regions in the workspace are  well-organized and separated, e.g., office buildings and warehouses.
 \begin{asmp}[(Workspace)]\label{asmp:env}
 Regions are disjoint, and each one spans consecutive cells. There exists a region-free path between any two regions, between any two label-free cells, and between any label-free cells and any regions.
 \end{asmp}
 If regions are partially overlapping or span multiple clusters of cells, we can define additional atomic propositions to make them disjoint and span only consecutive cells.  Assumption~\ref{asmp:env} implies that there are no ``holes'' inside regions that generate different labels, label-free cells are connected, and each region is adjacent to a label-free cell.

\subsubsection{Nondeterministic B$\ddot{\text{u}}$chi Automaton (NBA):}\label{sec:nba}
Given a team of $n$ robots and an \ltlx formula $\phi$, to find a (sub-)optimal satisfying path $\tau$, we operate on the corresponding NBA $\autop = (\ccalV, \ccalE)$ of $\phi$, which can be constructed using the tools, such as LTL2BA developed by~\cite{gastin2001fast}; see also Fig.~\ref{fig:nba_iii} for the NBA of tasks~\hyperref[task:i]{\it (i)} and~\hyperref[task:ii]{\it (ii)}. Note that the NBA in Definition~\ref{def:nba} is essentially a graph. For the rest of the work, we refer to the NBA by the graph $\autop$ for notational convenience. In what follows, we pre-process the NBA $\autop$ to obtain an ``equivalent'' NBA in the sense that we do not lose any feasible path that satisfies the specification $\phi$, which prepares us for imposing restrictions on the NBA. Before that, we introduce some necessary notations.

For a transition $(q_B, \gamma, q'_B)\to_B$ in the NBA $\autop$, we assume that the propositional formula $\gamma \in \Sigma$ is  in {\it disjunctive normal form} (DNF), i.e,
$ \gamma = \bigvee_{p\in \ccalP} \bigwedge_{q\in \ccalQ_p} (\neg)\ap{i}{j}{k,\chi}$, where the negation operator can only precede the atomic propositions, $\ccalP$ and $\ccalQ_p$ are proper index sets. Note that any propositional formula has an equivalent formula in DNF~\citep{baier2008principles}. We call  $\ccalC_p^{\gamma}=\bigwedge_{q\in \ccalQ_p}(\neg) \ap{i}{j}{k,\chi}$ the $p$-th {\it clause} of $\gamma$ that includes a set $\ccalQ_p$ of positive and negative {\it literals} and each positive literal is an atomic proposition $\ap{i}{j}{k,\chi}\in \ccalA\ccalP$. Let $\mathsf{cls}(\gamma)$ denote the set of clauses $\ccalC_p^{\gamma}$ in $\gamma$. And let $\mathsf{lits}^+(\ccalC_p^{\gamma})$ and $\mathsf{lits}^-(\ccalC_p^{\gamma})$ be the {\it positive subformula} and {\it negative  subformula}, respectively,  of all positive literals and all negative literals in the clause $\ccalC_p^\gamma$, which, by default, are $\top$ (constant true) if the corresponding literals do not exist. Furthermore, we call the propositional formula $\gamma$ a {\it vertex label} if $q_B=q'_B$, otherwise, an {\it edge label}. In what follows, we do not consider self-loops when we refer to edges in $\autop$, since self-loops can be captured by vertices.   With a slight abuse of notation, let {$\gamma: \ccalV \to \Sigma $} and {$\gamma: \ccalV \times \ccalV \to \Sigma$} be the functions that map a vertex and edge in the NBA to its vertex label and edge label, respectively. Next, we  pre-process the NBA $\autop$ by removing infeasible clauses and merging redundant literals.  In particular, given  a vertex label or edge label $\gamma$ in $\autop$:
\paragraph{(1) Absorption in $\mathsf{lits}^+(\cp{p}{\gamma})$:} \label{prune:absorption1} For each clause $\cp{p}{\gamma} \in \clause{\gamma}$, we delete the positive literal $\ap{i}{j}{k} \in \mathsf{lits}^+(\cp{p}{\gamma})$ (replacing it with $\top$), if another $\ap{i'}{j}{k,\chi'} \in \mathsf{lits}^+(\cp{p}{\gamma})$ exists such that $i \leq i'$  since if $\ag{i'}{j}$ are at region $\ell_k$, i.e., $\ap{i'}{j}{k,\chi'}$ is true, so is  $\ap{i}{j}{k}$. Similarly, we replace $\ap{i}{j}{k}$ with $\ap{i-i'}{j}{k}$ if $i > i'$ since $i-i'$ robots suffice if $\ap{i'}{j}{k,\chi'}$ is true.

%% \endnote{\blue{Action is not taken when $\chi\not=0$.}}
 \paragraph{(2) Absorption in $\mathsf{lits}^-(\cp{p}{\gamma})$:} \label{prune:absorption2} We delete the negative literal $\neg \ap{i'}{j'}{k'} \in \mathsf{lits}^-(\cp{p}{\gamma})$, if another $\neg \ap{i'}{j}{k} \in \mathsf{lits}^-(\cp{p}{\gamma})$ exists such that $i' < i$.
\paragraph{(3) Mutual exclusion in $\mathsf{lits}^+(\cp{p}{\gamma})$:}\label{prune:exclusion1} We delete the clause $\cp{p}{\gamma} \in \mathsf{cls}(\gamma)$ (replacing it with constant false $\bot$ ) if there exist two positive literals $\ap{i}{j}{k,\chi}, \ap{i}{j}{k',\chi} \in \mathsf{lits}^+(\cp{p}{\gamma})$ such that $k\not= k'$ and $\chi\not=0$ since the same $i$ robots of type $j$  cannot be at different regions at the same time.
 \paragraph{(4) Mutual exclusion in $\mathsf{lits}^+(\cp{p}{\gamma})$  and $\mathsf{lits}^-(\cp{p}{\gamma})$:} \label{prune:exclusion2} We delete the clause $\cp{p}{\gamma} \in \mathsf{cls}(\gamma)$  if there exist a positive literal $\ap{i}{j}{k,\chi} \in \mathsf{lits}^+(\cp{p}{\gamma})$ and a negative literal $\neg \ap{i'}{j}{k} \in \mathsf{lits}^-(\cp{p}{\gamma})$ such that $i' \leq i$ since they are mutually  exclusive.
 \paragraph{(5) Violation of team size:} \label{prune:violation1}  For each clause $\cp{p}{\gamma} \in \clause{\gamma}$, let $\mathsf{lits}^+(j')$ denote literals in $\mathsf{lits}^+(\cp{p}{\gamma})$ that involve robots of type $j'$, i.e., $\mathsf{lits}^+(j') = \{\ap{i}{j}{k,\chi} \in \mathsf{lits}^+(\ccalC_p^\gamma)| j = j'\}$. We delete the clause $\cp{p}{\gamma}$   if the total required number of robots of type $j$ exceeds the size $|\ccalK_j|$, i.e., if there exists $j\in[m]$ such that $ \sum_{\ap{i}{j}{k,\chi}\in\mathsf{lits}^+(j)}   i > |\ccalK_{j}|$.

       It is worthy of noting that these pre-processing steps  merely  remove infeasible clauses and merge redundant literals, which does not compromise any accepting word in $\ccalL(\autop)$ that can be generated by a feasible path. Therefore, with a slight abuse of notation, we continue using $\autop$ to refer to the NBA of $\phi$ after pre-processing steps.


\begin{figure}[!t]
   \centering
   \subfigure[NBA $\autop$ for the task {\it (i)}]{
     \label{fig:nba_i}
     \includegraphics[width=0.8\linewidth]{nba_i.pdf}}
   \subfigure[NBA $\autop$ for the task {\it (ii)}]{
     \label{fig:nba_ii}
     \includegraphics[width=0.6\linewidth]{nba_ii.pdf}}
   \caption{NBA $\autop$ for tasks \hyperref[task:i]{\it (i)} and \hyperref[task:ii]{\it (ii)}.}
   \label{fig:nba_iii}
\end{figure}

 \begin{cexmp}[(Key observations on the pre-processed NBA $\autop$)]
   The pre-processed NBA corresponding to tasks \hyperref[task:i]{\it (i)} and \hyperref[task:i]{\it (ii)} are shown in Fig.~\ref{fig:nba_iii}. The vertex label is placed in the square bracket next to each vertex. After pre-processing, the NBA $\autop$ for task~\hyperref[task:i]{\it (i)} does not change, whereas some labels in the NBA $\autop$ for task \hyperref[task:i]{\it (ii)} become $\bot$ due to step~\hyperref[prune:exclusion1]{\it (3)}, which are highlighted in orange.

   In Fig.~\ref{fig:nba_i}, $\vertex{init}$ is the initial vertex and $v_6$ is the accepting vertex. Observe that all vertices have self-loops except the initial vertex $\vertex{init}$. In each accepting run, e.g., $\vertex{init}, v_1, v_2, v_3, v_6, v_6^\omega$, the satisfaction of the label of an edge implies the satisfaction of the label, if exists, of its end vertex. For instance, the label $\ap{2}{1}{2,1} \wedge \neg\ap{2}{1}{3}$ of the edge $(v_1, v_2)$ implies the label $\neg\ap{2}{1}{3}$ of vertex $v_2$, and  the label $\neg\ap{2}{1}{3}$ of the edge  $(\vertex{init}, v_1)$ implies the label $\neg\ap{2}{1}{3}$ of  its end vertex $v_1$. This is because once the edge is enabled, its end vertex label should be satisfied at the next time instant; otherwise, the progression in the NBA $\autop$ gets stuck.

   The same observation also applies to NBA in Fig.~\ref{fig:nba_ii} where vertex $\vertex{init}$ is both an initial and accepting vertex and $v_3$ is another accepting vertex.  The accepting run $\vertex{init}, v_2, v_3, (v_1, v_2, v_3)^\omega$ includes one pair of initial and accepting vertices, $\vertex{init}$ and  $v_3$, and the accepting run $\vertex{init}, v_2, v_1, \vertex{init}^\omega$ (although infeasible) includes one pair of initial and accepting vertices, $\vertex{init}$ and $\vertex{init}$. Note that we view the two $\vertex{init}$ vertices differently, one as the initial vertex and the other as the accepting vertex. Furthermore, the label $\ap{1}{1}{3,1}$ of the edge $(v_1, v_2)$  implies the label $\top$ of its end vertex $v_2$, so is the edge $(v_2, \vertex{init})$ and its end vertex $\vertex{init}$ (although infeasible). It is noteworthy that, even though the accepting vertex $v_3$ does not have a self-loop, the satisfaction of the label $\ap{1}{1}{2,1}$ of its incoming edge $(v_2, v_3)$ implies the label $\top$ of its outgoing edge $(v_3, v_1)$. Without this implication, the progression will get stuck at $v_3$ since the label $\ap{1}{1}{2,1} \wedge \ap{1}{1}{3,1}$ of edge $(v_3, \vertex{init})$ is infeasible and it takes more than one time steps between regions $\ell_2$ and $\ell_3$ (see Fig.~\ref{fig:workspace}), making the label $\ap{1}{1}{3,1}$ of edge $(v_3, v_2)$ unsatisfiable at the next time instant.
 \end{cexmp}


 Inspired by key observations about the NBA $\autop$ in the Example~\ref{exmp:1}, next we introduce the notion of {\it implication} and {\it strong implication} between two propositional formulas, and based on this, we define the {\it restricted accepting runs} in the NBA $\autop$ that are in the prefix-suffix structure. The completeness of our hierarchical framework relies on that the set of restricted accepting runs of an NBA $\autop$ is nonempty.

 \begin{defn}[(Implication and strong implication)]\label{defn:implication}
   Given two propositional formulas $\gamma$ and $\gamma'$ over $\ccalA\ccalP$, we say that formula  $\gamma$ implies $\gamma'$, denoted by $\gamma \simplies \gamma'$, if for each clause $\ccalC_{p}^{\gamma} \in \clause{\gamma}$, there exists a clause $\ccalC_{p'}^{\gamma'} \in \clause{\gamma'}$ such that  $\ccalC_{p'}^{\gamma'}$ is a subformula of $\ccalC_{p}^{\gamma}$, i.e., all literals in $\ccalC_{p'}^{\gamma'}$ also appear in $\ccalC_{p}^{\gamma}$. By default, $\top$ is a subformula of any clause. In addition, formula $\gamma$ strongly implies $\gamma'$, denoted by $\gamma \simplies_s  \gamma'$, if $\gamma \simplies \gamma'$, and for each clause $\ccalC_{p'}^{\gamma'} \in \clause{\gamma'}$, there exists a clause $\ccalC_{p}^{\gamma} \in \clause{\gamma}$ such that  $\ccalC_{p'}^{\gamma'}$ is a subformula of $\ccalC_{p}^{\gamma}$.
 \end{defn}

 Intuitively, if $\gamma \simplies \gamma'$, robot locations that satisfy $\gamma$ lead to the satisfaction of $\gamma'$.

 \begin{figure}[t]
  \centering
  \includegraphics[width=0.7\linewidth]{lasso.pdf}
  \caption{Graphical depiction of the accepting run in the prefix-suffix structure when $\vertex{accept}$ does not have a self-loop, which resembles a lasso. The shaded blue line and the orange loop represent the prefix and suffix part, respectively. The arrow indicates the progression direction and the gray circles indicate the self-loops.}
  \label{fig:lasso}
\end{figure}


\begin{defn}[(Restricted accepting runs)]\label{defn:run}
  Given an NBA $\autop$ (after pre-processing) corresponding to an \ltlx formula, we call any accepting run, in the prefix-suffix structure, $\rho = \rho^{\textup{pre}} [\rho^{\textup{suf}}]^\omega= v_0, \ldots, \vertex{prior}, \vertex{accept} [\vertex{next}, \ldots, \vertex{prior}', \vertex{accept}]^\omega$ (see Fig.~\ref{fig:lasso}), a restricted accepting run,  if it  meets the following conditions:
  \begin{noindlist}
    \setlength\itemsep{0em}
  \item \label{cond:a} Even though $v_0 $ and $ \vertex{accept}$ point to the same vertex (if any), they are viewed as different vertices.  There do not exist different vertices between any two identical vertices  in the prefix part  $v_0, \ldots, \vertex{prior}, \vertex{accept}$. In other words, the prefix part does not return to a vertex after leaving it. Similarly, there do not exist different  vertices  between any two identical vertices in the suffix part  $\vertex{next}, \ldots, \vertex{prior}', \vertex{accept}$, either. Moreover,  $\vertex{accept}$ appears only once  in the prefix and suffix parts, respectively, both at the end.
  \item \label{cond:b} There only exist one initial vertex $v_0$ and one  accepting vertex $\vertex{accept}$ in the accepting run (they can appear multiple times in a row), but different accepting runs can have different pairs of initial and accepting vertices;
  \item \label{cond:c} In the prefix part, only initial and accepting vertices, $v_0$ and $\vertex{accept}$, can be allowed not to have  self-loops, i.e., their vertex labels  can be $\bot$, while in the suffix part,  only accepting vertex $\vertex{accept}$ can be allowed not to have a self-loop;
  \item  \label{cond:d} For any two consecutive vertices $v_1$, $v_2$ in the accepting run $\rho$, if $v_1 \neq v_2$, $v_2\neq \vertex{accept}$ and $v_2$ has a self-loop, then the edge label $\gamma(v_1, v_2)$  strongly implies  the end vertex label $\gamma(v_2)$, i.e., $\gamma(v_1, v_2) \simplies_s \gamma(v_2)$;
   %% \item \label{cond:e} For any three consecutive vertices $v_1, v_2$ and $v_3$ in the accepting run, if $v_2 \neq v_{\vertex{accept}}$ and $v_2$ has a self-loop, then either $v_1 = v_2$ or $v_2 = v_3$, that is, the label of  vertex $v_2$ should be satisfied at least once;
   \item \label{cond:e} In the suffix part $\rho^{\textup{suf}}$, if $\vertex{accept} = \vertex{next}$ (this happens when $\vertex{accept}$ has a self-loop), then $\rho^{\textup{suf}}$ is reduced to only consisting of  $\vertex{accept}$. Meanwhile, the label of edge $(\vertex{prior}, \vertex{accept})$  implies the label of vertex $\vertex{accept}$, i.e., $\gamma(\vertex{prior}, \vertex{accept}) \simplies  \gamma(\vertex{accept})$;
 \item \label{cond:f} In the suffix part, if $\vertex{accept} \neq \vertex{next}$ (this can happen when $\vertex{accept}$  does not have a self-loop), then the label of edge $(\vertex{prior}, \vertex{accept})$ implies the label of edge $(\vertex{accept}, \vertex{next})$, i.e., $\gamma(\vertex{prior}, \vertex{accept}) \simplies  \gamma(\vertex{accept}, \vertex{next})$. Meanwhile, the label $\gamma(\vertex{prior}, \vertex{accept})$ implies the label of  edge $(\vertex{prior}', \vertex{accept})$, i.e., $\gamma(\vertex{prior}, \vertex{accept}) \simplies  \gamma(\vertex{prior}', \vertex{accept})$. Note that $\vertex{prior}$ and $\vertex{prior}'$ can be different.
  \end{noindlist}
 \end{defn}

In a nutshell, conditions~\hyperref[cond:a]{\it (a)} and~\hyperref[cond:b]{\it (b)} state that the restricted accepting run is  simple (no cycles, only including one pair of initial and accepting vertices), and conditions~\hyperref[cond:c]{\it (c)}-\hyperref[cond:f]{\it (f)} forbids requirements on the abrupt change of robot locations. In other words, robots are given adequate time to enable subsequent edges after progression reaches vertices.
 The definition of restricted accepting runs is not restrictive since many accepting runs can meet these conditions for temporal logic tasks in the robotics applications, such as coverage, sequencing, etc. For instance, the sets of restricted accepting runs in the NBA $\autop$ for tasks~\hyperref[task:i]{\it (i)} and~\hyperref[task:ii]{\it (ii)} are nonempty. In what follows, we clarify these conditions in detail.

For condition~\hyperref[cond:a]{\it (a)}, as $v_0$ and $\vertex{accept}$ mark different advancements towards task completion, it is reasonable to treat them  differently. The cycle segment is redundant if the run traverses back after leaving it. Therefore, if we aggregate consecutive identical vertices into one single vertex, there are no identical vertices in the prefix part. The same applies to the suffix part. The prefix and suffix parts end once  $\vertex{accept}$ is reached, as in~\cite{smith2010optimal}.
      For condition~\hyperref[cond:b]{\it (b)}, the accepting run in Section~\ref{sec:ltl} is defined over a pair of initial and accepting vertices. In Section~\ref{sec:app}, we seek to extract the sub-NBA from the NBA $\autop$ for each pair of initial and accepting vertices, reducing the size of the sub-NBA.

      For condition~\hyperref[cond:c]{\it (c)}, if a vertex does not have a self-loop, then one of its incoming edge labels  and one of its outgoing edge labels  must be enabled at two consecutive time instants. For instance, if the NBA $\autop$ traverses edges $(v_2, v_3)$ and $(v_3, v_2)$ in Fig.~\ref{fig:nba_ii}, subformula $\ap{1}{1}{3,1}$ must be satisfied right after $\ap{1}{1}{2,1}$, which means a robot  must visit region $\ell_3$ immediately after reaching $\ell_2$. This temporal property is not aligned with the semantics of temporal operators like $\ccalU$, $\lozenge$ and $\square$. Based on condition \hyperref[cond:c]{\it (c)}, we   remove some vertices without self-loops from the NBA in Section~\ref{sec:prune}, further reducing its size.

      Moreover, conditions \hyperref[cond:d]{\it (d)} and \hyperref[cond:e]{\it (e)} are similar to~\hyperref[cond:c]{\it (c)} in the sense that  the satisfaction of the edge label $\gamma(v_1, v_2)$ should facilitate the satisfaction of the end vertex label $\gamma(v_2)$ since the end vertex label needs to be satisfied immediately after the edge label. %% In Sections~\ref{sec:app} and~\ref{sec:solution}, we first consider a relaxed NBA where all negative literals are ignored, and then re-consider negative literals in Section~\ref{sec:solution2mrta}. The conditions \hyperref[cond:d]{\it (d)} and \hyperref[cond:e]{\it (e)} ensure that the plan obtained by only considering the positive subformulas can be modified to accommodate the ignored negative subformula.
      In Appendix~\ref{sec:discussion}, we will discuss the relaxation of strong implication to implication.
      %% by preventing the mutual exclusions between positive and negative subformulas.
\begin{figure*}[!t]
   \centering
\includegraphics[width=\linewidth]{overview.pdf}
   \caption{Schematic overview of the proposed method.  The first five boxes correspond to the relaxation stage and the last two constitute the correction stage.}
\label{fig:overview}
\end{figure*}

      Finally, prefix and suffix parts of an accepting run can be addressed separately based on condition~\hyperref[cond:f]{\it (f)}, since  $\gamma(\vertex{prior}, \vertex{accept}) \simplies  \gamma(\vertex{accept}, \vertex{next})$  ensures that the robot locations enabling the last edge in the prefix part also enables the first edge in the suffix part. Otherwise, the progression may get stuck since these two edge labels need to be satisfied at two consecutive time instants, similar to conditions~\hyperref[cond:d]{\it (d)} and \hyperref[cond:e]{\it (e)}. Also, as the suffix part of a satisfying path is a loop, robots need to return to their initial locations of the suffix part after completing one round. The implication $\gamma(\vertex{prior}, \vertex{accept}) \simplies  \gamma(\vertex{prior}', \vertex{accept})$ indicates that the robot initial locations of the suffix part enable the edge  $(\vertex{prior}', \vertex{accept})$, which ensures that the robots can travel back to initial locations of the suffix part to make trajectory loops and meanwhile, drive the transition in  $\autop$ back to  vertex $\vertex{accept}$ to repeat the suffix part $\rho^{\text{suf}}$.

      \subsubsection{Satisfying paths:}
We emphasize that the definition of the restricted  accepting runs only takes into account the structure of the  NBA and logical implication relations. How the robot paths induce such a restricted accepting run  is beyond the scope of the definition. Next, we make assumptions regarding the robot paths.
\begin{asmp}[(Satisfying paths of restricted accepting runs)]\label{asmp:same}
  Given a team of $n$ robots and a valid specification $\phi \in \textit{LTL}_{-\bigcirc}^\chi$, if the robot path $\tau$ induces a restricted accepting run, then we assume that  (a)\label{asmp:a} every time a vertex label is satisfied, it is always the same clause in this vertex label that is satisfied, and further it is the same fleet of robots that satisfy this clause; (b)\label{asmp:b} the satisfied clause in an edge label implies the satisfied clause in its end vertex label if its end vertex label is satisfied at least once by the path, and further the fleet of robots satisfying the positive subformula of the clause in the end vertex label, if any, belongs to the fleet of robots satisfying the positive  subformula of the clause in the corresponding edge label;
  %% (c)\label{asmp:c} the fleet of robots that satisfy the positive subformula in certain clause of the edge $(\vertex{prior}, \vertex{accept})$ in the prefix part returns to their respective regions when the label of the edge $(\vertex{prior}', \vertex{accept})$ is satisfied in the suffix part.
  (c)\label{asmp:c} robot locations  enabling the edges $(\vertex{accept}, \vertex{next})$ and  $(\vertex{prior}', \vertex{accept})$ in the suffix part are identical to robot locations enabling the  edge $(\vertex{prior}, \vertex{accept})$ in the prefix part.
\end{asmp}

Assumption~\ref{asmp:same} is closely related to the restricted accepting runs. Specifically, by condition~\hyperref[cond:a]{\it (a)} in Definition~\ref{defn:run}, each vertex in a restricted accepting run can only be visited within a consecutive time period.  Once locations of a fleet of robots satisfy a  vertex label, they can remain idle to maintain the satisfaction of the same clause in this vertex label, meeting condition~\hyperref[asmp:a]{\it (a)} in Assumption~\ref{asmp:same}. Furthermore, by condition~\hyperref[cond:d]{\it (d)} in Definition~\ref{defn:run}, once locations of a fleet of  robots satisfy an edge label, they can remain idle at the next time instant, leading to the satisfaction of the clause in the end vertex label that the satisfied clause in the edge label implies. Thus, condition~\hyperref[asmp:b]{\it (b)} is  met. As for condition~\hyperref[asmp:c]{\it (c)}, the robot locations  enabling the edge $(\vertex{prior}, \vertex{accept})$ in the prefix part are the initial locations of the suffix part, which can enable the edge  $(\vertex{prior}', \vertex{accept})$ according to condition~\hyperref[cond:f]{\it (f)} in Definition~\ref{defn:run}. Therefore, condition~\hyperref[asmp:c]{\it (c)} demands that the robots travel along a loop when advancing the infinite number of repetitions of the suffix part.





%% \subsection{Outline of the LTL-MRTA Algorithm}
%% { \begin{algorithm}[t]
%%       \caption{Outline of the LTL-MRTA Algorithm}
%%       \LinesNumbered
%%       \label{alg:frame}
%%       \KwIn {workspace $\ccalW$,  robot team $\{\ccalK_j\}$\\ \quad \quad \quad
%%        \ltlx formula $\phi$}
%%       Translate $\phi$ into an NBA $B_o$ \label{frame:nba}\Comment*[r]{\ref{sec:prune}}
%%       Prune $B_o$ and do replacing to get $B_r$ \label{frame:prune}\Comment*[r]{\ref{sec:prune}}
%%       Sort pairs of initial and accepting vertices in ascending order by the total length\label{frame:sort} \Comment*[r]{\ref{sec:pregraph}}
%%       \For{each pair in the sorted order}{
%%         \Comment*[r]{Find robot prefix paths}
%%         Extract the sub-NBA $B_s$\ and prune $B_s$ \label{frame:sub-NBA}\Comment*[r]{\ref{sec:pregraph}}
%%         Extract subtasks from $B_s$ and infer the poset with the largest width \label{frame:poset}\Comment*[r]{\ref{sec:poset}}
%%         Build the MILP graph; see also Alg.~\ref{alg:milpgraph} \label{frame:milpgraph}\Comment*[r]{\ref{sec:graph}}
%%         Formulate the MILP and solve it \label{frame:milp} \Comment*[r]{\ref{sec:milp}}
%%         Extract high-level plans  \label{frame:path} \Comment*[r]{\ref{sec:path}}
%%         Identify the accepting run in $B_r$ \label{frame:run} \Comment*[r]{\ref{sec:run}}
%%         Solve generalized  multi-robot path planning to obtain executable paths\label{frame:mapp} \Comment*[r]{\ref{sec:mapp}-\ref{sec:solution2mapp}}
%%         \Comment*[r]{Find robot suffix paths
%%         }
%%         Repeat lines~\ref{frame:sub-NBA}-\ref{frame:mapp} \label{frame:suffix} \Comment*[r]{\ref{sec:suf}}
%%       }
%% Select the plan with the lowest cost according to~\eqref{eq:cost} \label{frame:cost}
%%  \end{algorithm}}
\subsection{Outline of the proposed method}
           { The schematic overview of our proposed method is shown in Fig.~\ref{fig:overview}, which consists of {\it relaxation} and {\it correction} stages.  The adoption of this relaxation-and-correction framework, also a hierarchical framework, comes from the observation that MILP formulation is a well-studied approach in the literature on task allocation and vehicle routing problems, and powerful multi-robot path planning methods for points-to-points navigation exists. To leverage the formulation of MILP, we first ignore the negative literals in the NBA $\autop$, %% In this way, temporal relations among subtasks can be better exploited, and existing work on vehicle routing problems can inspire scalable techniques to solve the allocation of subtasks.
         and then  the negative literals are  considered in the low-level executable path generation by leveraging state-of-the-art multi-robot path planning techniques.

         Specifically, the first stage is referred to as the {\it relaxation} stage, which produces a high-level plan that ignore  negative literals  in the NBA $\autop$; see also the first five blocks inside the orange box in~Fig.~\ref{fig:overview}. To this end, we first prune the NBA $\autop$ by deleting infeasible transitions and remove negative subformulas  so that the satisfaction of the transitions (referred to also as subtasks that are defined later) in the relaxed NBA requires multi-robots to meet at certain regions; see Section~\ref{sec:prune}. Then based on  a selected pair of initial and accepting vertices, we extract a sub-NBA  from the relaxed NBA that covers as many transitions as possible; see Section~\ref{sec:pregraph}. Next, by associating each transition in the sub-NBA with a subtask, we extract a set of subtasks from the sub-NBA and infer the temporal relation by mining a set of posets; see Section~\ref{sec:poset}. What follow are the construction of the routing graph that captures the regions that robots need to visit to satisfy these subtasks and the temporal order of the visit (see Sections~\ref{sec:graph}), and the formulation of a MILP based on the vehicle routing problem (see Section~\ref{sec:milp}). In this way, a high-level plan provides a sequence of regions that each robot needs to visit in order; see Section~\ref{sec:path}. Next, as shown in the last two blocks inside the green box in Fig.~\ref{fig:overview}, the {\it correction} stage follows where the high-level plan is adjusted and concretized to low-level executable paths by solving a sequence of generalized multi-robot path planning problems that account for the ignored negative literals; see Appendix~\ref{sec:solution2mrta}. With mild assumptions, the completeness of our proposed method is proven in Theorem~\ref{thm:completeness} in Section~\ref{sec:correctness}.

\begin{rem}
The proposed method is not limited to  LTL$_{-\bigcirc}^\chi$ formulas. It can also be applied to  formulas that include the ``next'' operator but have a nonempty set of restricted accepting runs, such as $\lozenge\left(\ap{1}{1}{2,1} \wedge \bigcirc \left(\ap{1}{1}{2,1} \,\ccalU\, \ap{1}{2}{2}\right)\right)$ and $\lozenge \left(\ap{1}{1}{2}  \wedge \bigcirc \lozenge \ap{1}{2}{2}\right)$; see Section~\ref{sec:sim} for simulations. Also, the workspace does not necessarily satisfy Assumption~\ref{asmp:env}, as Fig.~\ref{fig:workspace} in Example~\ref{exmp:1} where no label-free paths between regions~$\ell_3$ and $\ell_5$. In Section~\ref{sec:sim}, various specifications are satisfiable using this workspace.
\end{rem}

\begin{rem}
We emphasize that our goal is to synthesize a set of robot paths to satisfy the given specification, which may not satisfy Assumption~\ref{asmp:same}. As shown in the theoretical analysis of Section~\ref{sec:correctness}, the existence of such paths satisfying Assumption~\ref{asmp:same} is essential to establish the completeness of our proposed method.
\end{rem}

\section{Extracting Subtasks and Inferring the Temporal Order from the NBA}\label{sec:app}
In this section, we discuss the relaxation stage by only considering positive literals in the NBA $\autop$. Our goal is to extract a set of subtasks from the relaxed NBA  and then infer the temporal order, dependent or independent, among these subtasks, which corresponds to blocks \circled{1} and \circled{2}
in Fig.~\ref{fig:overview}.
\subsection{{Pruning and relaxation of the NBA}}\label{sec:prune}

We begin with pruning and relaxing the NBA $\autop$. Given an NBA $\autop$, the following steps are taken to prune $\autop$ by removing infeasible transitions.  Later, when we introduce the notion of subtasks based on edges in the NBA, pruning reduces the number of subtasks that need to be considered.

Specifically, we delete all edges labeled with $\bot$, as they cannot be enabled.  We also delete all vertices without self-loops except the initial and accepting vertices, which is justified by condition \hyperref[cond:c]{\it (c)} in Definition~\ref{defn:run}. Furthermore, by condition~\hyperref[cond:d]{\it (d)}  in Definition~\ref{defn:run}, for any vertex other than the accepting vertex, we delete any of its incoming edges if the corresponding edge label does not strongly imply its vertex label. Finally, we delete every vertex, except the initial vertex, that cannot be reached by other vertices.
%\end{noindlist}

We denote by $\autop^-$ the resulting NBA.    It is worthy of noting that  this pruning process does not compromise any feasible solution to Problem~\ref{prob:1} that induces a restricted accepting run in $\autop$, as shown in~Lemma~\ref{prop:prune} in Appendix~\ref{app:correctness}. Given the pruned NBA $\autop^-$, we further relax it by replacing each negative literal in vertex or edge labels with $\top$. Let $\auto{relax}$ denote the relaxed NBA. Note that, when the specification $\phi$ does not involve negative atomic propositions, we have  $\auto{relax} = \autop^-$.  Furthermore, Lemma~\ref{prop:inclusion} states that the language accepted by $\autop^-$ is included in the language accepted by $\auto{relax}$, so we do not remove feasible solutions to Problem~\ref{prob:1}. In other words, $\auto{relax}$ is an over-approximation of $\autop^-$. This is why the correction stage  is required to modify the solution obtained from $\auto{relax}$ in order to satisfy $\phi$.  Note that $\autop^-$ and $\auto{relax}$  are sub-NBA  of $\autop$ in terms of vertices and edges. Thus, given notions such as labels and runs in $\autop^-$ and $\auto{relax}$, we can map them to $\autop$  obtaining the corresponding notions. For the rest of the paper, given a notion in any NBA derived from $\autop$, e.g., $\auto{relax}$, we denote by $(\cdot)_{\phi}$ its counterpart in $\autop$. For instance, for a specific edge label $\gamma$ in $\auto{relax}$, we denote by $\gamma_{\phi}$ the corresponding label in $\autop$ (including the negative literals).

\begin{figure}
  \centering
  \subfigure[$\auto{relax}$ for task {\it (i)}]{
    \includegraphics[width=0.5\linewidth]{nba_i_relax.pdf}\label{fig:nba_i_relax}}
   \subfigure[$\auto{relax}$ for task {\it (ii)}]{
     \includegraphics[width=0.35\linewidth]{nba_ii_prune.pdf}\label{fig:nba_ii_prune}}
   \caption{The relaxed NBA $\auto{relax}$ for tasks~\hyperref[task:i]{\it (i)} and~\hyperref[task:ii]{\it (ii)}.}
   \label{fig:relax}
\end{figure}


\begin{cexmp}[(Pruning and relaxation of the NBA $\autop$)]
   The pruned NBA $\autop^-$ of the NBA  for the task \hyperref[task:i]{\it (i)} is the same as its original NBA in Fig.~\ref{fig:nba_i}. The relaxed NBA $\auto{relax}$ is shown in Fig.~\ref{fig:nba_i_relax}. The pruned NBA $\autop^-$ for the task \hyperref[task:ii]{\it (ii)} is the same as the relaxed NBA $\auto{relax}$ which is shown in Fig.~\ref{fig:nba_ii_prune}. Particularly, $\autop^-$  is obtained from $\autop$ in Fig.~\ref{fig:nba_ii} by removing edges $(v_1, \vertex{init}), (v_2, \vertex{init}),  (v_3, \vertex{init})$ and replacing $\gamma(\vertex{init})$ with $\bot$.
\end{cexmp}



  \subsection{Extraction of sub-NBA \upshape  $\auto{subtask}$  from $\auto{relax}$}\label{sec:pregraph}
  In this section, we first introduce the notion of subtasks, then exploit the structure of the NBA $\auto{relax}$ by decomposing it into sub-NBA such that each sub-NBA corresponds to one selected pair of initial and accepting vertices (see also block \circled{1} in Fig.~\ref{fig:overview}), and next extract subtasks along with inferring their temporal order in  Section~\ref{sec:poset}. In Section~\ref{sec:solution}, the extracted subtasks with inferred temporal order are used to synthesize a high-level plan that can induce a path in $\auto{relax}$ that connects the selected pair of initial and accepting vertices and a cycle around the accepting vertex.
\subsubsection{Subtasks:}\label{sec:subtask}
Consider an edge $e = (v_1, v_2) $  and its starting vertex $v_1$ in an NBA $\auto{}$, e.g., $\autop^-$ or $\auto{relax}$.  Assume that  currently  $\auto{}$ is at vertex $v_1$. To transition to $v_2$, certain robots need to simultaneously reach certain regions  or avoid certain regions to make $\gamma(v_1, v_2)$ true, while maintaining  $\gamma(v_1)$ true en route. We assume that the transition to $v_2$ occurs immediately once $\gamma(v_1, v_2)$ becomes true. Based on this interpretation, we formally define the subtask below.
\begin{defn}[(Subtask)]\label{defn:subtask}
 {A subtask is equivalent to an edge $(v_1, v_2)$ in the NBA $\auto{}$.}
\end{defn}

The goal of this subtask is to transition to vertex $v_2$. Informally speaking, an edge $e$ in $\auto{}$, particularly $\auto{relax}$, captures a subtask that specifies a set of \textit{target regions} that should be visited by robots of certain types. Subtasks can be viewed as generalized reach-avoid tasks where  specific types of robots are driven to desired target regions (the "reach" part of the task) while satisfying the vertex label along the way (the "avoid" part of the task. Avoidance here is defined in a more general way compared to the conventional definition that requires robots to stay away from given regions in space). Note that it is the label of the starting vertex $v_1$ and the label of the edge $(v_1, v_2)$ that characterize the subtask. %% Next, we introduce the activation and completion time of a subtask or its starting vertex label.
%% \begin{defn}[(Activation and completion time of a subtask or its starting vertex label)]\label{defn:time}
%% Given a subtask $e = (v_1, v_2)$, we define the  activation time of a subtask (or of its starting  vertex label) as when its vertex label $\gamma(v_1)$ turns true, and the completion time  of a subtask (or of its starting vertex label) as when its edge label $\gamma(v_1, v_2)$ becomes true (or the last time its starting vertex label $\gamma(v_1)$ is true). The span of a subtask (or its starting vertex label) starts from the activation time and ends at the completion time.
%% \end{defn}x
Next we define  the notion of equivalent subtasks.
\begin{defn}[(Equivalent subtasks)]\label{defn:eq}
 Subtasks $(v_1, v_2)$ and $(v'_1, v'_2)$ in an NBA $\auto{}$ are equivalent, denoted by $(v_1, v_2) \sim (v'_1, v'_2)$, if $\gamma(v_1) = \gamma(v'_1)$, $\gamma(v_1, v_2)=\gamma(v_1', v'_2)$ and they  are not in the same path that connects the same  pair of initial and accepting vertices.
\end{defn}

 The last condition in Definition~\ref{defn:eq} is necessary since two subtasks in the same path mark different progressions towards task completion, even if they have identical labels.
\begin{cexmp}[(Subtasks)]
  The relaxed NBA  $\auto{relax}$ captures high-level plans composed of subtasks that need to be satisfied in specific orders to reach the accepting vertex. For instance, the path $\vertex{init}, v_1, v_4, v_3, v_6$ in Fig.~\ref{fig:nba_i_relax} represents a high-level plan where first $\langle1,2\rangle$ visits region $\ell_4$, then $\langle2,1\rangle$ visit region $\ell_2$ and finally the same two robots of type 1 visit region $\ell_3$. By the interpretation of task \hyperref[task:i]{\it (i)}, the temporal order between these subtasks specifies that the time when $\langle1,2\rangle$ visits region $\ell_4$ is independent from the time when $\langle2,1\rangle$ visit region $\ell_2$, and that $\langle1,2\rangle$ visiting region $\ell_4$ and $\langle2,1\rangle$  visiting region $\ell_2$ should occur prior to $\langle2,1\rangle$ visiting region $\ell_3$.
\end{cexmp}

In the rest of Section~\ref{sec:app} and in Section~\ref{sec:solution}, we focus on the relaxed NBA $\auto{relax}$ and design high-level plans that specify the sequence of regions that the robots should visit and the corresponding timeline.



%% \subsubsection{Revisit of the prefix-suffix structure of accepting runs}\label{sec:presuf}
%% \blue{Recall in Section~\ref{sec:ltl} that the prefix part connects an initial vertex $v_0$ to an accepting vertex $\vertex{accept}$, and the suffix part connects the accepting vertex $\vertex{accept}$ to itself. In what follows, assisted by Fig.~\ref{fig:lasso}, we discuss the prefix-suffix structure of accepting runs in the NBA $\auto{relax}$ in two cases based on the presence or absence of the vertex label of  $\vertex{accept}$.
%%   \domanda{(i) Presence of \upshape$\gamma(\vertex{accept})$}\label{sec:presence} If the robots reach locations that drive the transition in NBA $\auto{relax}$ to the accepting vertex $\vertex{accept}$ with $\gamma(\vertex{accept})\neq\bot$ and remain idle thereafter, the suffix part of the accepting run of $\auto{relax}$ only contains $\vertex{accept}$; see Fig.~\ref{fig:lasso}.
%%   \domanda{(ii) Absence of \upshape $\gamma(\vertex{accept})$}\label{sec:absence} For the suffix part, not only do the transitions in the NBA $\auto{relax}$ occur along a cycle around $\vertex{accept}$, but also robots need to travel back to some locations to make their trajectories loops, thus, synchronizing and restarting the inifite execution. Let $v_{\text{prior}}$ and $v_{\text{next}}$ denote the vertices that right before and after $v_{\text{acccept}}$ in a cycle around $\vertex{accept}$, and $v'_{\text{prior}}$ denote the vertex right before $\vertex{accept}$ in the prefix part; see also Fig.~\ref{fig:lasso}. If  the edge label $\gamma(\vertex{accept}, v_{\text{next}})$ in $\auto{relax}$ is not $\top$, then robots need to satisfy $\gamma(\vertex{accept}, v_{\text{next}})$ immediately after the satisfcatoin of the edge label $\gamma(v'_{\text{prior}}, \vertex{accept})$ (due to $\gamma(\vertex{accept}) = \bot$) and further satisfy the vertex label $\gamma(v_{\text{next}})$ at the next time instant. Thus, if these two edges are addressed separately such that one is considered when designing the prefix plan and  the other is considered  when desinging the suffix plan, it is possible that robots can not visit regions that satisfy $\gamma(\vertex{accept}, v_{\text{next}})$ immediately after the satisfaction of $\gamma(v'_{\text{prior}}, \vertex{accept})$ and further $\gamma(v_{\text{next}})$ at the next time instant. That is, the termination of the prefix part cannot successfully transition to the activation of the suffix part.  The same issue occurs to the case where one round of cycle ends up at $\vertex{accept}$ and the the satisfaction of $\gamma(v_{\text{prior}}, \vertex{accept})$ might not lead to the satisfaction of $\gamma(\vertex{accept}, v_{\text{next}})$. To overcome this issue, we extend the prefix plan and let the last part of the prefix plan drive the transition one step further to $v_{\text{next}}$ and the final locations of the prefix plan satisfy its vertex label $\gamma(v_{\text{next}})$; see also the shaded prefix plan in Fig.~\ref{fig:lasso}, In this way, the prefix part and the cycle partially overlap.}

%%   %% first need to satisfy $\gamma(\vertex{accept}, v_{\text{next}})$ immediately after the satisfcatoin of the edge label $\gamma(v_{\text{prior}}, \vertex{accept})$ (due to $\gamma(\vertex{accept}) = \bot$) when they are about to finish one round along the cycle, and what's more, they also need to travel back to initial locations of the suffix part, i.e., final locations of the prefix part that drives the transition to the accepting state $\vertex{accept}$, to close the trajectory loop and synchronize. However, the issue is that it is possible that robots can not visit regions that satisfy $\gamma(\vertex{accept}, v_{\text{next}})$ immediately after the satisfaction of $\gamma(v_{\text{prior}}, \vertex{accept})$ if they are addressed . Even so, traveling back to initial locations might violate the vertex label $\gamma(v_{\text{next}})$. To overcome this issue, we extend the prefix plan and let the last part of the prefix plan drive the transition one step further to $v_{\text{next}}$ and the final locations of the prefix plan satisfy its vertex label $\gamma(v_{\text{next}})$; see also the shaded prefix plan in Fig.~\ref{fig:lasso}, so that the edge label $\gamma(\vertex{accept}, v_{\text{next}})$ is satisfied while robots head towards their initial locations.

  \subsubsection{Sorting the pairs of initial and accepting vertices by path length:}\label{sec:sort}  As stated in condition \hyperref[cond:b]{\it (b)} of Definition~\ref{defn:run}, each restricted accepting run  contains  one pair of initial and accepting vertices. In what follows, we sort the pairs of initial and accepting vertices in terms of the shortest length of the accepting run connecting them.  Then in Section~\ref{sub-NBA:1}, we extract a sub-NBA for each pair by following the order. It is beneficial to deal with one sub-NBA at a time  rather than the whole NBA $\auto{relax}$ due to the reduced size.

  \paragraph{(1) Computation of the shortest simple path:} Given a pair of initial vertex $v_0$ and accepting vertex $\vertex{accept}$ in $\auto{relax}$, we first compute  the shortest simple path from  $v_0$ to $\vertex{accept}$ in terms of the number of edges/subtasks,  where a simple path does not contain any  repeating vertices, echoing with condition~\hyperref[cond:a]{\it (a)} in Definition~\ref{defn:run} that no cycles exist in each separate part.
  To this end, we first remove all other initial vertices and accepting vertices from $\auto{relax}$. This will not affect those restricted  accepting runs that contain $v_0$ and $\vertex{accept}$ due to condition \hyperref[cond:b]{\it (b)}  in Definition~\ref{defn:run}.  Then, for the initial vertex $v_0$, we continue depending on whether it has a self-loop:

  \refstepcounter{phase}
\subphase{if $v_0$ does not have a self-loop, i.e., $\gamma(v_0)=\bot$}{In this case, for each outgoing edge of $v_0$ in $\auto{relax}$ labeled with $\gamma$,  we remove this edge  if the initial robot locations do not satisfy the corresponding edge label $\gamma_{\phi}$ (including the negative literals) in $\autop$. We emphasize that the satisfaction check should be conducted in the NBA $\autop$ since if initial robot locations cannot enable an edge starting from $v_0$ in $\autop$, there is no point in considering this edge in any NBA.}\label{sec:initial}

\subphase{if $v_0$ has a self-loop, i.e., $\gamma(v_0)\neq\bot$}{We check whether the initial robot locations satisfy $\gamma_{\phi}(v_0)$. If yes, we do nothing; otherwise, this case is the  same as case~\ref{sec:initial} and thus, we remove the self-loop of $v_0$ and further
remove any of its  outgoing edges  from $\auto{relax}$ if the initial robot locations do not satisfy the corresponding edge label $\gamma_{\phi}$ in $\autop$.}


Next, the shortest simple path connecting $v_0$ and $\vertex{accept}$ can be found using Dijkstra's algorithm.  Note that if a vertex is both an initial and accepting vertex, we view it differently, one as the initial vertex and one as the accepting vertex, although it appears twice in the shortest simple path.
\paragraph{(2) Computation of the shortest simple cycle:} Next, we compute the shortest simple cycle around $v_\text{accept}$ in $\auto{relax}$, where repeating vertices only appear at the first and last. Note that this $\auto{relax}$ is a copy of the original one  obtained from $\autop^-$. Thus, operations made to  find the shortest simple  path will not affect this $\auto{relax}$. If $\vertex{accept}$ in $\auto{relax}$ has a self-loop, the length of the shortest simple cycle is 0. Otherwise, similar to finding the shortest simple path, we first remove all other accepting vertices from~$\auto{relax}$ and then remove all initial vertices (including $v_0$) if they do no have self-loops.  In this way, the only vertex that does not have a self-loop is the accepting vertex $\vertex{accept}$.  This will not affect those restricted accepting runs that are related to  $v_0$ and $\vertex{accept}$  due to conditions \hyperref[cond:b]{\it (b)} and \hyperref[cond:c]{\it (c)} in Definition~\ref{defn:run}.


  By default, if no simple path or cycle exists, the length is infinite. After obtaining the shortest simple path and cycle, we assign their total length to the given pair of initial and accepting vertices.  Finally,  we sort all pairs of initial and accepting vertices in ascending order in terms of the total length. We prefer the pair with the shorter length since it contains fewer subtasks to be completed.}
%% \begin{figure}[!t]
%%   \centering
%%   \subfigure[$\gamma(\vertex{accept}) \neq \bot$]{
%%       \label{fig:presence}
%%       \includegraphics[width=0.3\linewidth]{presence.pdf}}
%%   \subfigure[$\gamma(\vertex{accept}) = \bot$]{
%%       \label{fig:absence}
%%       \includegraphics[width=0.6\linewidth]{absence_presuf.pdf}}
%%   \caption{Fig.~\ref{fig:presence} depicts the sub-NBA for the prefix and suffix parts with the presence of $\gamma(\vertex{accept})$ and Fig.~\ref{fig:absence} depicts the sub-NBA for the prefix and suffix parts, respectively, with the absence of $\gamma(\vertex{accept})$.}
%%   \label{fig:presuf}
%% \end{figure}


  \subsubsection{Extraction of the sub-NBA \upshape $\auto{subtask}$:}\label{sub-NBA:1}
  We iterate over the sorted pairs of initial and accepting vertices. Given a pair of vertices  $v_0$ and $v_\text{accept}$ whose total length is not infinite, we seek to find  high-level plans that induce simple paths in $\auto{relax}$  connecting this pair, and a simple cycle around $\vertex{accept}$. To do this,  we extract one sub-NBA for the prefix part and one for the suffix part from the NBA $\auto{relax}$, respectively.  Here, we discuss the sub-NBA for the prefix part. The  sub-NBA for the suffix part is similar and will be  discussed in Section~\ref{sec:suf}.  Given the pair of vertices $v_0$ and $\vertex{accept}$, we construct a prefix sub-NBA $\auto{subtask}$ in the following three steps; see also Fig.~\ref{fig:prefix}.

  First, we follow similar procedures as those in Section~\ref{sec:sort} when computing the shortest simple path, including removing the self-loop of $v_0$ and its outgoing edges from $\auto{relax}$ if the initial robot locations do not satisfy them and further removing all other initial and accepting vertices.  Note that when $v_0 = \vertex{accept}$ in $\auto{relax}$, i.e., the initial vertex is also the accepting vertex, we remove the self-loop of $v_0$ (acting as the initial vertex) when the initial robot locations do not satisfy its label. This will not affect the self-loop of $\vertex{accept}$ (acting as the accepting vertex) since  we view $v_0$ and $\vertex{accept}$ differently by condition~\hyperref[cond:a]{\it (a)} in Definition~\ref{defn:run}. Fig.~\ref{fig:prefix_self_loop}  and~\ref{fig:prefix_no_self_loop} show  the NBA  $\auto{subtask}$  when $\gamma_{\phi}(v_0)$ is satisfied and is not satisfied  by robot initial locations, respectively.


  Next, we remove all outgoing edges from $\vertex{accept}$ if $\vertex{accept} \not=v_0$, because we focus on the prefix part. Finally, let $\ccalV_{\text{s}}$ denote the set that contains all remaining vertices in $ \auto{relax}$ that belong to a path  connecting $v_0$ and $\vertex{accept}$. Then, we construct a sub-NBA $\auto{subtask}=(\ccalV_{\text{s}}, \ccalE_\text{s})$ from $\auto{relax}$  including all edges between vertices in $\ccalV_{\text{s}}$.
%% Based on the vertex label  $\gamma(\vertex{accept})$, we operate on $\auto{subtask}$ in two manners.

\begin{figure}
  \centering
  \subfigure[$\gamma_{\phi}(v_0)\neq \bot$ satisfied by initial robot locations and $\gamma_{\phi}(\vertex{accept}) = \bot$]{
    \includegraphics[width=0.33\linewidth]{prefix_self_loop.pdf}\label{fig:prefix_self_loop}}
  \hspace{1em}
  \subfigure[$\gamma_{\phi}(v_0)$ violated by initial robot locations and $\gamma_{\phi}(\vertex{accept})\neq \bot$]{
    \includegraphics[width=0.35\linewidth]{prefix_no_self_loop.pdf}\label{fig:prefix_no_self_loop}}
  \caption{{$\auto{subtask}$ for the prefix part.}}\label{fig:prefix}
\end{figure}

%% When the accepting vertex $\vertex{accept}$ has a self-loop, we solve the prefix and suffix part at the same time, since if robot configurations satisfy the vertex label $\gamma(\vertex{accept})$ and remain idle, the progression will stay at $\vertex{accept}$ forever.
%% In particular, we add a vertex $v'_{\text{accept}}$ with label $\top$ and an edge $(\vertex{accept}, v'_{\text{accept}})$ with label $\top$ to $\auto{subtask}$, so that the edge $(\vertex{accept}, v'_{\text{accept}})$ will be treated as a subtask in Section~\ref{sec:app} and its vertex label $\gamma(\vertex{accept})$ will be enabled when designing high-level and low-level plans in Section~\ref{sec:solution2mrta}; see also Fig.~\ref{fig:prefix_self_loop}.  Note that when $v_0 = \vertex{accept}$ in $\auto{relax}$, that is, when the initial vertex is also the accepting vertex, we remove the self-loop of $v_0$ (acting as the initial vertex) when the initial robot locations do not satisfy its label, but this will not affect the self-loop of $\vertex{accept}$ (acting as the accepting vertex) since  we view $v_0$ and $\vertex{accept}$ differently. Furthermore, we only connect $v'_{\text{accept}}$ to $\vertex{accept}$ that acts as the accepting vertex; see Fig.~\ref{fig:prefix_no_self_loop}.
%% \domanda{\it (ii) Absence of \upshape$\gamma(\vertex{accept})$} This case corresponds to case~\hyperref[sec:absence]{\it (ii)}. If $\gamma(\vertex{accept})$ does not exist, we connect $\vertex{accept}$ to $v_{\text{next}}$ that immediately follow $\vertex{accept}$ in $\auto{relax}$, and build a sub-NBA $\auto{relax}$ for each selection of $v_{\text{next}}$. We sort the set of vertices $v_{\text{next}}$ in an ascending order according to the length of the propositional formula $\gamma(\vertex{accept}, v_{\text{next}})$. The length of formula $\top$ is 0 by default. Intuitively, the shorter the formula is, the easier it can be satisfied. As discussded in~case~\hyperref[sec:absence]{\it (ii)}, the vertex label of $v_{\text{next}}$ should be satisfied at last (it has a vertex label since we remove all vertices without lables except initial and accepting vertices in step~\hyperref[prune:3]{{\it 6)}} in Section~\ref{sec:prune}). Similar to~\hyperref[i:presence]{{\it i)}}, we add a new vertex $v'_{\text{next}}$ with label $\top$ and a new edge $(v_{\text{next}}, v'_{\text{next}})$ with label $\top$  to $\auto{subtask}$; see also the left figure in Fig.~\ref{fig:absence}.
     \begin{figure}
       \centering
       \subfigure[$\auto{subtask}$ for task~{\it (i)}]{
         \includegraphics[width=0.45\linewidth]{nba_i_subtask.pdf}\label{fig:nba_i_subtask}}
       \subfigure[$\auto{subtask}$ for task~{\it (ii)}]{
         \includegraphics[width=0.3\linewidth]{nba_ii_subtask.pdf}\label{fig:nba_ii_subtask}}
       \caption{Sub-NBA $\auto{subtask}$ for the prefix part of tasks~\hyperref[task:i]{\it (i)} and~\hyperref[task:i]{\it (ii)} in Example~\ref{exmp:1}, obtained from the NBA $\auto{relax}$ in Fig.~\ref{fig:relax}.}
       \label{fig:auto_subtask}
     \end{figure}

     \begin{cexmp}
       The sub-NBA $\auto{subtask}$ for the prefix part of tasks~\hyperref[task:i]{\it (i)} and~\hyperref[task:i]{\it (ii)} are shown in~Fig.~\ref{fig:auto_subtask}. For task~\hyperref[task:i]{\it (i)}, given the pair $\vertex{init}$ and $v_6$ in the relaxed NBA $\auto{relax}$ in Fig.~\ref{fig:nba_i_relax}, the total length is $3+0=3$ (edges $(\vertex{init}, v_3), (\vertex{init}, v_4), (\vertex{init}, v_5)$ were removed since $\vertex{init}$ does not have a self-loop and initial robot locations do not satisfy their labels). The NBA $\auto{subtask}$, shown in  Fig.~\ref{fig:nba_i_subtask} is obtained by removing edges $(\vertex{init}, v_3), (\vertex{init}, v_4), (\vertex{init}, v_5), (v_5, v_3),  (v_5, v_6)$ and vertex $v_5$ from $\auto{relax}$. For task~\hyperref[task:i]{\it (ii)}, given the pair $\vertex{init}$ and $\vertex{init}$,  there is no cycle leading back to $\vertex{init}$, so the total length is infinite and there is no corresponding sub-NBA $\auto{relax}$. The total length for the pair $\vertex{init}$ and $v_3$ is $2+2=4$. The NBA $\auto{subtask}$ is shown in  Fig.~\ref{fig:nba_ii_subtask}, where edges $(\vertex{init}, v_1)$ and $(v_1, v_2)$ are removed since $\vertex{init}$ does not have a self-loop and initial robot locations do not satisfy their labels.
     \end{cexmp}

Observe that the sub-NBA $\auto{subtask}$ in Fig.~\ref{fig:nba_i_subtask} still constitutes a large portion of  $\auto{relax}$ in Fig.~\ref{fig:nba_i_relax}, which is typical due to the fact that the ratio of the number of edges to the number of initial and accepting vertices is not small and most vertices have self-loops. Therefore, in what follows, we further prune the NBA $\auto{subtask}$  by exploiting its structure.

\begin{figure}
  \centering
  \subfigure[ID property]{
    \includegraphics[width=0.5\linewidth]{id.pdf}\label{fig:id}}
  \hspace{1em}
  \subfigure[ST property]{
    \includegraphics[width=0.3\linewidth]{st.pdf}\label{fig:st}}
  \caption{Independent diamond and sequential triangle properties.}\label{fig:property}
\end{figure}
  \subsubsection{Pruning the sub-NBA \upshape $\auto{subtask}$:} \label{sub-NBA:2}
Recall that in task~\hyperref[task:i]{\it (i)}  visits to  certain regions can be executed in parallel. To capture this, We define the independent diamond (ID) property adapted from~\cite{stefanescu2006automatic}  and sequential triangle (ST) property over vertices; see also Fig.~\ref{fig:property}.
\begin{defn}[(Independent diamond property)]\label{defn:id}
   Given four different vertices $v_1, v_2, v_3, v_4$ in the NBA $\auto{subtask}$, we say that these four vertices have the ID property if (a) $\gamma(v_1) = \gamma(v_2) = \gamma(v_4)$, (b) $v_1 \xrightarrow{\gamma}_B v_2 \xrightarrow{\gamma'}_B v_3$, (c) $v_1 \xrightarrow{\gamma'}_B v_4 \xrightarrow{\gamma}_B v_3$,  (d) $v_1 \xrightarrow{\gamma \wedge \gamma'}_B v_3$, and (e) $\gamma_{\phi}(v_3) = \top$ if $v_3 = \vertex{accept}$.
\end{defn}
Intuitively, if vertices have the ID property (see Fig.~\ref{fig:id}), we have equivalent subtasks $(v_1, v_2) \sim (v_4, v_3)$ and $(v_1, v_4) \sim (v_2, v_3)$ in $\auto{subtask}$ according to conditions {\it (a)-(c)}, and the occurrence order is arbitrary, precedence or simultaneity, according to conditions {\it (b)-(d)}.  We refer to $(v_1, v_3)$ as the {\it composite} subtask and $(v_1, v_2)$, $(v_1, v_4)$ as the {\it elementary} subtasks.  Although both can lead to vertex $v_3$, elementary subtasks are preferred since subtasks $(v_1, v_2)$ and $(v_1, v_4)$ can be executed independently, making it easier to satisfy and more flexible to implement, compared to the composite subtask requiring that two subtasks are accomplished at the same time. It is worth noting that the $\top$-check in condition {\it (e)} are conducted in $\autop$ for the sake of condition~\hyperref[cond:f]{\it (f)} in Definition~\ref{defn:run}, which guarantees  that the non-emptiness of the set of restricted accepting runs will not be affected if the edge $(v_1, v_3)$ is removed,  as shown in Lemma~\ref{prop:sub-NBA} in Appendix~\ref{app:correctness}. In short words, if $\gamma_{\phi}(v_3) \ne \top$ when $v_3 = \vertex{accept}$, and further if a restricted accepting run traverses edges $(v_1, \vertex{accept})$ and $(\vertex{accept}, \vertex{next})$ where $\vertex{accept}\neq \vertex{next}$, condition~\hyperref[cond:f]{\it (f)} in Definition~\ref{defn:run} states  that $\gamma_{\phi}(v_1, \vertex{accept}) \simplies \gamma_{\phi}(\vertex{accept}, \vertex{next})$, but $\gamma_{\phi}(v_2, \vertex{accept})$ and $\gamma_{\phi}(v_4, \vertex{accept})$ may not  imply $\gamma_{\phi}(\vertex{accept}, \vertex{next})$ since they are subformulas of $\gamma_{\phi}(v_1, \vertex{accept})$. Therefore, removing the composite edge $(v_1, \vertex{accept})$ can be at the risk of emptying the  set of restricted accepting runs.


\begin{defn}[(Sequential triangle property)]\label{defn:st}
  Given three different vertices $v_1, v_2, v_3$ in the NBA $\auto{subtask}$, we say that these three vertices $v_1, v_2, v_3$ have the ST property if %% {\it (i)} $\gamma(v_1) = \gamma(v_2)$,
(a) $v_1 \xrightarrow{\gamma}_B v_2 \xrightarrow{\gamma'}_B v_3$,  (b) $v_1 \xrightarrow{\gamma \wedge \gamma'}_B v_3$, and (c) $\gamma_{\phi}(v_3) = \top$ if $v_3 = \vertex{accept}$.
\end{defn}

If vertices have the ST  property (see Fig.~\ref{fig:st}), subtask $(v_1, v_2)$ should be satisfied no later than $(v_2, v_3)$, according to conditions {\it (a)} and {\it (b)}. Note that if vertices $v_1, v_2, v_3, v_4$ have the ID property, then $v_1, v_2, v_3$ and $v_1, v_4, v_3$ have the ST property. Based on these two properties, for any edge $(v_1, v_3)$ in $\auto{subtask}$, we remove it if there exists  vertex $v_2$ such that combined, they have  ST property. We denote by $\auto{subtask}^-$ the pruned $\auto{subtask}$. A composite subtask can be an elementary subtask of another composite subtask at a higher layer. Thus, removing composite subtasks  is vital for reducing the size of $\auto{subtask}$. Similar to the pruning of $\autop$ to get $\autop^-$, the feasibility of Problem~\ref{prob:1} is not compromised by pruning the NBA $\auto{subtask}$, as shown in Lemma~\ref{prop:sub-NBA}. %% \red{ This also justifies the method to sort a pair of initial and accept vertices. The shortest path usually results in longer labels that can be decomposed into multiple shorter labels, hence more subtasks but each one can be fulfilled easily.}
\begin{figure}[t]
    \centering
    \subfigure[$\auto{subtask}^-$ for task {\it (i)}]{
      \label{fig:sub-NBA}
      \includegraphics[width=0.29\linewidth]{nba_i_subtask_prune.pdf}}
    \hspace{1em}
    \subfigure[Subtasks and poset]
    {\label{fig:subtask}
      \includegraphics[width=0.62\linewidth]{subtask_i.pdf}}
        \caption{The NBA $\auto{subtask}^-$ and corresponding subtasks.} \label{fig:subtask_prune}
\end{figure}
\begin{cexmp} [(ID and ST properties and NBA $\auto{subtask}^-$)]
  In the NBA $\auto{subtask}$ for task~\hyperref[task:i]{\it (i)}, shown in Fig.~\ref{fig:nba_i_subtask}, instances of the ID and ST properties are the set of 4 vertices $v_1, v_2, v_3, v_4$ and the set of 3 vertices $v_2, v_3, v_6$ ($\gamma_\phi(v_6)=\top$ in Fig.~\ref{fig:nba_i}), respectively. Thus we delete $(v_1, v_3)$ and $(v_2, v_6)$. The obtained $\auto{subtask}^-$ is shown in Fig.~\ref{fig:sub-NBA}. The NBA $\auto{subtask}^-$ of task~\hyperref[task:ii]{\it (ii)} is the same as $\auto{subtask}$ since there are no composite subtasks.
\end{cexmp}

%% \begin{rem}
%%   The last conditions {\it (e)} in the definition of ID property and {\it (c)} in the definition of ST property are necessary for establishing the theoretical guarantee in Lemma~\ref{prop:sub-NBA}  on the non-emptiness of the set of restricted accepting runs after the pruning of composite subtasks. However, these conditions may not be necessary when implementing the pruning process%% , as discussed in~Appendix~\ref{sec:extension}
%%   .  We found that in the simulations in Section~\ref{sec:sim}, with condition {\it (c)} being omitted, only checking conditions {\it (a)} and {\it (b)} of Definition~\ref{defn:st} in $\auto{subtask}$  does not compromise  the performance.

%% \end{rem}


%% \begin{figure}[t]
%%   \centering
%%   \includegraphics[width=1\linewidth]{p_nba0.pdf}
%%    \caption{Sub-NBA $\auto{subtask}$}
%%   \label{fig:nba_b}
%% \end{figure}

\subsection{Inferring temporal order between subtasks in  $\auto{subtask}^-$}\label{sec:poset}
In this section,  we infer the temporal relation between subtasks in the pruned NBA $\auto{subtask}^- = (\ccalV_\text{s}, \ccalE_\text{s})$; see also block \circled{2} in Fig.~\ref{fig:overview}.  To capture the temporal relation among subtasks in a high-level plan,  we rely on the use of partially ordered sets described in Section~\ref{sec:partial}.


Specifically, given the NBA $\auto{subtask}^-$, let $\Theta$ denote the set that collects all simple paths connecting $v_0$ and $\vertex{accept}$ in $\auto{subtask}^-$. Simple paths suffice since condition~\hyperref[cond:a]{\it (a)} in Definition~\ref{defn:run} excludes cycles. %% In the case that $\vertex{accept}$ has a self-loop, we collect all paths leading to $\vertex{accept}'$.
For a simple path $\theta \in\Theta$, let $\ccalT(\theta)$ denote the set of subtasks in $\theta$. We say two simple paths $\theta_1$ and $\theta_2$ have the same set of subtasks if $\ccalT(\theta_1) =\ccalT(\theta_2)$. Then we partition $\Theta$ into subsets of  simple paths that contain the same set of subtasks, that is, $\Theta = \cup_e \Theta_e$, $\Theta_e \cap \Theta_{e'} = \emptyset$ if $e\not=e'$. The motivation for this partition is that the set of linear extensions generated by a poset has the same set of elements. {In what follows, we map subtasks to integers to facilitate the discovery of the  poset.}

Given a subset $\Theta_e$ of simple paths in the partition, with a slight abuse of notation, let $\ccalT(\Theta_e)$ denote the set of corresponding  subtasks. Let the function $f_e:\ccalT(\Theta_e)\to [|\ccalT(\Theta_e)|]$ map each subtask to a positive integer. Using $f_e$, we can map every path in $\Theta_e$ to a sequence of integers. Let $\Gamma_e$ collect all sequences of integers for all paths in $\Theta_e$, so $|\Theta_e| =  |\Gamma_e|$. Moreover, a sequence in $\Gamma_e$  is a permutation of the same set of integers and we denote by $X_e = [|\Theta_e|]$ the base set. For every sequence $S_e \in \Gamma_e$, let $S_e[i]$ denote its $i$-th entry. We define a linear order $L_{X_e} = (X_e, <_L)$ such that  $S_e[i]  <_L  S_e[j] $ if $i  <  j$. In other words, the subtask $S_e[i]$ should be completed prior to  $S_e[j]$. Then, let $\Xi_e$ collect all linear orders over $X_e$ that can be defined from sequences in $\Gamma_e$. A poset $P_e  = (X_e, <_{P_e})$  containing the maximum number of linear orders in $\Xi_e$ can be found using the algorithm for the partial cover problem in~\cite{heath2013poset}, where the order represents the precedence relation. Note that $\Xi_e$ may not be identical to $\ccalL(P_e)$, the set of all linear extensions of $P_e$. Thus, after obtaining the poset $P_e$, each of  the remaining linear orders in $\Xi_e$ that are not covered by $P_e$ is treated as a separate totally ordered set, which is a poset as well. In this way, we do not discard any poset.

{Finally, given a partition $\{\Theta_e\}$ and a corresponding set of posets $\{P_e\}$, we sort $\{P_e\}$ lexicographically first in descending order in terms of the width of posets and then in ascending order in terms of the height. Recall that the width of a poset is the cardinality of its maximal antichain, and the height is the cardinality of its maximal chain (see Section~\ref{sec:partial}). Intuitively, the wider a poset is, the larger the number of temporally independent subtasks it contains. The shorter of a poset is, the smaller the number of elementary subtasks it has.} Every linear extension of subtasks in a poset produces a simple path  connecting $v_0$ and $\vertex{accept}$ in $\auto{subtask}^-$. In the next section, our goal is to find a high-level plan that produces a linear extension of a given poset and optimizes the plan's cost simultaneously.

\begin{rem}
  If the size of sub-NBA $\auto{subtask}^-$ is still large, leading to large number of simple paths, we can select a fixed number of simple paths at most, similar to finding a fixed number of runs in work~\cite{kloetzer2020path}. This will not severely compromise the diversity of the selected simple paths since a lot of simple paths are combinations of the same set of elementary subtasks.
\end{rem}
\begin{cexmp}[(Temporal constraints)]
  For task~\hyperref[task:i]{\it (i)}, there are 2 simple paths in $\auto{subtask}^-$ leading to $v_6$ and all have the same set of 4 edges.  $\Theta_1 = \{\vertex{init},v_1, v_4,v_3,v_6$; $\vertex{init}, v_1, v_2,v_3, v_6$\}; see~Fig~\ref{fig:sub-NBA}.  The design of equivalent subtasks, mapping function, integer sequence and the poset are shown in Fig.~\ref{fig:subtask}. The temporal relation implies that subtasks $(v_1, v_4)$ and $(v_1, v_2)$ are independent, which agrees with our observation. For task~\hyperref[task:ii]{\it (ii)}, the NBA $\auto{subtask}^-$ in Fig.~\ref{fig:nba_ii_subtask} only has one path of two subtasks that generates a totally ordered set where  every two subtasks are comparable.
\end{cexmp}

%% Given $e = (v_1, v_2) \in\ccalE_\text{s}$, let $\ccalE_e$ collect all edges in $\ccalE_\text{s}$ that share the same first vertex label and edge label with $e$, i.e., $\ccalE_e = \{e' = (v'_1, v'_2) \in \ccalE_p \, |\, \gamma(v_1) = \gamma(v'_1), \gamma(v_1, v_2) = \gamma(v'_1, v'_2)\}$. Next, we partition $\ccalE_e$ into two disjoint subsets $\ccalE_e^1$ and $\ccalE_e^2$ such that any $e_1, e_2 \in \ccalE_e^1$ do not belong to a common path in $\Pi$ and $\ccalE_e^2$ is the complement of $\ccalE_e^1$, where $\Pi$ collects all simple paths that connect $v_0$ and $\vertex{accept}$ in $\auto{subtask}$. Tasks in $\ccalE_e^1$ are temporally independent and $\ccalE_e^1$ contains all possible such tasks/e{e'ges.

%% Given $\ccalE_e$ and its partition into $\ccalE_e^1$ and $\ccalE_e^2$, let the function $f_e: \ccalE_e \to \{N_e, \ldots,N_e+|\ccalE_e^2|\}$ map all edges in $\ccalE_e^1$ to the positive integer $N_e$, i.e., $f(e_1) = f(e_2)=N_e, \forall e_1, e_2 \in \ccalE_e^1$, and every edge in $\ccalE_e^2$ to a distinct integer in $\{N_e+1, \ldots, N_e+|\ccalE_e^2|\}$ with one-to-one correspondence, where  $[N_e-1]$ are the integers that have been already used for other sets in $\{\ccalE_e\}$. Since ${\ccalE_e}$ forms a partition of $\ccalE_\text{s}$, we can combine all functions $f_e$ in the function $f: \ccalE_p \to \mathbb{N}^+$ that maps an edge in $\ccalE_p$ to a positive integer. %% In Example~\ref{exp:1}, the function is defined as $f(\vertex{init}, v_{1}) = 1, f(v_{1}, v_{2}) = f(v_5, v_4) = 2, f(v_1, v_5) = f(v_{2}, v_{4}) = f(v_3, v_7)=3, f(v_{2}, v_{3}) = f(v_4, v_7) =4$.


%% \begin{cexmp}
%%   Consider the running example. The equivalence sets are $\ccalE_{(\vertex{init}, v_{1})} = \ccalE^1_{(\vertex{init}, v_{1})} = \{(\vertex{init}, v_{1})\}$, $\ccalE_{(v_{1}, v_{2})} = \ccalE^1_{(v_{1}, v_{2})} = \{(v_{1}, v_{2}), (v_5, v_4)\}$, $\ccalE_{(v_{1}, v_{5})} = \ccalE_{(v_{1}, v_{5})}^1 =  \{(v_1, v_5), (v_{2}, v_{4}), (v_3, v_7)\}$, $\ccalE_{(v_{2}, v_{3})} = \ccalE^1_{(v_{2}, v_{3})} = \{(v_{2}, v_{3}), (v_4, v_7)\}$. The function is defined as $f(\vertex{init}, v_{1}) = 1, f(v_{1}, v_{2}) = f(v_5, v_4) = 2, f(v_1, v_5) = f(v_{2}, v_{4}) = f(v_3, v_7)=3, f(v_{2}, v_{3}) = f(v_4, v_7) =4$. The set of sequences $\Gamma = \Gamma_\sim^1 = \{(1,2,4,3), (1,2,3,4), (1,3,2,4)\}$ and the order relation of the underlying poset $P_1 = P = \{1<_{P}2, 1<_{P}4, 1<_{P}3, 2<_{P}4\}$. In words, eventually 1 robot of type 1 visits $\ell_1$ before 2 robots of type 1 visits $\ell_3$, and the time that 1 robot of type 2 visits $\ell_2$ can be arbitrary.
%% \end{cexmp}
\section{Task Allocation and High-Level Plan Generation  on  the Relaxed Automaton}\label{sec:solution}
In this section,  by solving a MILP program inspired by vehicle routing problems, we find a high-level plan that indicates a sequence of waypoints that each robot needs to visit; see also blocks \circled{3}\,--\,\circled{5} in Fig.~\ref{fig:overview}. We iterate over the sorted set of posets $\{P_e\}$. Given a poset $P\in \{P_\text{pre}\}$ (where $\{P_{\text{pre}}\}$ is the set of posets inferred for the prefix part), recall that $X_{P}$ is its base set. Each element in $X_P$ is an integer, which is also an edge in the NBA $\auto{subtask}^-$ and a subtask.  The high-level plan produces a linear extension of the poset $P$ by sequentially satisfying vertex and edge labels of all elements in $X_P$. Therefore,  this plan will generate a simple path in $\auto{subtask}^-$ that connects $v_0$ and $\vertex{accept}$. The feasibility of the formulated MILP and properties of the solution are analyzed in Lemmas~\ref{prop:feasibility} and~\ref{prop:run}.


\subsection{Construction of the routing graph}\label{sec:graph}
To leverage the MILP formulation, we construct a routing graph $\ccalG = (\ccalV_{\ccalG},\ccalE_{\ccalG})$ where each vertex represents a specific region that is associated with a specific literal in a specific label of a subtask in $X_P$. Each vertex/region in $\ccalV_\ccalG$ is visited by at most one robot throughout the whole process. Simultaneous visits of multiple vertices in $\ccalV_\ccalG$ by a fleet of robots  satisfy a literal, a clause, or a label. The time of visits reflects the precedence relation among subtasks. Below, we first construct  the vertex set and then the edge set of $\ccalG$. Both constructions follow four layers of nested iterations from coarse to fine, starting with the edges, then the labels, then the clauses, and finally, the literals. The outline of the algorithm is shown in Alg.~\ref{alg:milpgraph}.  %% Fig.~\ref{fig:routing} demonstrates such a routing graph.
An illustrative graph for task~\hyperref[task:i]{\it (i)}  is  shown in Fig.~\ref{fig:milp}.
\begin{algorithm}[!t]
      \caption{Construct the routing graph}
      \LinesNumbered
      \label{alg:milpgraph}
      \KwIn {Poset $P$}
      \Comment*[r]{Create the vertex set}
      Create the vertex set $\ccalV_{\text{init}}$ for initial locations \label{milp:init}\;
      \Comment*[r]{vertices for  labels}
      \For{$e = (v_1, v_2) \in X_P$ \label{milp:for}}{
        \If{$\gamma(v_1, v_2) \not= \top$ \label{milp:nottrue}}{
          \For{$\ccalC_p^\gamma \in \clause{\gamma} $\label{milp:clause}}{
            \For{$\ap{i}{j}{k,\chi} \in \mathsf{lits}^+(\ccalC_p^{\gamma})$\label{milp:ap}}{
              Create $i$ vertices \label{milp:i}\;
            }
          }
        }
          \If{$\gamma(v_1)\not= \top, \bot$ \label{milp:nottrue2}}{
            Create vertices by following lines~\ref{milp:clause}-\ref{milp:i} \label{milp:repeat}\;
          }

      }
      \Comment*[r]{Create the edge set}
      \For{$e = (v_1, v_2) \in X_P$ \label{milp:for2}}{
        \If{$\gamma(v_1, v_2) \not= \top$ \label{milp:e}}{
            \For{$\ccalC_p^\gamma \in \clause{\gamma} $\label{milp:clause2}}{
              \For{$\ap{i}{j}{k,\chi} \in \mathsf{lits}^+(\ccalC_p^{\gamma})$\label{milp:lits}}{
                $(i)$ Vertices of  initial robot locations \label{milp:i2}\;
                $(ii)$ Vertices of prior subtasks \label{milp:ii}\;
                $(iii)$ Vertices associated with  $\gamma(v_1)$ \label{milp:iii}\;
              }
            }
        }
        \If{$\gamma(v_1) \not= \top,\bot$ \label{milp:nottrue3}}{
          %%   Create edges by following lines~\ref{milp:clause2}-\ref{milp:ii} \label{milp:repeat2}\;

          \If{$S_2^e= \emptyset$}{
            Create edges by following lines~\ref{milp:clause2}-\ref{milp:i2} \label{milp:repeati}\;
          }
          \ElseIf{\upshape $S_2^e\ne \emptyset$}{
            Create edges from vertices associated with subtasks in $S_2^e$  \label{milp:repeatii}\;
            \If{$X_{\prec_P}^e = \emptyset$ {\bf and} $X_{\|_P}^e \neq \emptyset$ }{
              Create edges from vertices associated with initial robot locations \label{milp:repeatiii}\;}
         }
        }
      }
\end{algorithm}


\subsubsection{Construction of the vertex set:}\label{sec:vertex} The vertex set $\ccalV_\ccalG$ consists of three parts: the first part is related to initial robot locations, the other two parts are associated with edge labels and vertex labels in the sub-NBA $\auto{subtask}^-$, respectively.
\refstepcounter{phase}
\subphase{Vertices associated with initial locations}{First we create $n$ vertices, collected in the set $\ccalV_{\text{init}}\subseteq \ccalV_{\ccalG}$ such that each vertex points to the initial location $s^0_{r,j}$ of robot $[r,j]\in\ccalK_j, \forall j\in [m]$ [line~\ref{milp:init}, Alg.~\ref{alg:milpgraph}] (see blue dots in Fig.~\ref{fig:milp}).} \label{vertex:initial}

Next, we iterate over subtasks in $X_{P}$. Given a subtask $e = (v_1, v_2) \in X_{P}$, we construct vertices for the  edge label $\gamma(v_1, v_2)$ and the starting vertex label $\gamma(v_1)$, if they are neither $\top$ nor $\bot$.

\subphase{Vertices associated with the edge label}{If $\gamma(v_1, v_2) \not= \top$, we operate on $\gamma(v_1, v_2) =  \bigvee_{p\in \ccalP} \bigwedge_{q \in \ccalQ_{p}} \ap{i}{j}{k,\chi}$ starting by iterating over clauses $\ccalC_p^{\gamma} \in \clause{\gamma}$ in the label, and then over literals in each clause $\ccalC_p^\gamma$ [lines~\ref{milp:for}-\ref{milp:i}, Alg.~\ref{alg:milpgraph}]. The literal $\ap{i}{j}{k,\chi}\in $ $\mathsf{lits}^+(\ccalC_p^{\gamma})$ implies that at least $\ag{i}{j}$, i.e., $i$ robots of type $j$,  should visit the target region $\ell_k$ simultaneously. Hence, we create $i$ vertices in $\ccalV_\ccalG$  all pointing to region $\ell_k$. If $\ag{i}{j}$ visit these $i$ vertices simultaneously, one robot per  vertex, then $\ap{i}{j}{k,\chi}$ is true. Note that if $\chi\not=0$, the robots visiting these $i$ vertices should be the same as those visiting another $i$ vertices  associated with another literal with the same nonzero connector. This will be ensured in the MILP formulation in~Section \ref{sec:milp}; see the red, yellow, and green dots in Fig.~\ref{fig:milp}.}\label{vertex:edge}

\subphase{Vertices associated with the starting vertex label}{After the iteration over the edge label $\gamma(v_1, v_2)$ of subtask $e$ is complete, vertices in $\ccalV_\ccalG$ associated with the starting  vertex label $\gamma(v_1)$ can be constructed in the same manner if $\gamma(v_1)$ is neither $\top$ nor $\bot$ [lines~\ref{milp:nottrue2}-\ref{milp:repeat}, Alg.~\ref{alg:milpgraph}].  We do not create vertices for the end vertex label since the meaning of subtask $e$ is irrelevant to the end vertex $v_2$. Additionally, the vertices associated with $v_2$ can be created when it comes to other subtasks for which $v_2$ is their starting vertex.}\label{vertex:vertex}


Finally, repeating this process for all subtasks in $X_{P}$ completes the construction of the vertex set $\ccalV_\ccalG$. Note that each vertex in $\ccalV_\ccalG\setminus \ccalV_{\text{init}}$ is associated with a literal of certain subtask in $X_P$, and each literal of certain subtask in $X_P$ is associated with (multiple) vertices in $\ccalV_\ccalG\setminus \ccalV_{\text{init}}$, which specifies the region and the robot type associated with these vertices.
To capture this correspondence, let $\ccalM^\ccalV_{e} : \ccalV_{\ccalG}\setminus \ccalV_{\text{init}} \to  X_{P} $ and $\ccalM^\ccalV_{\mathsf{lits}}  : \ccalV_\ccalG\setminus \ccalV_\text{init}  \to  \prod_{\mathsf{lits}} $  map a vertex in $\ccalV_\ccalG \setminus \ccalV_{\text{init}}$ to its associated subtask and literal, respectively, where $\prod_{\mathsf{lits}}$ is the cartesian product $ X_{P} \times\{0, 1\} \times \ccalP  \times \ccalQ_p$, and 0, 1 represent the label type, 0 for vertex label and 1 for edge label. Furthermore, let $\ccalM^\mathsf{lits}_{\ccalV}:   \prod_{\mathsf{lits}}  \to  2^{\ccalV_\ccalG}$ and $\ccalM^\mathsf{cls}_{\ccalV} :  \prod_{\mathsf{cls}} \to  2^{\ccalV_\ccalG}$ map a literal and clause to the associated vertices in $\ccalG$, respectively, where $\prod_{\mathsf{cls}}$ is the cartesian products $X_{P}\times \{0, 1\} \times \ccalP$. We also define $\ccalM^{\ccalV}_\ccalL :  \ccalV_\ccalG  \to  \ccalL$ and $ \ccalM^{\ccalV}_\ccalK :  {\ccalV_\ccalG}  \to  \{\ccalK_j\}$ that map a vertex in $\ccalV_\ccalG$ to its associated  region and robot type. Finally, if $\chi\not=0$, we define  $\ccalM_{\gamma}^\chi: \mathbb{N}^+ \to 2^{X_{P}\times \{0,1\}}$ to map $\chi$ to all labels in $X_P$ that have literals with the same connector $\chi$.

\begin{cexmp}[(Mappings for task {\it (i)})]
    The mappings in Fig.~\ref{fig:milp} regarding the vertex $\ell_2^{1}$ are:
    $\mathcal{M}_e^{\mathcal{V}}(\ell_{2}^{1})  = (v_1,v_2) = 3$ and $\mathcal{M}_{\mathsf{lits}}^{\mathcal{V}}(\ell_{2}^{1})  = ((v_1,v_2), 1, 1, 1)$ since the vertex $\ell_2^{1}$ corresponds to the first literal $\ap{2}{1}{2,1}$ of the first clause of the edge label of subtask $(v_1, v_2)$ in $X_P$; see also Fig.~\ref{fig:subtask_prune}.  $\mathcal{M}_\mathcal{L}^{\mathcal{V}}(\ell_{2}^{1})  = \ell_2$  and $\mathcal{M}_\mathcal{K}^{\mathcal{V}}(\ell_{2}^{1})  = \mathcal{K}_1$ since the literal $\ap{2}{1}{2,1}$ requires two robots of type 1 to visit region $\ell_2$.

    Furthermore,  the literal/clause-to-vertex mappings are:
    $\mathcal{M}^{\mathsf{lits}}_{\mathcal{V}}(((v_1,v_2), 1, 1, 1)) = \mathcal{M}^{\mathsf{cls}}_{\mathcal{V}}(((v_1,v_2), 1, 1))  = \{\ell_2^{1}, \ell_2^{2}\}$; $\mathcal{M}^{\mathsf{lits}}_{\mathcal{V}}(((v_1,v_4), 1, 1, 1)) = \mathcal{M}^{\mathsf{cls}}_{\mathcal{V}}(((v_1,v_4), 1, 1))  = \{\ell_4^{1}\}$ since the literal $\ap{1}{2}{4}$, the first literal of the first clause of the edge label of subtask $(v_1, v_4)$, requires one robot to visit region $\ell_4$. Finally, the connector-to-label mapping is: $\ccalM^{\chi}_{\gamma} (1)  = \{((v_1, v_2), 1), ((v_3, v_6), 1)\}$ since the connector 1 appears in the edge label of subtask $(v_1 ,v_2)$ and the edge label of subtask $(v_3, v_6)$.
   \end{cexmp}
\begin{figure}[t]
  \centering
  \includegraphics[width=0.7\linewidth]{milp.pdf}
  \caption{Routing graph $\ccalG$ for task~\hyperref[task:i]{\it (i)}. $s^0_{1,1}$, $s^0_{2,1}$ and $s^0_{3,1}$ are initial locations of three robots of type 1 and $s^0_{1,2}$ and $s^0_{2,2}$ are initial locations of two robots of type 2 (see case~\ref{vertex:initial}). Red dots $\ell_{2}^{1}$ and $\ell_{2}^{2}$ correspond to the edge label $\ap{2}{1}{2,1}$ of element 3, i.e., edge $(v_1, v_2)$ in $X_P$; see Fig.~\ref{fig:subtask}. Yellow  dots $\ell_{3}^{1}, \ell_{3}^{2}$ correspond to the edge label $\ap{2}{1}{3,1}$ of element 4, and green dot $\ell_{4}^{1}$ corresponds to the edge label $\ap{1}{2}{4}$ of element 2 (see case~\ref{vertex:edge}). No dots correspond to vertex labels since all vertex labels are either $\top$ or $\bot$.  The edges from $\ell_2^{1}$ to $\ell_3^{1}$ and from $\ell_2^{2}$  to $\ell_3^{2}$ are due to $3 <_{P} 4$. }
    \label{fig:milp}
\end{figure}

\subsubsection{Construction of  the edge set:}\label{sec:edge_set} After obtaining the vertex set $\ccalV_\ccalG$, we follow a similar procedure   to construct the edge set $\ccalE_\ccalG$ by iterating over $X_P$, which captures the precedence order in the poset ${P}$.  For any subtask $e = (v_1, v_2) \in X_{P}$, if $\gamma(v_1, v_2) \not=\top$, we first operate on the edge label $\gamma(v_1, v_2) =  \bigvee_{p\in \ccalP} \bigwedge_{q \in \ccalQ_{p}} \ap{i}{j}{k,\chi}$ starting by iterating over clauses $\ccalC_p^{\gamma} \in \clause{\gamma}$, and then over literals in each clause $\ccalC_p^\gamma$ [lines~\ref{milp:for2}-\ref{milp:iii}, Alg.~\ref{alg:milpgraph}]. Considering the literal $\ap{i}{j}{k,\chi} \in \mathsf{lits}^+(\ccalC_p^{\gamma})$, its associated $i$ vertices point to  region $\ell_k$ that should be visited by $i$ robots. In what follows, we identify three types of {\it leaving vertices} in $\ccalV_\ccalG$ from where $i$ robots depart for these $i$ vertices to satisfy this specific literal $\ap{i}{j}{k,\chi}$.
\refstepcounter{phase}
\subphase{Leaving vertices associated with initial robot locations}{The initial vertices in $\ccalV_{\text{init}}$  associated with  robots of type $j$ are leaving vertices. We add an edge from each of  such initial vertices to each vertex associated with this  literal $\ap{i}{j}{k,\chi}$ (see blue edges  in~Fig.~\ref{fig:milp}), with one  weight, denoted by $T^*$, equal to the shortest traveling time from the initial location to region $\ell_k$ and another weight, denoted by $d$, equal to the smallest traveling cost, e.g., traveling distance or energy consumption, between the initial location and $\ell_k$.}\label{sec:a}

\subphase{Leaving vertices associated with prior subtasks}{Let $X^e_{<_{P}}$, $X^e_{\prec_{P}}$ and $X^e_{\|_{P}}$ denote the sets that collect subtasks in $X_{P}$ that are  smaller than, covered by, and incomparable to subtask $e$, respectively (see Section~\ref{sec:partial}). In words, $X^e_{<_{P}}$ contains subtasks in $X_P$ that should be completed prior to $e$, $X^e_{\prec_{P}} \subseteq X^e_{<_{P}}$ contains subtasks in $X^e_{<_{P}}$ that can be completed right before $e$, and $X^e_{\|_{P}}$ contains subtasks independent from $e$. To find leaving vertices, we iterate over $S_1^e = X^e_{<_{P}} \cup X^e_{\|_{P}}$ that includes all subtasks that can be completed prior to $e$.}\label{sec:b}

Given a subtask $e' = (v'_1, v'_2) \in S_1^e$, if its edge label $\gamma'(v'_1, v'_2) \not=\top$, we iterate all literals in $\gamma'$ by iterating over clauses in $\gamma'$. Specially, given a clause $\ccalC^{\gamma'}_{p'} \in \clause{\gamma'}$, for any literal $\ap{i'}{j'}{k',\chi'} \in\mathsf{lits}^+(\ccalC^{\gamma'}_{p'})$, if $j'=j$, then those vertices in $\ccalV_\ccalG$ associated with this literal are leaving vertices. If further $i'=i$, we randomly create $i$ one-to-one edges starting from these $i$ vertices and ending at the $i$ vertices associated with $\ap{i}{j}{k,\chi}$ (see the orange edges in Fig.~\ref{fig:milp}). Because there are exactly $i$ robots of type $j$, it suffices to build $i$ one-to-one edges. Furthermore, if $\chi=\chi'\neq0$, then literals $\ap{i}{j}{k,\chi}$ and $\ap{i'}{j'}{k',\chi'}$ must have the same number of vertices. Building $i$ one-to-one edges can guarantee that  the same  $i$ robots of type $j$ satisfy these two literals. Otherwise, if $i'\neq i$, we add $i\times i'$ edges to $\ccalE_\ccalG$ by creating an edge from any vertex associated with $\ap{i'}{j'}{k',\chi'}$ to any vertex of $\ap{i}{j}{k,\chi}$. Finally, since each region may span multiple cells, the weights $T^*$ and $d$ of these edges are set as the shortest traveling time and smallest traveling cost from  $\ell_{k'}$ to $\ell_k$. After creating edges  associated with the edge label  $\gamma'(v'_1,v'_2)$ of $e'$, we identify  leaving vertices  among the vertices in $\ccalV_\ccalG$ associated with the starting vertex label $\gamma(v'_1)$ of $e'$ and build edges in the same manner. %% \red{This simpilication will be addressed in Section~\ref{sec:solution2mapp}}.


\subphase{Leaving vertices associated with $\gamma(v_1)$ of $e$}{When the iteration over $S_1^e$ is completed, we identify leaving vertices  among the vertices associated with the starting vertex label  $\gamma(v_1)$ of the current subtask $e$ by following the  procedure ~\ref{sec:b} for the prior subtasks. This is because $\gamma(v_1)$ becomes true before $\gamma(v_1, v_2)$.}\label{sec:c}


So far we have constructed three types of leaving vertices corresponding to the literal $\ap{i}{j}{k,\chi}$ in $\mathsf{lits}^+(\ccalC_p^{\gamma})$ of the edge label $\gamma(v_1, v_2)$ [lines~\ref{milp:i2}-\ref{milp:iii}, Alg.~\ref{alg:milpgraph}]. We continue  constructing leaving vertices for all other literals in~$\mathsf{lits}^+(\ccalC_p^{\gamma})$ [line~\ref{milp:lits},  Alg.~\ref{alg:milpgraph}] and other clauses in $\clause{\gamma}$ [line~\ref{milp:clause2},  Alg.~\ref{alg:milpgraph}].
After constructing all edges pointing to vertices associated with literals in the edge label $\gamma(v_1, v_2)$ of the current subtask $e$ [line~\ref{milp:e},  Alg.~\ref{alg:milpgraph}], in what follows  we construct  edges pointing to vertices associated with literals in the starting vertex label $\gamma(v_1)$, by identifying leaving vertices among vertices associated with initial robot locations and locations of prior subtasks, Specifically, let $S_2^e = X_{\prec_P}^e \cup X_{\|_P}^e$ be the set that collects all subtasks that can occur immediately prior to subtask $e$. The satisfaction of edge labels  of subtasks in $S_2^e$  can directly lead to the starting vertex $v_1$ of $e$.
\refstepcounter{phase}
\subphase{$S_2^e = \emptyset$}{The subtask $e$ should be the first one among all to be completed. Thus, $v_1$ is identical to the initial vertex $v_0$. In this case,  we only identify leaving vertices associated with initial robot locations, as in case~\ref{sec:a} [lines~\ref{milp:repeati},  Alg.~\ref{alg:milpgraph}].}\label{edge:vertex1}
\subphase{$S_2^e \neq \emptyset$}{We  identify leaving vertices associated with prior subtasks in $S_2^e$. Given a subtask $e' = (v_1', v_2') \in S^e_2$, we find all clauses $\ccalC_{p'}^{\gamma'} \in  \clause{\gamma'}$ in the edge label $\gamma'$ of $e'$ such that, for the considered clause $\ccalC_p^\gamma \in \clause{\gamma} $ in the starting vertex label of subtask $e$, its corresponding clause $(\ccalC_p^\gamma)_{\phi}$ in $\autop$ is the subformula of   their corresponding clauses $(\ccalC_{p'}^{\gamma'})_{\phi}$ in $\autop$. Next, for each literal $\ap{i}{j}{k,\chi} \in \mathsf{lits}^+(\ccalC_p^\gamma)$ we create $i$ one-to-one edges, starting from those $i$ vertices associated with the counterpart  of literal  $\ap{i}{j}{k,\chi}$ in the found clause  $\ccalC_{p'}^{\gamma'} \in \clause{\gamma'}$  and ending at the $i$ vertices associated with $\ap{i}{j}{k,\chi}$ [lines~\ref{milp:repeatii},  Alg.~\ref{alg:milpgraph}]. We create such one-to-one edges based on condition~\hyperref[cond:d]{\it (d)}  in Definition~\ref{defn:run} and condition~\hyperref[asmp:b]{\it (b)} in Assumption~\ref{asmp:same}. That is,  the satisfied clause in the edge label  implies the satisfied clause in the end vertex label, and the fleet of robots satisfying the clause in the vertex label belongs to the fleet of robots satisfying the clause in the incoming edge label. This is also the reason why we consider prior subtasks in $S_2^e$ rather than $S_1^e$ as in case~\ref{sec:b}.}\label{edge:vertex2}
\subphase{$X_{\prec_P}^e = \emptyset$ and $X_{\|_P}^e \neq \emptyset$}{In this case, the subtask $e$ can be the first one among all to be completed. If so,  its starting vertex label $\gamma(v_1)$ should be satisfied at the beginning. However, leaving vertices associated with other edge labels can not achieve this (see case~\ref{edge:vertex2}), because these edges are enabled after subtask $e$. Therefore, for the vertex label $\gamma(v_1)$, we additionally identify leaving vertices pointing to initial robot locations, as in case~\ref{sec:a} [lines~\ref{milp:repeatiii},  Alg.~\ref{alg:milpgraph}]. %% For instance, in Fig.~\ref{fig:id}, subtasks $(v_1, v_4)$ and $(v_1, v_2)$ are independent. If $(v_1, v_4)$ is the first one to be completed and $(v_4, v_3)$ follows, then, the leaving vertices pointing to vertices associated with  $\gamma(v_1)$ should point to the initial locations, and the leaving vertices pointing to vertices associated with $\gamma(v_4)$ should correspond to the incoming edge label $\gamma'$.
Note that, if $X_{\prec_P }^e \neq \emptyset$,  there is no need to find such leaving vertices  pointing to initial locations since subtask $e$ is impossible to be the first one.}\label{edge:vertex3}



Finally,  when the iteration over all subtasks in $X_{P}$ is over, we finish the construction of  the edge set $\ccalE_\ccalG$ [line~\ref{milp:for2},  Alg.~\ref{alg:milpgraph}].

\subsection{Formulation of the MILP}\label{sec:milp}
In this section, as indicated by block \circled{4} in Fig.~\ref{fig:overview}, we propose a MILP-based method inspired by the vehicle routing problem (VRP) with temporal constraints~\citep{bredstrom2008combined} to obtain a high-level plan that induces a simple path in $\auto{subtask}^-$ connecting $v_0$ and $\vertex{accept}$. In the VRP, a fleet of vehicles traverses a given set of customers such that all vehicles depart from and return to the same depot, and each customer is visited by exactly one vehicle. Typically, a weighted graph is built with vertices corresponding to the customers and the depot, edges corresponding to the paths the vehicles can travel along, and edge weights representing the travel cost, e.g., energy and time. Then, a MILP-based model can be formulated to solve the problem. Compared to the VRP, the LTL-MRTA problem is significantly more complicated. Starting from vertices pointing to initial locations,  robots move along edges in $\ccalG$ to drive the transition in~$\auto{subtask}^-$ from $v_0$ to $\vertex{\text{accept}}$. First, robots are not required to return to their initial locations. Instead, there may exist robots that need to execute the task forever corresponding to the  ``always'' operator. Second, there may exist labeled regions that do not need to be visited at all and others that need to be visited exactly once,  more than once, or even infinitely many times. Finally, complex temporal constraints exist among robots.


In the formulated MILP. there are five types of constraints, include routing constraints, scheduling constraints, logical constraints, temporal constraints, and transition constraints. The details can be found in Appendix~\ref{app:appendix_prefix_milp}.

{{
\subsection{Construction of robot prefix plans from the MILP solution}\label{sec:path}
Given the solution to the  MILP formulated in Appendix~\ref{app:appendix_prefix_milp}, we first extract a time axis by sorting the completion time of all subtasks such that each time instant in the time axis is the completion time of one subtask in $X_P$ for which the MILP is formulated. This time axis produces a linear extension of the poset $P$ and  will be used to extract a simple path from the NBA $\auto{subtask}^-$. Next, we extract a high-level plan for each robot  that will be concretized to generate low-level paths satisfying the specification $\phi$; see also block~\circled{5}  in Fig.~\ref{fig:overview}.


\subsubsection{Time axis:}\label{sec:timeaxis} The progress made in $\auto{subtask}^-$ is directly linked to the satisfaction of edge labels, and further according to condition~\hyperref[cond:d]{\it (d)} in Definition~\ref{defn:run}, the satisfaction of every edge label in $\auto{subtask}^-$ leads to the satisfaction of its end vertex label except $\vertex{accept}$. Therefore, we collect the set of completion time of all subtasks in $X_P$ (time when edges are enabled)
and  sort them in ascending order to form a single increasing time axis, denoted by $\vec{t}$. We note that there are no identical time instants in the time axis since subtasks are completed at different times in the simple path.



\subsubsection{High-level plans for robots:} Next we extract a high-level plan for each robot, which is a sequence of waypoints that are related  to  the completion of subtasks in $X_P$, along with a sequence of increasing time instants. For each robot $[r,j]$, let $p_{r,j}$ denote its high-level plan and $t_{r,j}$ denote its  timeline. Consider the vertex $v^*_0 \in \ccalV_{\text{init}}$ in the routing graph $\ccalG$ that points to the initial location of  robot $[r,j]$  and let $v^*_1$ be the vertex such that $x_{v^*_0 v^*_1 r} =1$, where $x_{v^*_0 v^*_1 r} \in \{0,1\}$ is a routing variable which is 1 if robot $r$ traverses the edge $(v^*_0, v_1^*) \in \ccalE_\ccalG$ (see Appendix~\ref{app:appendix_prefix_milp}). Note that robot $r$ can only traverse one outgoing edge of $v_0^*$. Also,  recall that each vertex in the routing graph $\ccalG$ is associated with a label captured by the mapping $\ccalM_{\mathsf{lits}}^{\ccalV}$. If the label of $v_1^*$ is a vertex label, we continue to search for vertex $v_2^*$ such that $x_{v_1^* v_2^* r}=1$ until a vertex $v^* \in \ccalV_\ccalG$ associated with an edge label is found. Then the associated region  $\ccalM^\ccalV_{\ccalL}(v^*)$ is the first waypoint robot $r$ visits to complete a subtask. we add this region $\ccalM^\ccalV_{\ccalL}(v^*)$ to the plan $p_{r,j}$. Next, the visit time  $t^-_{v^* r}$ (scheduling variable denoting the time  when robot $r$ arrives at vertex $v^*$) is the completion time of the associated subtask, captured by $\ccalM_{e}^{\ccalV}(v^*)$. We add the time $t^-_{v^* r}$ to the timeline $t_{r,j}$. Note that each time instant in the time axis $\vec{t}$ corresponds to one subtask. Therefore, this visit time $t^-_{v^* r}$ is identical to one time instant in $\vec{t}$ that is associated with the same subtask.   Continuing this process, we can construct a sequence of waypoints along with the associated timeline where visit times are aligned with time instants in the time axis $\vec{t}$. Based on the high-level plan $\{p_{r,j}\}$, we design low-level executable paths to take into account negative literals.

%% \blue{The synthesized plan corresponds to the whole or a partial prefix plan
%%   depending on whether a vertex label exists for $\vertex{accept}$, which will be discussed in Section~\ref{sec:suf}. Note that the high-level plans are defined on an abstraction of the workspace, minimizing the traveling distance between regions and ignoring inter-robot collision avoidance. Furthermore, these plans are associated with the relaxed automaton $\auto{relax}^-$. In Section~\ref{sec:solution2mrta}, we show how to use these high-level plans to generate low-level executable plans that work for the original automaton $\autop^-$.}
\begin{cexmp}
 {After solving the MILP for the workspace in Fig.~\ref{fig:workspace}, the high-level plans and the associated timelines for robots are as follows: $p_{2,1} = p_{3,1} = \{\ell_2, \ell_3\}, t_{2,1} = t_{3,1} = \{4, 12\},    p_{2,2} = \{\ell_4\}$, $t_{2,2} = \{8\}$.    That is, robots $[2,1]$ and $[3,1]$ visit the office building $\ell_2$ at time instant 4, then robot $[2,2]$ visits the road at time instant 8, and finally robots $[2,1]$ and $[3,1]$ visit the  open area $\ell_3$ at time instant 12. The remaining  robots remain idle. Observe that the lengths of the plans differ since every robot may undertake different number of subtasks. The induced run from $\auto{subtask}^-$ in Fig.~\ref{fig:sub-NBA} is $\vertex{init}, v_1, v_2, v_3, v_6$. The associated time axis  is $\vec{t} = \{0, 4, 8, 12\}$, one time instant per subtask. In words, the subtask $(\vertex{init}, v_1)$ is completed at time instant 0 and the subtask $(v_1, v_2)$ is completed at time instant 4, which corresponds to the event that robots $[2,1]$ and $[3,1]$ visit the office building $\ell_2$ at time instant 4.
  }
\end{cexmp}

 \subsection{Design of Low-Level Paths that Satisfy the Original LTL Task}
  This section presents the correction stage that concretizes the high-level plan to satisfy the specification $\phi$; see also blocks \circled{6} and \circled{7} in Fig.~\ref{fig:overview}.
  We first extract a simple path from the NBA $\auto{subtask}^-$ connecting $v_0$ and $\vertex{accept}$ based on the time axis and the high-level plan. To satisfy the specification $\phi$, while following along the found simple path, we formulate a sequence of generalized multi-robot path planning (GMRPP) problems by convert each subtask into one instance of GMRPP. Each instance of GMRPP is essentially the generalization of the multi-robot point-to-point problem, whose goal  is to determine a collection of executable paths such that robots complete the current subtask (by enabling the edge label at the end while respecting the starting vertex en route) and automatically activate the next subtask after completion since the satisfaction of the edge label leads to the satisfaction of  the starting vertex of the next subtask. The details can be founded in Appendix~\ref{sec:solution2mrta}. We also discuss different implementations of
  the GMRPP in~\ref{sec:extension_gmrpp}.
\subsection{Construction of robot suffix paths}\label{sec:suf}
In this section, we construct robot paths for the suffix part. We assume that the high-level plan found in Section~\ref{sec:path} for the prefix part has been used to generate low-level paths as in Appendix~\ref{sec:solution2mrta}, which induces a run in $\autop$ connecting $v_0$ and $\vertex{accept}$. Thus, the final robot locations of the prefix part are known. In what follows, we proceed depending on whether vertex $\vertex{accept}$ has a self-loop.

If  vertex $\vertex{accept}$ has a self-loop, we first examine whether the final locations of the prefix part satisfy its label $\gamma_\phi(\vertex{accept})$. If yes, we conclude that we found a collective path that satisfies the specification $\phi$. Otherwise, we remove this self-loop since it does not contribute to the finding of the suffix paths. By treating the final locations of the prefix paths as the initial robot locations of the suffix paths, the suffix paths aim to drive the progression in~$\autop$ back to vertex $\vertex{accept}$ and send robots to initial locations of the suffix part to close the trajectories.
%% We have discussed the suffix part when the given accepting vertex $\vertex{accept}$ has a self-loop; see Fig.~\ref{fig:prefix_no_self_loop}. Its vertex label is satisfied automatically by the final robot locations of the prefix part since in step {\it (B$_2$)} in  Section~\ref{sub-NBA:1} we remove any incoming edge of $\vertex{accept}$ if the edge label does not strongly imply the label $\gamma_{\phi}(\vertex{accept})$.
The basic idea is to  view the simple cycle around $\vertex{accept}$ as a simple path, by treating the accepting vertex on the starting side of this simple path as the initial vertex $v_0$ and the other accepting vertex on the ending side as the goal to be reached. Then, starting from the NBA $\autop^-$ in Section~\ref{sec:prune}, we can follow a procedure similar to the prefix part to obtain paths for the suffix part.



  \subsubsection{Extracting subtasks and inferring the temporal order from the NBA:}\label{sec:suf_prune}
  \paragraph{(1) Extraction of sub-NBA $\auto{subtask}$ from $\auto{relax}$:}\label{sec:suf_extract} First, based on the NBA $\autop^-$ we obtain the relaxed NBA $\auto{relax}$, as in Section~\ref{sec:prune}.  Then, similar to finding the shortest simple cycle around $\vertex{accept}$ in Section~\ref{sec:sort}, we remove all other accepting vertices from $\auto{relax}$ and then remove all initial vertices if they do not have self-loops. Let $\gamma_{\phi}(\vertex{prior}, \vertex{accept})$ denote the edge label corresponding to the last completed subtask in the prefix part. After generating the low-level paths for the prefix part, the final robot locations of the prefix part satisfy $\gamma_{\phi}(\vertex{prior}, \vertex{accept})$ (see Fig.~\ref{fig:lasso}).

  Next, since $\vertex{accept}$ does not have a self-loop,  by condition \hyperref[cond:f]{\it (f)} in Definition~\ref{defn:run}, we remove any outgoing edges of $\vertex{accept}$ (acting as $v_0$) from $\auto{relax}$ if $\gamma_{\phi}(\vertex{prior}, \vertex{accept})$ does not imply its edge label in $\autop$. Similar to the satisfaction check in Section~\ref{sec:sort}, the implication check is also  conducted in $\autop$. By condition \hyperref[cond:f]{\it (f)}, if the set of restricted accepting runs is nonempty, the  implication holds  for some  outgoing edges of some accepting vertices.

  Furthermore, we remove any incoming edges of $\vertex{accept}$ (acting as $\vertex{accept}$) from $\auto{relax}$ if the corresponding edge label in $\autop$ is not implied by $\gamma_\phi(\vertex{prior}, \vertex{accept})$.  We note that the implication check is also conducted in the NBA $\autop$. By condition \hyperref[cond:f]{\it (f)}, if the set of restricted accepting runs is nonempty, the implication holds for some incoming edges of some accepting vertices.

  Finally, we  follow Section~\ref{sub-NBA:1} to  extract a sub-NBA $\auto{subtask}$ from $\auto{relax}$ for the pair $\vertex{accept}$ (acting as $v_0$) and $\vertex{accept}$. The structure of $\auto{subtask}$ is shown in Fig.~\ref{fig:suffix} where $v_0$ does not have a self-loop. We also depict the vertex $\vertex{prior}$ in the prefix part for better understanding.  Then, we prune $\auto{subtask}$ to obtain the NBA $\auto{subtask}^-$, as in Section~\ref{sub-NBA:2}.


  \begin{cexmp}[($\auto{subtask}^-$ for the suffix part)]
The suffix part for task~\hyperref[task:i]{\it (i)} only consists of the accepting vertex $\vertex{accept}$. The sub-NBA $\auto{subtask}^-$ associated with the suffix part for task~\hyperref[task:ii]{\it (ii)} is a cycle $v_3, v_1, v_2, v_3$ (see Fig.~\ref{fig:suffix_ii}).
  \end{cexmp}
  \paragraph{(2) Inferring temporal order between subtasks in $\auto{subtask}^-$:} We collect all simple cycles in $\Theta$ connecting $\vertex{accept}$ and $\vertex{accept}$. Because the initial robot locations of the suffix part satisfy $\gamma_{\phi}(\vertex{prior}, \vertex{accept})$, it also satisfies the label of the last edge in each simple cycle $\theta\in \Theta$ since those edges whose labels are not implied by $\gamma_\phi(\vertex{prior}, \vertex{accept})$ are removed when constructing $\auto{subtask}$.
  By taking such a simple cycle $\theta$, not only the transition is driven back to $\vertex{accept}$, but further  robots are able to return to their initial locations to close the trajectories. %% while respecting the same-$\ag{i}{j}$ constraints in Section~\ref{sec:samegroup}.
 Finally, we infer a set of posets $\{P_\text{suf}\}$ from simple cycles in $\Theta$ and sort them as before.
\begin{figure}[!t]
    \centering
    \includegraphics[width=0.4\linewidth]{suffix.pdf}
    \caption{$\auto{subtask}^-$ for the suffix part when $\vertex{accept}$ does not have a self-loop, where $\gamma_1$, $\gamma_2$ and $\gamma_3$ are edge labels and $\ccalC_{\text{prior}}^+$ is positive subformula that is satisfied by final robot locations of the prefix part; see Section~\ref{sec:suf_milp}.}
    \label{fig:suffix}
\end{figure}

 \begin{figure}
    \centering
    \includegraphics[width=0.5\linewidth]{suffix_ii.pdf}
    \caption{$\auto{subtask}^-$ for task (ii) obtained from Fig.~\ref{fig:nba_ii_prune}. A clause $\ap{1}{1}{2,1}$ is added to the edge label $\gamma(v_2, v_3)$; see Section~\ref{sec:suf_milp}.} \label{fig:suffix_ii}
  \end{figure}
\subsubsection{Finding paths  on $\auto{subtask}^-$:}\label{sec:suf_milp} Similar to the prefix part, we find the suffix paths by iterating over the set of posets $\{P_\text{suf}\}$. By condition~\hyperref[asmp:c]{\it (c)} in Assumption~\ref{asmp:same}, robots need to return to initial locations to close their trajectories while driving the transition in $\autop$ back to $\vertex{accept}$. To establish the completeness of our proposed method, we implement this sequentially. In the first step, those robots participating in the satisfaction of the positive subformula in $\gamma_\phi(\vertex{prior}, \vertex{next})$ return to  regions corresponding to their initial locations of the suffix part, and at the same time drive the transition back to $\vertex{accept}$. In the second step, robots return to their initial locations while not violating the specification $\phi$. We  discuss how to  meet condition~\hyperref[asmp:c]{\it (c)} in single step in Appendix~\ref{app:loop}.



 To achieve the first step, we  find the satisfied clause, denoted by $\ccalC_{\text{prior}}$, in the edge label $\gamma_\phi(\vertex{prior}, \vertex{next})$; we denote by  $\ccalC_{\text{prior}}^+$ and $\ccalC_{\text{prior}}^-$ the positive and negative subformulas in $\ccalC_{\text{prior}}$, respectively.  Next, we find the set $P_{\text{min}}$ of subtasks in $X_P$ that can be the last one to be completed. For each subtask $e = (v_1, v_2) \in P_{\text{min}}$, we augment its edge label $\gamma(v_1, v_2)$ with the clause $\ccalC_{\text{prior}}^+$, i.e., $\gamma(v_1, v_2) = \gamma(v_1, v_2) \vee \ccalC_{\text{prior}}^+$; see also Fig.~\ref{fig:suffix}.  If $e \in P_{\text{min}}$ is truly the last subtask to be completed, we require the clause $\ccalC_{\text{prior}}^+$ to be satisfied. We say that $\ccalC_{\text{prior}}^+$ is satisfied if those robots involved in satisfying $\ccalC_{\text{prior}}^+$ in the prefix part return to  regions corresponding to their initial locations. For instance, in Fig.~\ref{fig:suffix_ii} that shows $\auto{subtask}^-$ for task~\hyperref[task:ii]{\it (ii)}, we augment the label of the last edge with $\ccalC_{\text{prior}}^+ = \ap{1}{1}{2,1}$, which is the clause in the last edge label of the prefix part (see Fig.~\ref{fig:nba_ii_subtask}). Combined with the negative subformula $\ccalC_{\text{prior}}^-$, if $\ccalC_{\text{prior}}^+ \wedge \ccalC_{\text{prior}}^-$ is satisfied, the original edge label $\gamma_\phi(v_1, v_2)$  will also be satisfied since, by condition~\hyperref[cond:f]{\it (f)} in Definition~\ref{defn:run}, the label $\gamma_\phi(\vertex{prior}, \vertex{accept})$ implies the original edge label $\gamma_\phi(v_1, v_2)$ (acting as $\gamma_\phi(\vertex{prior}', \vertex{accept})$; see Fig.~\ref{fig:lasso}). In this way, robots return to regions corresponding to their initial locations and at the same time drive the transition back to $\vertex{accept}$. In what follows, we first  present the construction of the routing graph and the formulation of the MILP for the first step, and then introduce the second step to close robot trajectories.
  \paragraph{(1) Construction of the routing graph:} Given the poset $P$, we build a routing graph $\ccalG = (\ccalV_G, \ccalE_G)$ following almost the same steps in Section~\ref{sec:graph}. The exceptions are all related to the augmented clause $\ccalC_{\text{prior}}^+$.   When building the vertex set $\ccalV_\ccalG$, each time we encounter a literal in $\ap{i}{j}{k,\chi}$ in $\mathsf{lits}^+(\ccalC_{\text{prior}}^+)$, we create $i$ vertices and let each vertex point to the region $\ell_k$.  Also, we build a one-to-one correspondence between  vertices and robots satisfying this literal in the prefix part since these robots need to return to their respective regions. We emphasize that each such vertex is associated with a single robot instead of a type of robots.  The mappings are created according to the same  procedure  in Section~\ref{sec:vertex}.

  When  building the edge set $\ccalE_\ccalG$, there are no outgoing edges from  vertices associated with the literals in $\ccalC_{\text{prior}}^+$ since these vertices will be where robots reside at the final moment. The incoming edges of these vertices are constructed by treating $\ccalC_{\text{prior}}^+$ as a regular clause  in an edge label but with one exception.  Recall that in case~\ref{sec:b}, when identifying the leaving vertices  associated with prior subtasks, when the number of leaving vertices is the same as  the number of end vertices, we randomly create   one-to-one edges since all robots visiting these leaving vertices belong to the same type. However, here we create edges from all leaving vertices to each vertex associated with literal $\ap{i}{j}{k,\chi}$ in $\ccalC_{\text{prior}}^+$ since each vertex associated with this literal  is only allowed to be visited by a specific robot of a specific type, making all robots heterogeneous in this sense.
\stepcounter{mycounter}
\paragraph{(2) Formulation of the MILP problem:}  To find a high-level plan, we formulate a MILP  based on the routing graph $\ccalG$
by following  similar procedures to the prefix part, but with the exception that at last, some robots need to return to their respective regions. The detailed formulation can be found in Appendix~\ref{app:appendix_suffix_milp}
\paragraph{(3) Closing the robot trajectories:}\label{sec:closing}
We present the second step to close robot trajecotries.  After solving the MILP for the suffix part, we utilize the method in  Appendix~\ref{sec:solution2mrta} to obtain low-level paths that drive the transition in $\autop$ back to $\vertex{accept}$, and robots involved in $\ccalC_{\text{prior}}^+$ return to regions corresponding to their initial locations of the suffix part. Note that when generating the low-level paths for the last completed subtask $(\vertex{prior}', \vertex{accept})$, we seek to satisfy  the augmented  clause $\ccalC_{\text{prior}}$  in its edge label. By conditions~\hyperref[cond:d]{\it (d)} and~\hyperref[cond:f]{\it (f)} in Definition~\ref{defn:run}, we have $\gamma_\phi(\vertex{prior}, \vertex{accept}) \simplies \gamma_\phi(\vertex{accept}, \vertex{next})$ and $\gamma_\phi(\vertex{accept}, \vertex{next}) \simplies_s \gamma_\phi(\vertex{next})$, thus the initial locations of the suffix part satisfy the edge label $\gamma_\phi(\vertex{accept}, \vertex{next})$ and the  vertex label $\gamma_\phi(\vertex{next})$, so do the final locations in the low-level paths that enable $\gamma_\phi(\vertex{prior}', \vertex{accept})$ since they satisfy $\ccalC_{\text{prior}}$. Next, to close robot trajectories, robots return to their initial locations starting from the final locations in the low-level paths, while satisfying the clause $\ccalC_{\text{prior}}$ en route, thus satisfying $\gamma_{\phi}(\vertex{next})$. Because those robots involved in $\ccalC_{\text{prior}}^+$ have returned to their respective regions, and further by Assumption~\ref{asmp:env} each region spans consecutive cells,  they can return to their initial locations by traversing inside their respective regions. In this way, the NBA $\autop$ remains at vertex $\vertex{next}$, thus the specification $\phi$ is not violated. The problem of finding this path can be formulated as a generalized multi-robot path planning problem; see Appendix~\ref{sec:mapp}.

 \begin{rem}
   Closing robot trajectories in two steps is sufficient for the completeness of our proposed method (see Appendix~\ref{app:completeness_} for the proof of the completeness). Consider the single-step approach (see Appendix~\ref{app:loop}) where robots return to their initial locations of the suffix part at the same time  the progression in the NBA $\autop$ advances to $\vertex{accept}$, which implies that robots return to their initial locations to satisfy the last subtask $(\vertex{prior}', \vertex{accept})$. However, it might be possible  that the initial locations violate the vertex label $\gamma_\phi(\vertex{prior}')$ of the last subtask. In this case, when robots head towards their initial locations, once they reach regions corresponding to their initial locations, the last subtask is enabled and it has to be completed since its vertex label is violated. Nonetheless, at the same time robots may not reach their initial locations inside these regions. Therefore, the single-step approach fails. But practically, this kind of  cases rarely occur.  We found that in the simulations in Section~\ref{sec:sim}, adopting the single-step approach works well.
 \end{rem}

%% while traversing inside their respective regions. In this process, the observations remain the same as the initial locations. Because the initial locatoins enable the edges $\gamma_\phi(\vertex{accept}, \vertex{next})$ and edge label strongly imply the vertex label $\gamma_\phi(\vertex{next})$ according to condition~\hyperref[cond:d]{\it (d)} in Definition~\ref{defn:run}, the NBA $\autop$ remains at the vertex $\vertex{next}$ during the closing of robot trajectories, which does not violate the specification \ltlx.

\subsubsection{Obtaining the best path:}
Finally, for each poset $P \in \{P_{\text{suf}}\}$, we can potentially find one suffix path (failures may occur if the MILP formulation is physically infeasible). Then we select the suffix path over $\{P_{\text{suf}}\}$ with the lowest cost, which will be the best suffix path that corresponds to a poset $P_{\text{pre}}$ in the prefix part for the given pair $(v_0, \vertex{accept})$. This best suffix path and the prefix path corresponding to $P_{\text{pre}}$ constitute a best total path for the poset $P_{\text{pre}}$ given the pair $(v_0, \vertex{accept})$. Then, according to~\eqref{eq:cost}, we select the best total paths over posets in $\{P_{\text{pre}}\}$ for the given pair $(v_0, \vertex{accept})$.  Finally, we can obtain the best total path by iterating over all pairs of initial and accepting vertices with finite total length. We highlight that our method can terminate anytime once a feasible path is found, but running the algorithm longer can lead to more optimal feasible paths.


\begin{figure}
  \centering
  \subfigure[$t=4$]{
    \includegraphics[width=0.3\linewidth]{gridworld_4.pdf}
    \label{fig:frame4}
  }
  \subfigure[$t=8$]{
    \includegraphics[width=0.3\linewidth]{gridworld_8.pdf}
    \label{fig:frame8}
  }
  \subfigure[$t=15$]{
    \includegraphics[width=0.3\linewidth]{gridworld_15.pdf}
    \label{fig:frame15}
  }
  \caption{Key frames demonstrating the execution of low-level paths that satisfy task~\hyperref[task:i]{\it {(i)}}. The initial configuration is shown in~Fig.~\ref{fig:workspace}. Fig.~\ref{fig:frame4} shows that at time instant 4, robots $[2,1]$ and $[3,1]$  reach the office building $\ell_2$, while robot $[2,2]$ is on the way to  road $\ell_4$. Fig.~\ref{fig:frame8} shows at time instant 8, robot $[2,2]$ reaches road $\ell_4$ while robots $[2,1]$ and $[3,1]$ head towards the open area $\ell_3$. Finally, they reach $\ell_3$ in Fig.~\ref{fig:frame15} at time instant 15. Robots $[1,1]$ and $[1,2]$ remain idle throughout the process.}
  \label{fig:frames}
  \end{figure}
\begin{cexmp}[(Low-level paths)]
  Continue with task~\hyperref[task:i]{\it {(i)}}. When generating low-level paths, we also consider collision avoidance. Fig.~\ref{fig:frames} shows an array of 3 key frames where some subtasks are completed. Observe that task~\hyperref[task:i]{\it {(i)}} is completed at time  15,  longer than 12 given by the high-level plan since  the high-level plan uses the shortest traveling time between regions and does not consider collision avoidance.
\end{cexmp}


\section{Theoretical Analysis}\label{sec:correctness}
In this section, we analyze the completeness and soundness of our method. First we show that, with mild assumptions, our method is complete for \ltlz specifications.
\begin{thm}[(Completeness)]\label{thm:completeness}
  Considering  a discrete workspace  satisfying Assumption~\ref{asmp:env}, a team of $n$ robots of $m$ types and a valid specification $\phi\in \textit{LTL}_{-\bigcirc}^0$, if there exists a path $\tau = \tau^\textup{pre} [\tau^\textup{suf}]^\omega$ that induces a restricted accepting run $\rho = \rho^\textup{pre} [\rho^\textup{suf}]^\omega =  v_0, \ldots, \vertex{prior}, \vertex{accept}$ $ [\vertex{next}, \ldots, \vertex{prior}', \vertex{accept}]^\omega$ in the pre-processed $\autop$ and satisfies  Assumption~\ref{asmp:same}, our method can find a  robot path $\tilde{\tau}=\tilde{\tau}^{\textup{pre}} [\tilde{\tau}^{\textup{suf}}]^\omega$ that satisfies the specification $\phi$.
  %% generates a word $\tilde{w}= \tilde{w}^{\textup{pre}} [\tilde{w}^{\textup{suf}}]^\omega$ which induces a restricte accepting run $\tilde{\rho}= \tilde{\rho}^{\textup{pre}} [\tilde{\rho}^{\textup{suf}}]^\omega$, and the path $\tilde{\tau}$ satisfies the Assumption~\ref{asmp:same}.
  %% belonging to $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\autop)$, where $v_0$ and $\vertex{accept}$ is a certain pair of initial and accepting vertices. That is, the path $\tau$ can induce a run in $\autop$ that the a prefix part of a restricted accepting run.
\end{thm}

The detailed proof can be found in~Appendix \ref{app:correctness}. The main idea is to first prove feasible paths still exist in $\auto{subtask}^-$ after a series of relaxation, extraction and pruning. Based on this, we prove the feasibility of the MILP formulation and further the feasibility of the GMRPP.

\begin{rem}
  We emphasize that the completeness in Theorem~\ref{thm:completeness} is ensured for \ltlz rather than \ltlx specifications. This is because  task allocation related to induced atomic propositions in the prefix part may not lead to feasible allocations  in the suffix part. However, when the \ltlx specification can be satisfied by finite-length paths, such as co-safe LTL~\textup{\citep{kupferman2001model}} or LTL$_f$ \textup{\citep{de2013linear}}, our method is complete; see Proposition~\ref{thm:prefix} in Appendix~\ref{app:completeness}.
\end{rem}

\begin{rem}
  We note that the found path $\tilde{\tau}$ may not induce a restricted accepting run. In Definition~\ref{defn:run}, robots close  their trajectories at the same time the progression returns  to $\vertex{accept}$. However, in our  method, when the NBA $\autop$ returns to $\vertex{accept}$, only those robots involved in completing the last subtask in the prefix part return to regions corresponding to their initial locations. Thereafter,  trajectories are closed.
\end{rem}

The following statement, a direct consequence of Theorem~\ref{thm:completeness}, says that the found path satisfies the specification in the larger class $\textit{LTL}_{-\bigcirc}^\chi$, regardless of whether the workspace satisfies Assumption~\ref{asmp:env} and how the GMRPP is implemented.
\begin{cor}[(Soundness)]\label{thm:soundness}
  Considering  a discrete workspace, a team of $n$ robots of $m$ types and a valid specification $\phi\in \textit{LTL}_{-\bigcirc}^\chi$,  no matter how each GMRPP is implemented, the returned path, if any, satisfies the specification $\phi$.
  %% generates a word $\tilde{w}= \tilde{w}^{\textup{pre}} [\tilde{w}^{\textup{suf}}]^\omega$ which induces a restricte accepting run $\tilde{\rho}= \tilde{\rho}^{\textup{pre}} [\tilde{\rho}^{\textup{suf}}]^\omega$, and the path $\tilde{\tau}$ satisfies the Assumption~\ref{asmp:same}.
  %% belonging to $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\autop)$, where $v_0$ and $\vertex{accept}$ is a certain pair of initial and accepting vertices. That is, the path $\tau$ can induce a run in $\autop$ that the a prefix part of a restricted accepting run.
\end{cor}

 %% (i) determine the set of sets of atomic propositions $\sigma$'s in $w$ that enable the edge transitions in $\rho$. The set of atomic propositions $\sigma_e$ indexed by $e\in \mathbb{N}$  is such if $v_{e-1} \neq v_e$ in the run $\rho$; (ii) randomly select one clause in the edge label $\gamma(v_{e_1}, v_e)$ is satisfied by $\sigma_e$, then all literals in this clause also appear in $\sigma_e$. We collect these literals to construct the $e$-th set $\sigma^*_e$ in the essential word; (iii)
\section{Simulation Results}\label{sec:sim}
We present three case studies, implemented in Python 3.6.3 on a computer with 2.3 GHz Intel Core i5 and 8G RAM, that illustrate the correctness and scalability of our method. The MILP is solved using Gurobi~\citep{gurobi} with big-M $M_{\text{max}}=10^5$. We first examine the (sub-)optimality of our proposed method when the NBA can be  captured by a few posets. Second, we test the quality of the first solutions for various specifications by running our method longer. Finally, we compare our method with the existing work in terms of scalability by considering large-sized workspace and large number of robots. The results indicate that our method outperforms the existing work in terms of quality and scalability. We note that when implementing the method, we ignore constraints~\eqref{eq:lastsubtask0}-\eqref{eq:lastclause} in MILP which facilitate the transition between the prefix and suffix parts (see Appendix~\ref{sec:transition}) and adopt the single-step approach to close robot trajectories (see item~\hyperref[sec:closing]{(3)} in Section~\ref{sec:suf_milp}). We emphasize that for all specifications $\phi_1-\phi_{10}$ considered in the simulation, their sets of restricted accepting runs are nonempty, which demonstrates the broadness of this concept.

%% We generate a  $10\times 10$ grid world with 10 regions and 10 obstacles randomly placed in the world at each trial. The team of robots consists of of 5 types with $N$ robots of each type. The initial locations are randomly generated.

\subsection{Case study \RNum{1}: (Sub-)optimality for the highly structured NBA}
In this case study, we examine the quality of the found paths that satisfy those two tasks in the illustrative Example~\ref{exmp:1}, demonstrating the (sub-)optimality of the solutions when the corresponding NBA are highly structured. Here, we relate the high structure of an NBA to the detection of only a few posets in the sub-NBA $\auto{subtask}^-$. Observe that in Fig.~\ref{fig:sub-NBA}, a unique partially ordered set can capture the sub-NBA $\auto{subtask}^-$ for task~\hyperref[task:i]{\it (i)}. Similar observation can be obtained  on the sub-NBA $\auto{subtask}^-$ in Fig.~\ref{fig:nba_ii_subtask} for task~\hyperref[task:ii]{\it (ii)}.

To measure the cost of the solution in terms of the path length (number of transitions between different cells), we need to get access to the optimal cost. Due to the complexity of the LTL-MRTA problem, it is computationally expensive to get the optimal value. For instance, given the 9-by-9 workspace in Fig.~\ref{fig:frames}, the product transition system composed of 5 robots has $(9^2)^5=9^{10}$ states. Therefore, we take the following task-specific approach to get the shortest path length, without considering collision avoidance between robots. Specifically, in the workspace shown in Fig.~\ref{fig:frames},  we randomly generate the initial locations
of all robots that are at the right side of the vertical obstacles, i.e., the $x$-coordinate is larger than 4. Also, no robots are located inside region $\ell_2$. Task~\hyperref[task:i]{\it (i)} can be satisfied by finite-length paths, whose sub-NBA $\auto{subtask}^-$ is shown in Fig.~\ref{fig:sub-NBA}. To satisfy this task, two robots of type 1 first visit region~$\ell_2$ and then region $\ell_3$, and one robot of type 2 visits region $\ell_4$. We deal with this separately. First, we select two robots of type 1 as follows. For each robot of type 1, we calculate the path consisting of the shortest path from its initial location to a specific cell in region $\ell_2$ plus the shortest path from this cell to the  top-right cell in region $\ell_3$.  This total path is the shortest path the considered robot is going to  take if it is selected to sequentially visit $\ell_2$ and $\ell_3$. Of robots of type 1, we select the best two. Next, we select one robot of type 2 that has the shortest path from its initial location to the  rightmost cell in region $\ell_4$. Then, we take the sum of these three path length to get the optimal cost. Note that we did not consider the temporal relation between robots since they can go and go by taking the shortest paths. Similarly, for task~\hyperref[task:ii]{\it (ii)}, the prefix part (see Fig.~\ref{fig:nba_ii_subtask}) requires one robot of type 1 to visit region $\ell_2$, and the suffix part (see  Fig.~\ref{fig:suffix_ii}) requires the same robot to visit region $\ell_3$ then return to region $\ell_2$. We select the robot of type 1 that has the shortest path consisting of the shortest path from its initial location to a specific cell in region $\ell_2$ plus the shortest cycle from this cell to the top-right cell in region $\ell_3$ then back to itself. We set the total path length to  be the optimal cost.
\begin{table}[!t]
  \caption{Comparison between the optimal cost and solutions returned by our method. The merged column ``NoCol$+$Seq'' represents the case where collision avoidance is ignored and robots move sequentially, and the merged column ``Col$+$Sim'' incorporates collision avoidance and simultaneous execution. The notation $J^*$ is the optimal cost without considering collision avoidance. The number of trials out of 50 trials where the cost cost is equivalent to the optimal cost $J^*$ are shown inside the parentheses.}
  \label{tab:optimal}
  \centering
   \resizebox{\linewidth}{!}{\begin{tabular}{cccccc}
    \toprule
    \multirow{2}{*}{task} &  \multirow{2}{*}{$J^*$} & \multicolumn{2}{c}{NoCol$+$Seq} &\multicolumn{2}{c}{Col$+$Sim} \\
     \cmidrule(r){3-4} \cmidrule(r){5-6}
     &  & cost & horizon &  cost & horizon \\
     \midrule
         \hyperref[task:i]{\it (i)} & 27.2$\pm$3.1  & 28.0$\pm$3.3 (30) & 18.8$\pm$3.0 & 30.3$\pm$3.2 & 14.9$\pm$1.7 \\
         \hyperref[task:ii]{\it (ii)} & 18.7$\pm$1.2 & 21.6$\pm$2.8 \,\,(4) & 23.2$\pm$2.8 & 22.0$\pm$3.0 & 23.8$\pm$2.8 \\
         \bottomrule
  \end{tabular}}
\end{table}

After obtaining the optimal cost, given the same randomly generated initial locations,  we conduct two implementations of our proposed method. In the first implementation, we use the basic version of GMRPP with the absence of collision avoidance and sequential execution scheme (see Appendix~\ref{sec:gmmpp1}). In the sequential execution scheme, subtasks are addressed one by one, that is, only robots participating in the subtask under consideration have target points, whereas in the simultaneous execution scheme (see Appendix~\ref{sec:extension_essential}), several subtasks can be undertaken at the same time in that  robots participating in subsequent subtasks simultaneously  move towards ``intermediate'' target points. In the second implementation, we extend to incorporate the collision avoidance (see Appendix~\ref{sec:extension_collision}) and simultaneous execution scheme.  Both two implementations employ the full execution scheme (see Appendix~\ref{sec:gmmpp1}), in which all robots can move, whereas in the partial execution scheme (see Appendix~\ref{sec:extension_partial}), only necessary robots engaging in certain subtasks are allowed to move.  Table~\ref{tab:optimal} shows the statistical results, mean and standard deviation, about the cost and the horizon the found paths, average over 50 trials.

Without considering the collision avoidance, the path cost returned by our method is pretty close to the optimal cost, especially for task~\hyperref[task:i]{\it (i)} where the prefix paths suffice. Out of 50 trials, there are 30 trials in which our method can identify the optimal solutions. For task~\hyperref[task:ii]{\it (ii)}, the additional cost mostly arises from separately dealing with the prefix and suffix parts.  In the prefix part, the robot can visit the cell in region $\ell_2$ that is the closest to its initial location, however, it may incur more cost to return to this cell in the suffix part. The cost when considering the collision avoidance are also close to the optimal cost, which indicates that most times robots follow the shortest paths. As for the results about path horizon, we can see that, for task~\hyperref[task:i]{\it (i)}, simultaneous execution results in shorter horizon since one robot of type 2 can head toward region $\ell_4$ while two robots of type 1 leave for region $\ell_2$. Nonetheless, for task~\hyperref[task:ii]{\it (ii)}, the horizon remains almost the same. This is because subtasks cannot be executed in parallel by the same robot.



\begin{table*}[!t]
  \caption{Results for various specifications, where $N_{\text{pair}}$ is the number of pairs of initial and accepting vertices, $|\ccalA|$, $|\autop|$, $|\auto{subtask}^{-,\text{pre}}|$ and $|\auto{subtask}^{-,\text{suf}}|$ are the size of the NBA before and after pre-processing, for the prefix and suffix parts from which the first solutions are obtained, respectively.}
  \label{tab:quality}
  \centering
  \resizebox{\linewidth}{!}{\begin{tabular}{c|ccccc|cccccc}
    \toprule
    \multirow{2}{*}{Task} &  \multirow{2}{*}{$N_{\text{pair}}$} &  \multirow{2}{*}{$|\auto{}|$} & \multirow{2}{*}{$|\autop|$}  & \multirow{2}{*}{$|\auto{subtask}^{-,\text{pre}}|$}   & \multirow{2}{*}{$|\auto{subtask}^{-, \text{suf}}|$} & \multicolumn{2}{c}{$N_{\text{sol}}=1$} & \multicolumn{2}{c}{$N_{\text{sol}}=5$} & \multicolumn{2}{c}{$N_{\text{sol}}=10$}\\
    \cmidrule(r){7-8}  \cmidrule(r){9-10}  \cmidrule(r){11-12}
    & & & & & &  cost & time(sec) & cost & time(sec) & cost & time(sec)\\
    \midrule
    $\phi_3$ & 8 & (20, 142) & (20, 49) & (3, 2) & (5, 5) & 56.2$\pm$4.2 & 2.0$\pm$0.3 &  ---  &  ---  &   ---  &   ---\\
    $\phi_4$ & 4 &  (10, 57) & (10, 31) & (3, 2) & (3, 3) & 46.0$\pm$4.5 & 1.7$\pm$0.6 &  ---  &  ---  &  ---  &  --- \\
    $\phi_5$ &2 &  (11, 31) & (11, 25) & (10, 19) & (3, 3) & 17.6$\pm$6.2 & 0.7$\pm$0.2 & 17.6$\pm$6.2 & 3.4$\pm$0.8  & --- & --- \\
    $\phi_6$ &1  &(4, 9) & (4, 8) & (4, 5) & (4, 5) & 30.6$\pm$9.2 & 1.7$\pm$0.8 & 24.9$\pm$6.1 & 5.0$\pm$1.9 & 24.9$\pm$6.1 & 5.3$\pm$2.0 \\
    $\phi_7$ &3 & (24, 140) & (24, 104) & (22, 57) & (9, 18) &  49.3$\pm$9.5 & 3.8$\pm$2.5  &  49.3$\pm$9.5 & 4.4$\pm$2.5 &  49.3$\pm$9.5 & 5.6$\pm$2.5 \\
    $\phi_8$ &4 & (15, 83) & (15, 41) & (8, 13) & (8, 14) & 45.9$\pm$6.8  & 1.5$\pm$0.2 & 45.9$\pm$6.8  & 7.3$\pm$0.6  & 45.9$\pm$6.8  & 17.7$\pm$1.4  \\
    \bottomrule
  \end{tabular}}
\end{table*}

\subsection{Case study \RNum{2}: Quality of the first solutions} Common for the two specifications in the first case study is that the sub-NBA $\auto{subtask}^-$ for the prefix and suffix, respectively,  can be concisely captured by one poset, which may not be the case for most specifications. In this case study, we consider various specifications that can produce many posets, and we examine the quality of the first solutions for each specification by comparing with the best solutions when running longer to find  more solutions. We use the same workspace and robot team in the running example~\ref{exmp:1}. The considered specifications are as follows:
\begingroup
\allowdisplaybreaks
\begin{align*}
  \phi_3  = & \, \square \lozenge (\ap{2}{1}{2,1} \wedge \lozenge (\ap{2}{1}{3,1} \wedge \lozenge (\ap{2}{1}{4,1} \wedge \lozenge \ap{2}{1}{5,1}  )   )  ), \\
  \phi_4 = & \square \lozenge (\ap{2}{1}{2,1} \wedge \lozenge \ap{2}{1}{3,1}) \wedge \square (\ap{1}{1}{5,2} \simplies \bigcirc (\ap{1}{1}{5,2} \;\ccalU \, \ap{1}{2}{4})) \\
  &  \wedge \square \neg \ap{2}{1}{4}\\
  \phi_5  = & \, \lozenge (\ap{1}{2}{4,1} \wedge \bigcirc (\ap{1}{2}{4,1} \;\ccalU \, \ap{2}{1}{3})) \wedge \square \lozenge ( \ap{1}{2}{4,1} \wedge \lozenge \ap{1}{2}{3,1}), \\
  \phi_6  = & \,  \square \lozenge (\ap{1}{1}{3,1} \,\|\, \ap{1}{1}{5,1}) \wedge \square \lozenge \ap{1}{1}{2,1}  \wedge \square \lozenge (\ap{2}{2}{3} \,\|\, \ap{2}{2}{5})  \\
   & \wedge \square \neg \ap{2}{1}{4} \wedge \square \neg \ap{2}{2}{4}, \\
  \phi_7  = & \,  \square \lozenge (\ap{1}{2}{4} \wedge \bigcirc (\lozenge \neg \ap{1}{2}{4})) \wedge  \square \lozenge (\ap{1}{1}{5} \wedge \bigcirc (\lozenge \neg \ap{1}{1}{5} )) \\
  & \wedge  \lozenge  (\ap{3}{1}{3} \wedge \ap{2}{2}{3}), \\
  \phi_8 = & \, \square \lozenge  (\ap{2}{2}{4,1} \wedge \lozenge (\ap{2}{2}{2,1} \wedge \lozenge \ap{2}{2}{5,1}))  \wedge  \neg \ap{1}{2}{2} \;\ccalU \, \ap{2}{2}{4,1} \\
  & \wedge \neg \ap{1}{2}{5} \; \ccalU \, \ap{2}{2}{4,1} \wedge (\square \lozenge \ap{2}{1}{5}\, \| \,  \square \lozenge \ap{2}{1}{3}),
\end{align*}
\endgroup
where:

$\phi_3$ requires that the same two robots of type 1 meet first at regions $\ell_2$, then  $\ell_3$, next  $\ell_4$ and finally $\ell_5$, repeating this process infinitely often;

$\phi_4$ requires that the same two robots of type 1 meet at region $\ell_2$ and then $\ell_3$ infinitely many times. There exists one robot of type 1 such that every time  it visits region $\ell_5$, it should stay there until one robot of type 2 visits region $\ell_4$. Finally, at most one robot of type is at region $\ell_4$ at any time;

$\phi_5$ requires that one robot of type 2 visits region $\ell_4$ and stays there until two robots of type 1 reach region $\ell_3$, and this robot visits regions $\ell_4$ and then $\ell_3$ infinitely many times;

$\phi_6$ requires that one robot of type 1 visits regions $\ell_3$ or $\ell_5$ infinitely many times (robot can switch between these two regions) and the same robot visits region $\ell_2$ infinitely many times, two robots of type 2 meet at regions $\ell_3$ or $\ell_5$ infinitely many times, and at most one robot of any type is present at region $\ell_4$.

$\phi_7$ requires that one robot of type 2 visits region $\ell_4$ and then leave, repeating this infinitely many times. Similarly, for infinitely many times, one robot of type 1 visits region $\ell_5$ and then leave. Finally, all robots eventually meet at region $\ell_3$ .

$\phi_8$ requires that the same two robots of type 2 meet at region $\ell_4$, then $\ell_2$ and next $\ell_5$, repeating this infinitely many times, but with the restriction that no robots of type 2 reach regions $\ell_2$ and $\ell_5$ before two robots of type 2 meet at region $\ell_4$ for the first time. Finally, two robots of type 1 meet at regions $\ell_5$ or $\ell_3$ infinitely often.

Observe that the ``next''  operator $\bigcirc$ appears in some specifications. These  specifications  involving various operators are representative of commonly used complex tasks in robotics applications. Besides the emergency rescue scenario, $\phi_3$ can capture surveillance and data gathering tasks~\citep{smith2011optimal,guo2017distributed}, the subformula $\square \lozenge (\ap{1}{1}{3,1} \,\|\, \ap{1}{1}{5,1})$ in $\phi_6$ can specify intermittent connectivity tasks where robots are required to meet at communication regions indefinitely often to exchange data~\citep{kantaros2018distributed}. Futhermore, subformula $\square \neg \ap{2}{2}{4}$ in $\phi_5$ can avoid the collision between robots and $\neg \ap{1}{2}{2} \;\ccalU \, \ap{2}{2}{4,1}$ in $\phi_8$ can  prioritize certain subtasks to others.

We run 20 trials for every specification. In each trial, we randomly generate initial robot locations inside the label-free cells and no robots occupy the same cell. We consider collision avoidance, full  and simultaneous execution schemes. In Table~\ref{tab:quality}, we show  the number of pairs of initial and accepting vertices,  the size (number of vertices and edges) of the NBA before and after pre-processing, along with the size of the sub-NBA $\auto{subtask}^-$ for the prefix and suffix parts from which the first solutions are obtained. Furthermore, we terminate our method until all solutions or the first 10 solutions are generated, whichever comes first. We record the smallest cost that can be achieved in the first solutions, the first 5 solutions and the first 10 solutions, respectively, along with the accumulative runtimes. In  Table~\ref{tab:quality}, the symbol ``---'' means that only one solution found for $\phi_3$ and $\phi_4$, and less than or equal to 5 solutions found for $\phi_5$.

Observing Table~\ref{tab:quality}, we found that  the size of sub-NBA $\auto{subtask}^-$ is dramatically reduced compared to the size of NBA before pre-processing, especially for specifications $\phi_3$, $\phi_7$ and $\phi_8$. Dealing with smaller-sized sub-NBA saves computational times. It takes less than 20 seconds to get 10 solutions for specification $\phi_8$. On the other hand, observe that for specifications except $\phi_6$, the smallest cost  found in all or the first 10 solutions is equivalent to the cost of the first solutions, which indicates that the first solutions are of  high quality. For specification $\phi_6$, the best solution in the first 10 solutions belongs to  the first 5 solutions. This is  because we employ the optimization method and we sort the set of  posets in part according to their height which leads to small number of subtasks (see Section~\ref{sec:poset}).



\subsection{Case study \RNum{3}: Scalability}

In this case study, we examine the scalability of our proposed method with respect to the size of the workspace and the number of robots. In the first case, we  compare the performance with the BMC-based method in~\cite{sahin2019multi} and in the second case, we examine the effect of full or partial  execution on the performance.


\subsubsection{Comparison with the BMC method:}
Similar to our method,~\cite{sahin2019multi} adopt a hierarchical framework, which enhances the scalability from their previous work~\cite{sahin2017synchronous,sahin2019multirobot}. At the high level, the BMC  method abstracts the given transition system by aggregating states with the same observation, which generates an abstract transition system with much smaller size. Then, inspired by the Bounded Model Checking (BMC) method,  a high-level plan satisfying the specification is generated on the abstract transition system by formulating an ILP programming. After obtaining the high-level plan, a sequence of instances of  multi-robot path planning is used to concretize the high-level plan while taking into account the collision avoidance. Our method differs from the BMC method in~\cite{sahin2019multi} in the following several aspects. First, at the high level, the BMC method only focuses on the feasibility, which terminates as long as the first solution is obtained, whereas in our method, we infer the temporal order between subtasks and optimize the cost by formulating the MILP programming. Second, the high-level plans returned by the BMC method have the same horizon and obey the transition relation defined by the adjacency, whereas the high level plans returned by our method are concise in that they only specify sequences of essential regions and thus, do not necessarily have the same horizon. Third, at the low level, the path planner are responsible for satisfying the constraints imposed by the negative atomic propositions. Finally, our method is complete,  which is not guaranteed in~\cite{sahin2019multi}.
 \begin{figure}[!t]
    \centering
    \includegraphics[width=0.65\linewidth]{case2.pdf}
    \caption{Grid world from~\cite{sahin2019multi}}\label{fig:scalability}
 \end{figure}


To compare the scalability, we borrow the workspace used in~\cite{sahin2019multi}, a 30-by-30 grid world containing 6 regions $\ell_i, i=1,\ldots,6$; see also Fig.~\ref{fig:scalability}. We consider a team of $n$ homogeneous robots whose initial locations are randomly sampled inside region $\ell_1$. At each trial, $20\%$ of cells are randomly selected as obstacles. The specification is given as follows~\citep{sahin2019multi}.
\begin{align*}
  \phi_9 = \,   \square \lozenge \ap{n}{1}{2} \wedge   \square \lozenge \ap{n/2}{1}{3} &\,\wedge \square \lozenge \ap{n/2}{1}{4} \\
  & \wedge \neg \ap{1}{1}{4} \,\ccalU\, (\ap{1}{1}{5} \wedge \ap{1}{1}{6}),
\end{align*}
which requires (a) all robots meet at region $\ell_2$ infinitely often, (b) at least half of robots meet at regions $\ell_3$ and $\ell_4$, respectively, infinitely often, (c) robots should not visit region $\ell_4$ until at least one robot is inside region $\ell_5$ and one robot is inside region $\ell_6$ at the same time. We vary the number $n$ of robots, ranging from 4 to 30, which gives rise to a product transition system that has up to $(30\times30)^{30}  \approx 10^{90}$ states.

The size of the NBA is independent of the number of robots. The NBA $\autop$ has one pair of initial and accepting vertices, 5 vertices and 10 edges (excluding self-loops). The sub-NBA $\auto{subtask}^-$ for the prefix and suffix  parts has 5 vertices and 5 edges, and 4 vertices and 5 edges, respectively. In the implementation of our method, we employ the full and simultaneous execution schemes. We record runtimes  and cost of the first feasible solutions, where the cost is the sum of the cost of prefix and suffix parts. %% {Although translating LTL to NBA is worst-case exponential w.r.t. the length of the formula, in practice the translation is quick (0.03  seconds).}
Both methods consider the collision avoidance. The horizon increases by 10 when no solution exists for the GMRPP.
The statistical results, mean and standard deviation, average over 10 trials are shown in Table~\ref{tab:scalability}. The MATLAB code for the BMC method is available in~\url{https://github.com/sahiny/cLTL-hierarchical}.
\begin{table}[!t]
  \caption{Results with respect to the number of robots}\label{tab:scalability}
  \centering
  \resizebox{\linewidth}{!}{\begin{tabular}{ccccc}
      \toprule
      \multirow{2}{*}{$N$} & \multicolumn{2}{c}{Our method} & \multicolumn{2}{c}{BMC method} \\
      \cmidrule(r){2-3}  \cmidrule(r){4-5}
      & cost & time(sec) & cost & time(sec) \\
      \midrule
      4 & 270.6$\pm$4.4 & 62.4$\pm$1.4 & 944.4$\pm$21.2 & 76.5$\pm$13.8\\
      8 & 513.0$\pm$30.2 & 124.9$\pm$9.2 & 1819.0$\pm$149.9 & 334.9$\pm$153.9 \\
      12 & 794.6$\pm$11.1 & 187.4$\pm$9.1 &  2217.0$\pm$163.8 &  704.3$\pm$178.0\\
      16 & 1080.2$\pm$14.7 & 502.0$\pm$225.4 & 2725.8$\pm$149.2 & 1135.8$\pm$123.7\\
      30 & 2509.4$\pm$168.9 & 4072.1$\pm$985.4 & --- &--- \\
      \bottomrule
  \end{tabular}}
\end{table}

As we can see, our method outperforms the BMC method both in runtimes and quality of the solutions. Specifically, as the number of robots increases, the runtimes used by our method are about half of the runtimes used by the BMC method, but, the cost returned by our method is about 1/3 of the cost corresponding to the BMC method. When the number of robots is 30, the BMC method could not produce a solution within 2 hours. The reason is that we optimize the cost at both the high level and the low level, while the BMC method only considers the feasibility. Furthermore, the times of the low-level path planner being called have significant effect on the runtimes. In our method, the times of invoking the path planner is equivalent to or smaller than the number of subtasks in the extracted simple path based on the high-level plan (see Appendix~\ref{sec:run}). In the BMC method, each transition in the high-level plan is converted into one instance of multi-robot path planning problem. Apparently, the number of transitions is larger than the number of subtasks since each subtask may take multiple transitions.



\subsubsection{Effect of the full and partial execution schemes:} In the second case, we use the same workspace as shown in Fig.~\ref{fig:scalability}. We continue considering a teams of $n$ homogeneous robots with the following specification:
\begin{align*}
  \phi_{10} = \, \lozenge (\ap{3}{1}{5} \,\| \, \ap{3}{1}{6}) &\,\wedge   \square \lozenge (\ap{n/2}{1}{2,1} \wedge \lozenge \ap{n/2}{1}{4,1}) \\
  & \wedge  \square \lozenge \ap{n/4}{1}{3} \wedge \square \neg \ap{4}{1}{6},
\end{align*}
which requires (a) at least 3 robots eventually meet at either region $\ell_5$ or $\ell_6$, (b) a fleet of the same robots, at least half,  meets at region $\ell_2$ and then $\ell_4$, infinitely often, (c) at least a quarter of robots meet at region $\ell_3$ infinitely often, and (d) always no more than 3 robots can be present at region $\ell_6$ at the same time.



Before pre-processing in Section~\ref{sec:nba}, there are two pairs of initial and accepting vertices in the corresponding NBA, containing 8 vertices and 27 edges. After pre-processing,  the NBA $\autop$  has 8 vertices and 20 edges. For the first pair of initial and accepting vertices after sorting, the sub-NBA $\auto{subtask}^-$ associated with  the prefix and suffix parts have 7 vertices and 10 edges, and 5 vertices and 7 edges, respectively. We compare the performance of our method when using the full and partial execution schemes, respectively. We increase the number of robots up tp 32. The simulation setting is the same as that in the first case. The results averaged 10 trials are shown in Table~\ref{tab:scalability2}.

We found that the partial execution scheme takes less runtimes  compared with the full execution scheme. More importantly, this advantage becomes stronger as the number of robots increases. This is because as more robots are involved, more robots are not needed to move, treating them as obstacles can ease the computational burden imposed by increasing robots. For example, the subtask that at least 3 robots meet at region $\ell_5$ or $\ell_6$ only involves 3 robots no matter how large the robot team is. On the other hand, the partial execution scheme results in slightly smaller cost, which indicates that, even though the full execution scheme mobilizes all robots, those robots that do not participate in the specific subtask rarely move because of the optimized objective. Observe that for the partial execution scheme,  when 32 robots are involved, no solutions are generated in 3 out of 10 trials. This is because, as some robots are treated as obstacles,  the partial execution may make the GMRPP infeasible. Thus, it is better to use the partial execution when the workspace is relatively spacious considering the size of robots.


\begin{table}[!t]
  \caption{Results with respect to the number of robots.}\label{tab:scalability2}
  \centering
  \resizebox{\linewidth}{!}{\begin{tabular}{ccccc}
      \toprule
      \multirow{2}{*}{$n$} & \multicolumn{2}{c}{Full movement} & \multicolumn{2}{c}{Partial movement} \\
      \cmidrule(r){2-3}  \cmidrule(r){4-5}
      & cost & time(sec) & cost & time(sec) \\
      \midrule
      4 & 181.4$\pm$17.7 & 89.5$\pm$5.0 & 180.4$\pm$20.1 & 65.8$\pm$10.1\\
      8 & 356.6$\pm$16.0 & 198.9$\pm$12.3 & 354.2$\pm$15.2 & 129.3$\pm$4.9 \\
      12 & 573.5$\pm$63.3 & 350.7$\pm$25.4 &  554.3$\pm$49.4 &  192.5$\pm$10.4\\
      16 & 774.2$\pm$59.0 & 561.0$\pm$44.4 & 763.0$\pm$50.7 & 278.9$\pm$8.9\\
      32 & 1560.4$\pm$160.7 & 1886.8$\pm$696.0 & 1524.6$\pm$30.6$^*$ &  778.1$\pm$134.9 \\
      \bottomrule
  \end{tabular}}
  \begin{tablenotes}
    \small
  \item $^*$ 3 out of 10 trials failed.
  \end{tablenotes}
\end{table}

%% \subsubsection{Case \RNum{1}} {The cooperative persistence coverage task is}

%% \small
%% \begin{align*}
%%   %% & \phi = \square \lozenge \ap{x}{1}{1} \wedge \square \lozenge \ap{x}{2}{2} \wedge \square \lozenge \ap{x}{3}{3}  \wedge \square \lozenge \ap{x}{4}{4} \wedge \square \lozenge \ap{x}{5}{5} \nonumber \\
%%   %% & \wedge \lozenge \square\ap{x}{1}{6} \wedge \lozenge \square\ap{x}{2}{7} \wedge \lozenge \square\ap{x}{3}{8} \wedge \lozenge \square\ap{x}{4}{9} \wedge \lozenge \square\ap{x}{5}{10}
%%    \phi_2 = \bigwedge\nolimits_{j\in[4]} \square \lozenge( \ap{x}{j}{j} \wedge \ap{x}{j+1}{j} ) ,
%% \end{align*}

%% \normalsize
%% where $x = N/3$. We vary $N$ and compare our method to the method for cLTL+ problems in~\cite{sahin2019multirobot} in terms of runtime and cost measured by~\eqref{eq:cost} with $w=0.5$. This task cannot be categorized as a cLTL problem since here robots are heterogeneous. {Although translating LTL to NBA is worst-case exponential w.r.t. the length of the formula, in practice the translation is quick (0.03 and 0.10 seconds for case \RNum{1} and \RNum{2}, respectively). Both NBA $B$ and $\auto{relax}$ have 5 vertices and 14 edges (excluding self-loops). The size of $B$ is independent of the number of robots. There is one pair of initial and accepting vertices and  $\auto{subtask}^-$ has 5 vertices and 5 edges.} Since the method in~\cite{sahin2019multirobot} depends on the horizon $h$ of the plan, we vary $h$ between 5, 10, 15.\endnote{The SAT solver Z3 is used to solve the Integer Linear Programming since~\cite{sahin2019multirobot} addresses feasibility and all variables are binary.} The results  are shown in Table~\ref{tab:2} and are averaged over 10 trials for each $N$. Our method is two orders of magnitude faster than~\cite{sahin2019multirobot}. This is because it decomposes the problem so that first a sequence of waypoints is decided by solving a MILP and then a shortest path  between waypoints is computed. More importantly, our method outperforms~\cite{sahin2019multirobot} in terms of cost.  The feasibility-oriented formulation in~\cite{sahin2019multirobot} causes robots that are not assigned to any task to move aimlessly, while in our solution, such robots remain idle.

%% %% \begin{table}[t]
%% %%   \centering
%% %%   \caption{Comparative results w.r.t. the number of robots}\label{tab:2}
%% %%   \begin{tabular}{c|c|c|c|c}
%% %%    \toprule
%% %%    \multicolumn{2}{c|}{$N$} & 3 & 6 & 9 \\
%% %%    \midrule
%% %%    \multirow{4}{*}{\vtop{\hbox{\strut runtime}\hbox{\strut \;\,\,(sec)}}} & LTL-MRTA & {\bf 0.1}\bm{$\pm $}{\bf 0.0} & {\bf 0.9}\bm{$\pm$}{\bf 0.5} & {\bf 1.5}\bm{$\pm$}{\bf 0.7}\\
%% %%     & $h=5$ & 173.2$\pm$54.3 & 403.9$\pm$207.9 & 511.7$\pm$327.9\\
%% %%     & $h=10$ & 71.1$\pm$23.8 & 153.6$\pm$108.8  & 285.9$\pm$271.4\\
%% %%     & $h=15$ & 68.3$\pm$6.4 & 159.7$\pm$20.8 & 349.7$\pm$35.5\\
%% %%     \midrule
%% %%    [<0;26;15M]& LTL-MRTA &  {\bf 19.9}\bm{$\pm$}{\bf 4.4} & {\bf 32.7}\bm{$\pm$} {\bf 3.4} & {\bf 46.9}\bm{$\pm$}{\bf 5.8}\\
%% %%     & $h=5$  & 63.0$\pm$8.0 & 118.7$\pm$22.7  & 156.5$\pm$32.7\\
%% %%     &$h=10$ & 64.4$\pm$5.7 & 126.6$\pm$14.5 & 189.2$\pm$18.8\\
%% %%     & $h=15$ & 92.5$\pm$5.4 & 185.2$\pm$ 6.5 & 268.7$\pm$16.5\\
%% %%         \bottomrule
%% %%   \end{tabular}
%% %% \end{table}

%% \subsubsection{Case \RNum{2}} We consider tasks where some locations are visited sequentially by the same set of robots. For instance, these can be tasks where objects are  picked up by several robots and then delivered to another location.
%% Let $N=5$. The LTL formula  considered is

%% \small
%%
%% \begin{align*}
%%   \phi_3 = &  \square \lozenge (\pi^{\ell_1,0}_{3,1} \wedge \pi^{\ell_4, 0}_{4,4}) \wedge \lozenge ( \pi^{\ell_2,1}_{3,3} \wedge  (\pi^{\ell_2,1}_{3,3} \,\mathcal{U} \, \pi^{\ell_2,0}_{1,4})  \wedge \lozenge \pi_{4,3}^{\ell_3,0})   \nonumber \\ & \wedge \lozenge (\aap{2}{2}{\ell_7}{0} \wedge (\aap{3}{5}{\ell_8}{2} \vee \aap{3}{5}{\ell_{10}}{2}) \wedge \bigcirc  \lozenge  \aap{3}{5}{\ell_{9}}{2} ) \wedge \lozenge \square \aap{1}{2}{\ell_{10}}{0}
%% \end{align*}
%%
%% \normalsize
%% The NBA $B$ has 31 vertices and 182 edges. There is one pair of initial and accepting vertices. The sub-NBA $\auto{subtask}^-$ has 25 vertices and 48 edges. The MILP has 3760 variables and 4477 constraints. The runtime over 10 trials is 4.8$\pm$2.2$s$. {An animation can be found in~\cite{ltlmrta}.} We observe that the paths satisfy the task. The methods in~\cite{schillinger2018decomposition,schillinger2018simultaneous,faruq2018simultaneous} can not address such cooperative tasks and~\cite{sahin2017provably,sahin2017synchronous,sahin2019multi,sahin2019multirobot} can not capture tasks where the same set of robots needs to visit different locations.
\section{Conclusion}\label{sec:conclusion}
This paper  proposed an efficient and scalable hierarchical framework to address task allocation and motion planning problems for multi-robot system under  temporal logic specifications. We proved that, with mild assumptions, the proposed hierarchical framework is complete. Finally, we provided extensive simulations to demonstrate the efficacy of our proposed method and the simulation results showed that our method outperforms state-of-the-art  methods in terms of cost and scalability.

\bibliographystyle{SageH}
\bibliography{xl_bib}

\appendix
\section{Formulation of the MILP to Generate High-Level Plans}
We first formulate the MILP for the prefix part (see Section~\ref{sec:milp}) and then for the suffix part (see Section~\ref{sec:suf_milp}).
\subsection{MILP for the prefix part}\label{app:appendix_prefix_milp}
 To formulate the MILP, we define two types of variables: the routing variables $x_{uvr} \in\{0, 1\}$ and the scheduling variables $t^-_{vr}, t^+_{vr} \in \mathbb{N}$, where $x_{uvr}=1$  if robot  $r\in \ccalM^\ccalV_\ccalK(v)$ traverses the edge $(u,v) \in \ccalE_\ccalG$, and $t^-_{vr}, t^+_{vr}$ are times when robot $r$ should arrive at and is allowed to leave from vertex $v \in \mathcal{V}_\ccalG$. We assume that robot $r$ is still at vertex $v$ at departure time $t^+_{vr}$. Since the satisfaction of the edge label is instantaneous, if $v \in \ccalV_\ccalG$ is associated with an edge label, we have
  $t_{vr}^- = t_{vr}^+$, which means that the robot is allowed to leave at the next time instant. As for the vertex label, we have $t_{vr}^-  \leq t_{vr}^+$, which means that the robot should stay where it is to wait for the satisfaction of the corresponding edge label.

\subsubsection{Routing constraints:}\label{app:routing_constraints} These constraints work at the vertex level, which restrict the flow when the robots traverse between connected vertices in $\ccalV_\ccalG$. Specifically, $\forall\, v \in \ccalV_\ccalG\setminus\ccalV_{\text{init}}$, the constraint that  $v$ is visited by at most one robot belonging to type $\ccalM^\ccalV_{\ccalK}(v)$ can be encoded as
\begin{align}
   & \sum_{u:(u,v)\in \ccalE_\ccalG} \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} x_{uvr}  \leq 1, \;\forall\, r \in \ccalM^\ccalV_{\ccalK}(v), \label{eq:1}
\end{align}
which does not take the strict equality since the clause that vertex $v$ is associated with can be false, so there is no need to visit this vertex. Moreover, the flow constraint on a vertex, $\forall \,v \in \ccalV_\ccalG\setminus\ccalV_{\text{init}}$, that the inflow is no less than the outflow  can be encodes as
\begin{align}
& \sum_{w:(v,w)\in \ccalE_\ccalG} x_{vwr}   \leq  \sum_{u:(u,v)\in \ccalE_\ccalG} x_{uvr}, \;\forall\, r \in \ccalM^\ccalV_{\ccalK}(v), \label{eq:2}
\end{align}
which states that the robot can remain idle if it is not assigned a subtask. Then, $\forall \,v \in \ccalV_{\text{init}}$, the initial conditions of~\eqref{eq:2} are
\begin{subequations}\label{eq:2.5}
  \begin{align}
    & \sum_{w:(v,w)\in \ccalE_\ccalG} x_{vwr}  \leq 1, \;\text{if}\; r = r_v \in \ccalM^\ccalV_{\ccalK}(v), \label{eq:2.5a}\\
    & \sum_{w:(v,w)\in \ccalE_\ccalG} x_{vwr}  = 0, \;\forall r \in \ccalM^\ccalV_{\ccalK}(v)\setminus \{ r_v\}, \label{eq:2.5b}
  \end{align}
\end{subequations}
where $r_v$ refers to the specific robot at the initial location $\ccalM^\ccalV_{\ccalL}(v) = s^0$ if $v \in \ccalV_{\text{init}}$.
 \subsubsection{Scheduling constraints:}\label{app:scheduling_constraints} These constraints also work at the vertex level, capturing the temporal relation on a vertex or between the visit of two connected vertices. First, we require positivity of scheduling variables, $\forall \, v \in \ccalV_\ccalG$, i.e.,
\begin{align} \label{eq:3}
  0 \leq t_{vr}^{-}, t_{vr}^+ \leq M_{\text{max}} \sum_{u:(u,v)\in \ccalE_\ccalG} x_{uvr}& , \forall r\in \ccalM^\ccalV_{\ccalK}(v),
\end{align}
where $M_{\text{max}}$ is a large positive integer. The constraint~\eqref{eq:3} implies that $t_{vr}^- = t_{vr}^+ = 0$ if vertex $v$ is not visited by robot $r$. The initial condition of~\eqref{eq:3} is
\begin{align}\label{eq:3.5}
   t_{vr}^- = t_{vr}^+ = 0,  \quad   \;\forall r \in \ccalM^\ccalV_{\ccalK}(v), \;\forall\, v \in \ccalV_{\text{init}}.
\end{align}
The scheduling constraints between the visit of two connected vertices considering the traveling time, $\forall\, r\in \ccalM^\ccalV_{\ccalK}(v),\, \forall \,(u,v)\in \ccalE_\ccalG$, are
\begin{subequations}\label{eq:4}
  \begin{align}
    & \hspace{-0.6em} t_{ur}^+ +  T^*_{uv} x_{uvr} \leq  \,t_{vr}^- + M_{\text{max}} (1 - x_{uvr}), \nonumber \\
    &  \pushright{\text{if}\;  u\in \ccalV_{\text{init}}\; \text{or}\; u<_{P}v \; \text{or}\; (u,v)\in X_P,} \label{eq:4b} \\
    & \hspace{-0.6em}t_{ur}^+  + (T^*_{uv} + 1)  x_{uvr}  \leq t_{vr}^- + M_{\text{max}} (1 - x_{uvr}),  \nonumber \\
    & \pushright{\text{if}\; u\|_{P} v,} \label{eq:4a}
  \end{align}
\end{subequations}
where %% $M_{\text{min}}$ is a small positive integer,
$T^*_{uv}$ is the shortest traveling time between regions that vertices $u$ and $v$ correspond to, $u \in \ccalV_{\text{init}}$ means the starting vertex $u$ points to an initial location as in cases~\ref{sec:a},~\ref{edge:vertex1} and~\ref{edge:vertex3}, $u \|_{P} v$ and $u<_{P} v$ mean that the subtask $\ccalM^\ccalV_{{e}}(u)$ is incomparable to or smaller than $\ccalM^\ccalV_e(v)$, corresponding to  cases~\ref{sec:b} and~\ref{edge:vertex2} where $u$ is associated with prior subtasks, and $(u,v)\in X_P$ refers to case~\ref{sec:c} where $u$ is associated with the vertex label and $v$ is associated with the edge label of the same subtask. When $x_{uvr}=1$, constraint~\eqref{eq:4b} becomes $t_{ur}^+  + T^*_{uv}  \leq t_{vr}^-$ and constraint~\eqref{eq:4a} becomes $t_{ur}^+  + T^*_{uv} + 1   \leq t_{vr}^-$. Because $T^*_{uv} \geq 0$, constraints~\eqref{eq:4} ensure that $t_{vr}^-$ should be no less than $t_{ur}^+$ if $x_{uvr}=1$. Note that a cycle in $\ccalG$ must include a pair of incomparable vertices, since all comparable vertices constitute a chain. Constraint~{\eqref{eq:4a} avoids cycles in $\ccalG$ where all vertices correspond to the same region. E.g., consider such a cycle $u_1,u_2,\ldots, u_c, u_1$. Without  constraint~\eqref{eq:4a}, zero traveling time will be exploited by constraints~\eqref{eq:1},~\eqref{eq:2} and~\eqref{eq:4b}, generating a solution $x_{u_1 u_2 r} = ,\ldots,=x_{u_c u_{1} r}= 1$ for a robot $r$, without this robot actually visiting any vertex from its initial location.  Constraint~\eqref{eq:4a} is functionally similar to the subtour elimination constraint in vehicle routing problems which prevents any solution that consists of a disconnected tour. We leverage a  term 1 to ensure that time increases along the edge that connects incomparable vertices, thus preventing the traversing of a cycle.

  \subsubsection{Logical constraints:}\label{sec:labelconstraints} These constraints connect the vertex level with subtask level, which encode the logical relation between labels, clauses and literals, and the realization of literals.
                {Given a subtask $e\in X_P$, every vertex or edge label  $\gamma  = \bigvee_{p\in \ccalP} \bigwedge_{q\in \ccalQ_p} \ap{i^q}{j^q}{k^q,\chi^q}$ (neither $\top$ nor $\bot$) is true as long as one of its clauses is true.  To this end, we associate each clause  $\ccalC_{p}^{\gamma} \in \clause{\gamma}$ with a binary variable $b_p$ such that $b_p=1$ if the $p$-th clause  $\ccalC_{p}^{\gamma}$ is true. Hence, the label $\gamma$ being true can be encoded as
\begin{align}\label{eq:c}
   \sum_{p  \in \ccalP} b_p = 1.
\end{align}
That is, one and only one clause is true, which is justified by condition~\hyperref[asmp:a]{\it (a)} in  Assumption~\ref{asmp:same} that it is the same clause in a vertex label that is satisfied. The logical relation, between a clause and its literals, that the satisfaction of the clause is equivalent to the satisfaction of all its literals, is encoded as
\makeatletter\def\f@size{9}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}
 \!\!\!  \left. \left[ \sum_{q\in \ccalQ_p} \sum_{v \in \ccalM^\mathsf{lits}_{\ccalV}(e,0|1,p,q)} \sum_{u: (u,v) \in \ccalE_\ccalG} \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} x_{uvr} \right] \middle/ {\sum_{q\in \ccalQ_p} i^q} \right.= b_p, \label{eq:6}
\end{align}
which also bridges the routing variables $x_{uvr}$ with the logical variables $b_p$. In words, if $b_p=1$, then every vertex associated with the $p$-th clause should be visited by one robot.
{Let $$z_{q} = \sum_{v \in \ccalM^\mathsf{lits}_{\ccalV}(e,0|1,p,q)} \sum_{u: (u,v) \in \ccalE_\ccalG} \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} x_{uvr}$$ be the inner summation. If $b_p=1$, then all literals in $\mathsf{lits}^+(\ccalC_p^{\gamma})$ are true. In this case, for the $q$-th literal $\ap{i^q}{j^q}{k^q,\chi^q} \in \mathsf{lits}^+(\ccalC_p^\gamma)$, all $i^q$ vertices in ${\ccalM^\mathsf{lits}_{\ccalV}(e,0|1,p,q)}$ should be visited, so $\sum_{u: (u,v) \in \ccalE_\ccalG} \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} x_{uvr} = 1$ for each vertex $v \in {\ccalM^\mathsf{lits}_{\ccalV}(e,0|1,p,q)}$, and therefore $z_{q}= i^q$, and the left side of constraint~\eqref{eq:6} becomes
  \begin{align*}
   \left. \sum_{q\in \ccalQ_p} z_q \small/ {\sum_{q\in \ccalQ_p} i^q} = {\sum_{q\in \ccalQ_p} i^q} \small/{\sum_{q\in \ccalQ_p} i^q} \right. = 1 = b_p.
  \end{align*}
If $b_p=0$, all $x_{uvr}$ in constraint~\eqref{eq:6} equal 0, which implies that no vertices need to be visited for false clauses. Combining constraints~\eqref{eq:3} and~\eqref{eq:6}, $\sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t^-_{vr}$ equals 0 if the  clause that $v$ is associated with is false. That is, a robot remains idle if it is not responsible for the satisfaction of any clause. Furthermore, constraints~\eqref{eq:1} and~\eqref{eq:6} imply that, if visited, each vertex is visited by only one robot the whole time, which aligns with condition~\hyperref[asmp:a]{\it (a)} in Assumption~\ref{asmp:same} that the same fleet of robots satisfy the same clause.

    Note that the logical relation in constraint~\eqref{eq:6} only encodes that some vertices should be visited sometime to satisfy all literals, next we encode the synchronization constraint that, if $\gamma$ is an edge label and  the $p$-th clause $\ccalC_p^\gamma$ is true, all vertices in~$\ccalM^\mathsf{cls}_\ccalV(e, 1,p)$ should be visited at the same time since the satisfaction of edge labels is instantaneous.
      We define the pairwise vertex set induced from the clause $\ccalC_p^\gamma$ as  $\ccalV_{\gamma, p}^{\text{sync}} = \{(u,v)\,|\, u, v\in \ccalM^\mathsf{cls}_\ccalV(e,1,p), u\not= v \}$. If $b_p=1$, visiting any pair in $\ccalV_{\gamma, p}^{\text{sync}}$ simultaneously is encoded as
\begin{align}
  & \quad\quad  \sum_{r\in \ccalM^\ccalV_{\ccalK}(u)} t_{ur}^-  = \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^- , \quad\forall (u,v) \in \ccalV_{\gamma, p}^{\text{sync}}.\label{eq:7}
\end{align}
When $b_p=0$, constraint~\eqref{eq:7} also holds since both sides equal 0.




\subsubsection{Temporal constraints:}\label{sec:temporal} These constraints work at the subtask level in terms of temporal relations. Given the subtask $e$, there are three types of temporal constraints regarding the activation and completion time (see Definition~\ref{defn:time} below),  within the subtask or between subtasks.
\begin{defn}[(Activation and completion time of a subtask or its starting vertex label)]\label{defn:time}
Given a subtask $e = (v_1, v_2)$, we define the  activation time of a subtask (or of its starting  vertex label) as when its vertex label $\gamma(v_1)$ turns true, and the completion time  of a subtask (or of its starting vertex label) as when its edge label $\gamma(v_1, v_2)$ becomes true (or the last time its starting vertex label $\gamma(v_1)$ is true). The span of a subtask (or its starting vertex label) starts from the activation time and ends at the completion time.
\end{defn}
\paragraph{(i) Temporal constraints on one subtask:}\label{sec:onesubtask} These constraints capture the relation that the completion time of a subtask should lie in the span of its starting vertex label, or exactly one time instant later than the completion of its starting vertex label. Intuitively, the ``avoid'' part should be maintained until the ``reach'' part is realized.

For this, we define auxiliary variable  $t_e$ as the completion time of the subtask $e$, i.e., time when its edge label  becomes true. We have  that
\begin{align}\label{eq:edgetime}
  t_e = \sum_{p\in \ccalP} \sum_{r\in \ccalM^\ccalV_{\ccalK}(v_p)}t_{v_p r}^-,
\end{align}
where $v_p$ is randomly selected from $\ccalM^\mathsf{cls}_\ccalV(e,1,p)$ due to constraints~\eqref{eq:c} and~\eqref{eq:7} that only one clause is true and all associated vertices are visited at the same time.

When the starting vertex $v_1$ has a self-loop, and its label $\gamma(v_1)$ is not  $\top$ (otherwise, there are no associated vertices in $\ccalG$), the temporal relation, $\forall\, \ccalC_p^{\gamma} \in \clause{\gamma(v_1)}$ and $\forall v \in \ccalM^\mathsf{cls}_\ccalV(e,0,p)$, can be encoded as
  \begin{align}
 \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^-   \leq  t_e \leq
    \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^+ + 1  + M_{\text{max}} (1 - b_{p}). \label{eq:17}
  \end{align}
  If $b_p=0$, then no robot visits vertex $v$ according to constraint~\eqref{eq:6}, so~$ \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^- = 0 \leq t_e$, i.e., the left inequality holds. The right one holds obviously. Only when $b_p=1$, i.e., the $p$-th clause in the vertex label is true,  does constraint~\eqref{eq:17} come into effect. Note that constraint~\eqref{eq:17} implies that the span of the subtask is not necessarily equal to the span of its starting vertex label.

  On the other hand, when the starting vertex $v_1$ does not have a self-loop, we have that $v_1$ is identical to the initial vertex $v_0$. Recall that in Section~\ref{sec:prune}, we remove all vertices without self-loops except initial and accepting vertices. Hence, in $\auto{subtask}^-$, only $v_0$ and $\vertex{accept}$ are allowed not to have self-loops but $\vertex{accept}$ can not be the starting vertex; see also Fig.~\ref{fig:prefix}. Therefore, $v_1 = v_0$. If $\gamma(v_0) = \bot$,  constraint~\eqref{eq:17} becomes that the edge label of subtask $e$ should be satisfied at time instant 0 to initiate the progression, i.e.,
  \begin{align}
 t_e = 0, \quad \text{if}\; \gamma ({v_0}) = \bot. \label{eq:tis0}
  \end{align}



\paragraph{(ii) Temporal constraints on the completion of two sequential subtasks:}\label{sec:constraintonedge}
These constraints impose the precedence relation that subsequent subtasks should be completed after the completion of the prior subtasks.   Given the current subtask $e$, we consider its prior subtasks in the set $X^e_{\prec_{P}}$  rather than a larger set $X^e_{<_{P}}$. That is, we consider  subtasks that are covered by $e$  due to the transitivity of the partial order.
If $X^e_{\prec_{P}}$ is nonempty, we iterate over subtasks in it.  Given $e' \in X^e_{\prec_{P}}$, the fact that the subtask $e'$ is completed before the current subtask $e$ can be encoded as
\begin{align}\label{eq:12}
  t_{e'} +  1  \leq t_e, \; \forall \, e' \in X_{\prec P}^e,
\end{align}
where the term 1 excludes the case where two edge labels become true simultaneously, violating the precedence relation.

\paragraph{(iii)  Temporal constraints on  the  completion of the current subtask and the activation  of subsequent subtasks:}
These constraints capture the precede relation that the completion of the current subtask $e$ should be at most one time instant earlier than the activation of the subtask immediately after it. Otherwise, the sub-NBA induced from the poset $P$ will be trapped at $e$ if there is no activated subtask immediately after it. To capture this, we define $|X_P|\cdot |X_P -1|$ auxiliary binary variables $b_{ee'}$ for any two different subtasks  $e, e' \in X_P$,  such that $b_{ee'}=1$  if it is subtask $e'$ that occurs immediately after subtask $e$. Furthermore, we define  $S_3^e = X^e_{\succ_{P}} \cup X^e_{\|_{P}}$ that collects all subtasks whose activation can immediately follow the completion of subtask $e$.  In what follows, we proceed based on whether $ X^e_{\succ_{P}} \neq \emptyset$.
\refstepcounter{phase}
\subphase{$ X^e_{\succ_{P}} \neq \emptyset$}{In this case, there must exist a subtask that occurs after $e$. Then, the  constraint that there exists a subtask in $S_3^e$ that occurs immediately after $e$ can be encoded as}\label{activation:a}
\begin{align}\label{eq:bafter}
 \sum_{e'\in  S_3^e} b_{ee'} = 1.
\end{align}
If the subtask $e'$ indeed occurs immediately  after subtask $e$, then it should be completed after subtask $e$, that is,
\begin{align}\label{eq:after}
  t_e + 1 \leq  t_{e'} + M_{\text{max}} (1 - b_{ee'}),\; \forall\, e' \in S_3^e.
\end{align}
%% Note that $t_e$ can not be equivalent to $t_{e'}$, otherwise, when subtask $e$ is completed, it is still possible that no subtask is being or about to be activated  at the next time instant (subtask $e'$ has been completed).
To establish the transition between subtasks, the subtask $e'$ that occurs immediately  after subtask $e$ should be activated at most one time instant later than the completion of $e$. That is, $\forall\, e' = (v_1', v_2') \in S_3^e, \forall \, \ccalC_p^{\gamma(v'_1)} \in \clause{\gamma(v'_1)} , \forall \,v \in \ccalM^\mathsf{cls}_\ccalV(e',0,p)$, we have that
\begin{align}\label{eq:20}
  & \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^-   \leq t_{e}  + 1 + M_{\text{max}} (1 - b_{ee'}).
\end{align}
If $p$-th clause in the vertex label $\gamma(v_1')$ is true, constraint~\eqref{eq:20} requires that the associated vertices are visited at most one time instant later than the completion of $e$. Otherwise if $p$-th clause is false, the left side becomes 0, constraint~\eqref{eq:20} holds trivially. If $\gamma(v_1')=\top$, we view that subtask $e'$ is activated since the beginning. Thus, constraint~\eqref{eq:20} is satisfied trivially.

\subphase{$ X^e_{\succ_{P}} = \emptyset$}{In this case, if subtask $e$ is completed after  subtasks in  $X_{\|_P}^e$, then it is the last  subtask  to be completed in  $X_P$. Thus, there is no subtask to be activated any more. Otherwise, if subtask $e$ is not the last subtask, then there exists a subtask that occurs after $e$, same as case~\ref{activation:a}. To determine whether subtask $e$ is the last subtask, we define $|X_P|\cdot |X_P -1|$ auxiliary binary variables $b_{e}^{e'}$ for any two different subtasks  $e, e' \in X_P$,  such that $b_{e}^{e'}=1$  if and only if  $t_{e} > t_{e'}$, that is, if and only if subtask $e$ is completed after $e'$. This implication can be encoded as, $\forall\, e, e' \in X_P $ and $e\neq e'$,}\label{activation:b}
\begin{subequations}\label{eq:diff}
  \begin{align}
    b_e^{e'} + b_{e'}^e &  = 1, \label{eq:diff_a}\\
  M_{\text{max}} (b_{e}^{e'} - 1) \leq t_e -  t_{e'} & \leq M_{\text{max}} b_{e}^{e'} - 1. \label{eq:diff_b}
\end{align}
\end{subequations}
Constraints~\eqref{eq:diff} requires both that  no two subtasks are completed at the same time and that $b_e^{e'}=1$ if and only if $t_e > t_{e'}$. Assuming $t_e = t_{e'}$. According to constraint~\eqref{eq:diff_b}, we get that $b_e^{e'}=b_{e'}^{e}=1$, which violates constraint~\eqref{eq:diff_a}. Although independent subtasks can occur simultaneously, we break the tie so that the solution to the MILP formulation gives rise to a simple path in $\auto{subtask}^-$ that is a linear extension of the poset $P$. When $t_e > t_{e'}$, the right side implies $b_e^{e'}=1$; when $t_e < t_{e'}$, the left side implies $b_{e}^{e'}=0$.

%%  Then, that $b_e^{e'}$ implying $t_e > t_{e'}$  can be encoded as


 Furthermore, we define $z = |X^e_{\|_{P}}|$. Observe that, for $e' \in X^e_{\|_{P}} $, the term $z -  \sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'} = 0$ if $e$ is the last completed task, otherwise  positive. If subtask $e$ is not the last subtask, there should be a subtask in $X^e_{\|_{P}}$ that occur immediately after $e$, which can be encoded as
\begin{subequations}\label{eq:afterparallel}
  \begin{align}
  \sum_{e' \in X_{\|_P}^e} b_{ee'} & \le 1,\label{eq:afterparallel_a}\\
  z - \sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'} - M_{\text{max}}  \sum_{e' \in X_{\|_P}^e} b_{ee'} &  \leq 0, \label{eq:afterparallel_b} \\
 % \sum_{e' \in X_{\|_P}^e} b_{ee'} & \leq 1.
  %% M_{\text{max}} ( \sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'} -   z ) & \leq
  \sum_{e' \in X_{\|_P}^e} b_{ee'} - M_{\text{max}}(z -  \sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'}) & \leq0 . \label{eq:afterparallel_c}
\end{align}
\end{subequations}
If subtask $e$ is completed after  subtasks in  $X_{\|_P}^e$, then $z - \sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'} = 0$, we have $ \sum_{e' \in X_{\|_P}^e} b_{ee'}=0$ according to constraint~\eqref{eq:afterparallel_c}, i.e., there is no subtask required to follow $e$ immediately. Constraint~\eqref{eq:afterparallel_a} becomes $0\le 1$ and~\eqref{eq:afterparallel_b} becomes $0\le 0$. Both hold trivially.
Otherwise, if subtask is not the last subtask, i.e., $z - \sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'} > 0$, then we have $ \sum_{e' \in X_{\|_P}^e} b_{ee'}=1$ according to constraints~\eqref{eq:afterparallel_a} and~\eqref{eq:afterparallel_b}. Constraint~\eqref{eq:afterparallel_c} holds trivially. Finally, after determining the subtask $e'$ that occurs immediately follow $e$, we impose the same constraints as~\eqref{eq:after} and~\eqref{eq:20}.

Note that constraints~\eqref{eq:bafter}-\eqref{eq:afterparallel} in \ref{activation:a} and \ref{activation:b} ensures that, for a subtask except the last one in $X_P$, there exists another subtask that immediately follows it. However, it is possible that the subtasks that immediately follow two different subtasks are the same one, which cannot be excluded by constraint~\eqref{eq:bafter}. To avoid this, next we impose the constraint that, except the first subtask  to be completed in $X_P$, each subtask  can only immediately follow one subtask. Combined with constraints~\eqref{eq:bafter}-\eqref{eq:afterparallel}, we guarantee the one-to-one correspondence between any two consecutive subtasks in a linear extension. Recall that $S_2^e = X^e_{\prec_{P}} \cup X^e_{\|_{P}}$. We proceed based on whether $X^e_{\prec_{P}} = \emptyset$ or not.
\refstepcounter{phase}
\subphase{$X^e_{\prec_{P}} \neq \emptyset$}{In this case,  subtask $e$ can not be the first subtask to be completed, that is, it has to immediately follow one subtask in $S_2^e$:}
  \begin{align}\label{eq:follow1}
 \sum_{e' \in S_2^e} b_{e'e} = 1.
\end{align}
 \subphase{$X^e_{\prec_{P}}= \emptyset$}{In this case, $X^e_{<_{P}} = \emptyset$,  so there is no subtask prior to $e$. Recall that the binary variable $b_e^{e'}=1$ if subtask $e$ is completed after $e'$ and no two subtasks are completed at the same time. Therefore, $b_e^{e'}=0$ if $e$ is completed prior to $e'$, and further  the term $\sum_{e' \in X_{\|_P}^e } {b}_{e}^{e'}=0$ if $e$ is the first completed task, otherwise  positive. Then, the constraint that each subtask in $X_{\|_P}^e$, except the first one,  immediately follows another subtask can be encodes as}
\begin{subequations}\label{eq:follow}
  \begin{align}
  \sum_{e' \in X_{\|_P}^e} b_{e'e} & \le 1,\label{eq:follow_a}\\
 \sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'} - M_{\text{max}}  \sum_{e' \in X_{\|_P}^e} b_{e'e} &  \leq 0, \label{eq:follow_b} \\
 % \sum_{e' \in X_{\|_P}^e} b_{ee'} & \leq 1.
  %% M_{\text{max}} ( \sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'} -   z ) & \leq
  \sum_{e' \in X_{\|_P}^e} b_{e'e} - M_{\text{max}} \sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'} & \leq0 . \label{eq:follow_c}
\end{align}
\end{subequations}
When $e$ is the first subtask, i.e., $\sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'}=0$, then $\sum_{e' \in X_{\|_P}^e} b_{e'e} = 0$ according to constraints~\eqref{eq:follow_b} and~\eqref{eq:follow_c}. Otherwise, if $e$ is not the first subtask, i.e., $\sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'} > 0$, then $\sum_{e' \in X_{\|_P}^e} b_{e'e} = 1$ according to constraints~\eqref{eq:follow_a} and~\eqref{eq:follow_b}; same as~\eqref{eq:follow1}.


\paragraph{(iv) Temporal constraints on the activation of the first subtask:}
We analyzed the temporal constraints on the completion of the current subtask and the activation of subsequent subtasks above. However, if the subtask $e$ is the first subtask to be completed, there is no subtask whose completion activates $e$, which should be activated at the beginning. To determine the first subtask in $X_P$,  let $P_{\text{max}}$ be the set that collects subtasks that can be the first one to be completed, which are referred to as the maximal element in a poset $P$. An element in a poset $P$ is a maximal element if there is no element in $P$ larger than it. That is, for  any subtask  $e \in P_{\text{max}}$, we have $X_{\prec_P}^e = \emptyset$. If the first completed subtask $e = (v_1 ,v_2)$ has a self-loop and the vertex label is not $\top$ (it is activated since the beginning if $\gamma(v_1)=\top$), we require that the vertex label $\gamma(v_1)$ should be activated at time 0, which implies that the associated vertices in $\ccalG$ should be visited at 0,   i.e., $\forall\, e \in P_{\text{max}}, \forall\, \ccalC_p^{\gamma(v_1)} \in \clause{\gamma(v_1)}, \forall \,v \in \ccalM^\mathsf{cls}_\ccalV(e,0,p)$,
\begin{align}\label{eq:zeroactivation}
  & \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^-  \leq M_{\text{max}} (\sum_{e' \in P_{\text{max}}\setminus \{e\}  } {b}_{e}^{e'} + 1- b_p).
\end{align}
Only when $e$ is the first subtask to be completed, i.e, $\sum_{e' \in P_{\text{max}}\setminus \{e\}  } {b}_{e}^{e'}=0$ and the associated clause is true, i.e., $b_p=1$, should the vertices be visited by robots at time 0, i.e., $\sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^-  \leq 0$. When $|P_{\text{max}}|=1$, constraint~\eqref{eq:zeroactivation} will be reduced to  $ \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^-  \leq M_{\text{max}} (1- b_p).$ Note that if the vertex label $\gamma(v_1)$ has no self-loop, then $v_1$ is identical to $v_0$. We have discussed  this case in constraint~\eqref{eq:tis0}.


Recall that in cases ~\ref{edge:vertex2} and~\ref{edge:vertex3}  when constructing the edges for vertex labels of subtasks in $P_{\text{max}}$ (a subtask $e$ is in $P_{\text{max}}$ if $X_{\prec_P}^e=\emptyset$), their leaving vertices fall into two categories, one category from initial vertices and the other from immediately prior subtasks. To meet condition~\hyperref[asmp:b]{\it (b)}  in Assumption~\ref{asmp:same} that the satisfied clause in the edge label implies the satisfied clause in the end vertex label and the same fleet of robots satisfy these two clauses, we require that, the starting vertex label of the first completed  subtask in $P_{\text{max}}$ should be satisfied by robots coming from the initial vertices $\ccalV_{\text{init}}$ in $\ccalG$, and the starting vertex label of the remaining subtasks in $P_{\text{max}}$ should be satisfied by robots coming from vertices in $\ccalG$ that are associated with edge labels of immediately prior subtasks. To this end, we first define an auxiliary binary variable $b_{e}^{\prec}$ such that $b_{e}^{\prec}= 1$ if subtask $e$ is the first subtask in $P_{\text{max}}$, that is,
\begin{subequations}
  \begin{align}
   \sum_{e' \in P_{\text{max}}\setminus \{e\}} {b}_e^{e'}  - M_{\text{max}} (1 - b_{e}^{\prec}) & \leq 0\\
    1 - b_{e}^{\prec} -  M_{\text{max}}  \sum_{e' \in P_{\text{max}}\setminus \{e\}} {b}_e^{e'}    & \leq 0
  \end{align}
\end{subequations}
When $e$ is the first subtask, i.e., $ \sum_{e' \in P_{\text{max}}\setminus \{e\}} {b}_e^{e'}=0$, we have that $b_e^{\prec}=1$. Then, for any clause in the starting vertex label of $e$, the constraints regarding the categories of leaving vertices can be encoded as, $\forall \, \ccalC_p^\gamma \in \clause{\gamma} $,
\begin{subequations}\label{eq:routingforactivation}
  \begin{align}
   & \sum_{q\in \ccalQ_p} \sum_{v \in \ccalM^\mathsf{lits}_{\ccalV}(e,0,p,q)} \sum_{\substack{u: (u,v) \in \ccalE_\ccalG \\ u \not\in \ccalV_{\text{init}}}}   \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} x_{uvr} \leq M_{\text{max}} (1 - b_e^{\prec}),  \label{eq:routingforactivation_a}\\
   & \sum_{q\in \ccalQ_p} \sum_{v \in \ccalM^\mathsf{lits}_{\ccalV}(e,0,p,q)} \sum_{\substack{u: (u,v) \in \ccalE_\ccalG \\ u \in \ccalV_{\text{init}}}}   \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} x_{uvr} \leq M_{\text{max}}  b_e^{\prec}.  \label{eq:routingforactivation_b}
  \end{align}
\end{subequations}
where $u \in \ccalV_{\text{init}}$ means that vertex $u$ falls into the category of $\ccalV_{\text{init}}$ in $\ccalG$. When subtask $e$ is the first one to be completed in $P_{\text{max}}$, i.e., $b_e^{\prec}=1$, constraint~\eqref{eq:routingforactivation_a}, combining with constraint~\eqref{eq:6}, says that robots should come from vertices in~$\ccalV_{\text{init}}$. However, when subtask $e$ is not  the first subtask to be completed in $P_{\text{max}}$, i.e., $b_e^\prec=0$, constraint~\eqref{eq:routingforactivation_b} requires that robots should come from vertices associated with immediately prior subtasks.


\subsubsection{Same-$\ag{i}{j}$ constraints:}\label{sec:samegroup}
We encode the constraints that some subtasks are executed by the same $i$ robots of type $j$, which are indicated by the same nonzero connector $\chi$. Given a nonzero connector $\chi$, we can locate all labels, vertex or edge labels, that have literals with the same connector $\chi$  by the mapping function $\ccalM_\mathsf{\gamma}^\chi(\chi)$. In an edge label $(e, 1)  \in  \ccalM_\mathsf{\gamma}^\chi(\chi)$ or a vertex label $(e, 0)  \in  \ccalM_\mathsf{\gamma}^\chi(\chi)$, each clause has at most one literal $\aap{i}{j}{k}{\chi}$ with connector $\chi$ and it is associated with $i$ vertices in $\ccalG$. We enumerate these $i$ vertices and denote the $b$-th vertex by $v_k^b$. Then for any two labels $\gamma, \gamma'\in\ccalM_\mathsf{\gamma}^a(\chi)$ and any two clauses $\ccalC_p^\gamma \in \clause{\gamma}$ and $\ccalC_{p'}^{\gamma'} \in \clause{{\gamma'}}$ that have  literals $\aap{i}{j}{k}{\chi}$ and $\aap{i}{j}{k'}{\chi}$, respectively, {the constraint} that the corresponding literals are satisfied by the same $i$ robots of type $j$, $\forall \,b \in [i]$ and  $\forall \, r \in \ccalK_j$, can be encoded as
\begingroup
\allowdisplaybreaks
\begin{subequations}\label{eq:same}
  \begin{align}
    & \sum_{u:(u, v_k^b) \in \ccalE_\ccalG} x_{u v_k^b r} + M_{\text{max}} (b_p - 1) \nonumber \\& \quad\quad\quad \leq  \sum_{u:(u, v_{k'}^b) \in \ccalE_\ccalG} x_{u v_{k'}^b r} + M_{\text{max}}(1 - b_{p'}),\\
    & \sum_{u:(u, v_{k'}^b) \in \ccalE_\ccalG} x_{u v_{k'}^b r} + M_{\text{max}} (b_{p'} - 1) \nonumber \\& \quad\quad\quad \leq \sum_{u:(u, v_{k}^b) \in \ccalE_\ccalG} x_{u v_{k}^b r} + M_{\text{max}}(1 - b_{p}),
  \end{align}
\end{subequations}
\endgroup
where $v_{k'}^b$ is the $b$-th vertex associated with $\aap{i}{j}{k'}{\chi}$. Only when $b_p = b_{p'}=1$, does~\eqref{eq:same} come into effect. Then, $\sum\nolimits_{u:(u, v_k^b) \in \ccalE_\ccalG} x_{u v_k^b r} = \sum\nolimits_{u:(u, v_{k'}^b) \in \ccalE_\ccalG} x_{u v_{k'}^b r} $, i.e., two $b$-th vertices $v_k^b$ and $v_{k'}^b$ are visited by the same robot $r$.

\subsubsection{Constraints on the transition between the prefix and suffix parts:}\label{sec:transition} Since we deal with prefix and suffix parts separately, to ensure that the final locations of the prefix part seamlessly transition to the suffix part, we impose constraints to gain control over  the final locations of the prefix part, which is determined by the satisfied clause in the edge label of the  subtask that is the last one to be completed.

To this end,  we first find the set of subtasks, denoted by $P_{\text{min}}$, in the poset $P$ that can be the last one to be completed, which are referred to as the minimal elements in a poset. An element in a poset $P$  is a minimal element if there is no element in $P$ smaller than it. Then, we loop over subtasks in $P_{\text{min}}$ when formulating the MILP, and set a specific subtask $e\in P_{\text{min}}$ to be the last one, which can be encoded as
\begin{align}\label{eq:lastsubtask0}
  b_e^{e'} = 1, \;  \forall\, e' \in X_P \setminus\{e\}.
\end{align}
After selecting the last subtask to be completed, we next select one clause in its edge label $\gamma$ that needs to be satisfied. We loop over all clauses in the edge label of the last subtask, and set a specific clause $\ccalC_p^\gamma \in \clause{\gamma}$ to be true, i.e.,
\begin{align}\label{eq:lastclause}
  b_p = 1.
\end{align}
If a path for Problem~\ref{prob:1} can not be detected when  $e$ is the last subtask in the prefix part  and its $p$-th clause is set to be true,  we continue the loop over clauses in the edge label of $e$. If a path for Problem~\ref{prob:1} can not be detected after finishing the loop over clauses in the selected edge label, we set another subtask in $P_{\text{min}}$ to be the last one and repeat the same process. By putting constraints on the final locations of the prefix part, we can identify the same clause satisfied by the final locations of the prefix part as that satisfied by the assumed feasible paths, which ensures the feasibility of  the suffix part and the completeness of our method; see also Theorem~\ref{thm:completeness}.

\begin{rem}
  The constraints~\eqref{eq:lastsubtask0}-\eqref{eq:lastclause} on the transition between the prefix and suffix parts are necessary for establishing the completeness of our proposed method, which ensures that another feasible path can be generated by slightly modifying the assumed feasible path $\tau$ in the problem formulation (see Appendix~\ref{app:completeness_} for the proof of the completeness). However, there may exist numerous solutions to Problem~\ref{exmp:1}, and it will be computationally inefficient to try all possibilities of the last subtasks and the corresponding clauses.  Therefore, to reduce the computational burden, these constraints may not be necessary when implementing the MILP.  We found that in the simulations in Section~\ref{sec:sim}, omitting constraints~\eqref{eq:lastsubtask0}-\eqref{eq:lastclause}  did not make problems infeasible.
\end{rem}


\subsubsection{MILP objective} The objective is to minimize the weighted sum of traveling cost and traveling time, i.e.,
\begin{align}\label{equ:obj}
  \min \; \;&  \alpha \sum_{(u,v)\in \ccalE_\ccalG}  \sum_{r \in \ccalM^\ccalV_{\ccalK}(v)} d_{uv} x_{uvr} +  (1 - \alpha) \sum_{e\in X_P} t_e,
\end{align}
  where $\alpha$ is a user-specified parameter and  $d_{uv}$ is the traveling cost, e.g., traveling distance.
  \begin{rem}
   Compared to Problem~\ref{prob:1}, the objective~\eqref{equ:obj} involves the optimization of time. In the simulations in Section~\ref{sec:sim}, we observed that without optimizing the time, some scheduling variables can take large values, which impacts the plan execution; see Section~\ref{sec:path}. Note that traveling cost, e.g., traveling distance, and traveling time are typically non-conflicting objectives.
  \end{rem}
  \begin{rem}
    One advantage of the above MILP formulation is that we tackle each subtask directly,  which permits us to impose more constraints on certain subtasks to cater to stricter needs, such as prevent certain robots from engaging in a subtask. We will detail these extensions in Appendix~\ref{sec:extension_milp}.
  \end{rem}
                }}

\subsection{MILP for the suffix part}\label{app:appendix_suffix_milp}
The MILP formulation for the suffix part creates the same  constraints as~\eqref{eq:1}-\eqref{eq:same} in Appendix~\ref{app:appendix_prefix_milp} with two exceptions:
\refstepcounter{phase}
\subphase{Returning to respective regions}{The first exception results from the requirement that, while driving transition back to $v_{\text{accept}}$, robots need to return to  regions corresponding to their initial locations. To this end, we define binary variables $b_e$ for each subtask in $P_{\text{min}}$ that can be the last one to be completed, such that $b_e$ equaling 1 implies the satisfaction of the augmented clause $\ccalC_{\text{prior}}^+$ (see Fig.~\ref{fig:suffix}). First, we require that one  and only one $b_e$ can be true, i.e.,}
\begin{align}\label{eq:one_suffix}
  \sum_{e \in P_{\text{min}}} b_e = 1.
\end{align}
If $b_e=0$ for a subtask $e$ in $P_{\text{min}}$, then one of the remaining clauses in the edge label of $e$ must be satisfied according to constraint $\eqref{eq:c}$, which is reduced to the regular case as if  $\ccalC_{\text{prior}}^+$  did not exist.

Next, we encode the constraint that it is when completing the last subtask in $P_{\text{min}}$ that robots return to their respective regions. Recall that in Appendix~\ref{app:appendix_prefix_milp} we define binary variables $b_{e}^{e'}=1$ which is 1 if subtask $e$ is completed after  $e'$, i.e., $t_e >  t_{e'}$. To determine this last satisfied subtask in $P_{\text{min}}$,
%% we define $|P_{\text{min}}|^2$ binary variables $b_{e}^{e'}, \forall e, e' \in P_{\text{min}}$,  such that $b_{e}^{e'}=1$  iff $t_e \geq t_{e'}$, that is, iff $e$ is satisfied no earlier than  $e'$. This implication can be encoded as}
%% \makeatletter\def\f@size{10}\check@mathfonts
%% \def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
%% \begin{align}
%%   M_{\text{max}} (b_{e}^{e'} - 1) \leq t_e -  t_{e'} \leq M_{\text{max}} b_{e}^{e'} - M_{\text{min}},
%% \end{align}
%%
%%  where $M_{\text{min}}$ is a small positive number and it is used to enforce $b_{e}^{e'}=1$ if $t_e = t_{e'}$.
  we define $z = |P_{\text{min}}| -1$. Then, for any $e \in P_{\text{min}}$, the term $\sum_{e' \in  P_{\text{min}}\setminus \{e \} } b_{e}^{e'} - z  = 0$ if $e$ is the last subtask to be completed. Thus, some robots returning to their respective regions to complete the last subtask  can be encoded as
\begin{align}\label{eq:lastsubtask}
  1 + M_{\text{max}} ( &  \sum_{e' \in  P_{\text{min}}\setminus \{e \} } b_{e}^{e'} - z)  \leq  b_e \nonumber \\
  & \leq 1 + M_{\text{max}} (z - \sum_{e' \in  P_{\text{min}}\setminus \{e \} } b_{e}^{e'}),
\end{align}
for any subtask $e \in P_{\text{min}}$. Only when $e$ is the last subtask in $P_{\text{min}}$ to be completed, does $b_e = 1$ come into effect.


Given a subtask $e = (v_1, v_2) \in P_{\text{min}}$, similar to constraint~\eqref{eq:6}, the following constraint states that when $b_e=1$, i.e., subtask $e$ is indeed the last one to be completed,  each vertex in $\ccalG$  associated with clause $\ccalC_{\text{prior}}^+$ of $\gamma(v_1, v_2)$ will be visited by a specific robot, for the $q$-th literal $\ap{i^q}{j^q}{k^q,\chi^q}$ in $\ccalC_{\text{prior}}^+$,
\begin{align}\label{eq:return_suffix}
  \left.   \left[ \sum_{v \in \ccalM_\ccalV^\mathsf{lits}(e, 1, p_e, q)}   \sum_{u: (u,v) \in \ccalE_\ccalG}     \sum_{r_v = \ccalM_{\ccalK}^\ccalV(v) }   x_{uvr} \right] \middle/ {i^q} \right. = b_e,
 \end{align}
where $p_e$ is the index of the clause $\ccalC_{\text{prior}}^+$ in $\gamma(v_1, v_2)$ and robot $r_v$ is the specific robot that should visit vertex $v$.


\subphase{same-$\ag{i}{j}$ constraints}{The second exception is the same-$\ag{i}{j}$ constraints in Appendix~\ref{sec:samegroup}, because we need to maintain the same  $i$ robots of type $j$ visiting some regions sequentially as those in the prefix plan. Specifically, after solving the MILP for the prefix part, for any connector $\chi\not=0$ that appears in the specification $\phi$, we check whether any literal that includes this connector was involved in the prefix part. If yes, then these literals with the same nonzero connector should be satisfied by the same $\ag{i}{j}$. We denote by $\ccalK^\chi \subseteq \ccalK_j$ the set of $\ag{i}{j}$ that make these literals true and  by  $r^b$ the $b$-th robot in the enumerated set $\ccalK^\chi$. When dealing with the suffix part, for any label $\gamma \in\ccalM_\mathsf{\gamma}^\chi(\chi)$ where literals with connector $\chi$ appear and any clause $\ccalC_p^\gamma \in \clause{\gamma}$ that has  literal $\aap{i}{j}{k}{\chi}$, the constraint that this literal is satisfied by the same $\ag{i}{j}$  can be encoded as}
\begin{align}\label{eq:same_suffix}
    \sum_{u:(u, v_k^b) \in \ccalE_\ccalG} x_{u v_k^b r^b} =  b_p, \;\forall\, r^b \in \ccalK^\chi,
\end{align}
where $v_k^b$ is the $b$-th vertex in the set of vertices in the routing graph $\ccalG$  that are associated with literal $\ap{i}{j}{k,\chi}$. If the clause $\ccalC_p^\gamma$ is true, i.e.,  $b_p=1$, the $b$-th vertex $v_k^b$ is visited by the $b$-th robot $r^b \in \ccalK^\chi$. On the other hand, if $\ccalK^\chi = \emptyset$, that is, literals that share this $\chi$ do not appear in the prefix part, we turn to constraint~\eqref{eq:same} to impose the same-$\ag{i}{j}$ constraints.

By condition \hyperref[cond:f]{\it (f)} regarding implication in Definition~\ref{defn:run}, there is a clause  $\ccalC'$ in the edge label $\gamma(\vertex{prior}', \vertex{accept})$ that is a subformula of $\ccalC_{\text{prior}}$. Therefore, some robots returning to regions corresponding to their initial locations  will enable the positive subformul in $\ccalC'$ of $\gamma(\vertex{prior}', \vertex{accept})$ and, at the same time maintain that any positive literal in the clause $\ccalC'$ with nonzero connector uses the same group of robots as the literal in the clause $\ccalC_{\text{prior}}^+$ of $\gamma(\vertex{prior}', \vertex{accept})$ that share  the same connector.  In other words, when robots head back towards their initial locations, the same-$\ag{i}{j}$ constraints over the last completed subtask are satisfied automatically. Robots can safely return to their initial locations at last without worrying about violating the same-$\ag{i}{j}$ constraints.

%% The solution to this MILP returns high-level plans that induce a run in $\auto{subtask}^-$ that starts from and ends at the accepting vertex $\vertex{accept}$. Then, we can get the low-level executable paths by following the method in~Section~\ref{sec:solution2mrta} that drive the transitions to vertex label of $v_{\text{next}}$. The last step is to design paths that satisfy  the vertex label of $v_{\text{next}}$ so that robots go back  to their initial locations from the final locations of these paths returned by Section~\ref{sec:solution2mrta} and meanwhile do not violated the specification. In this way, robots' path constitute a cycle.

  \section{Design of Low-Level Paths that Satisfy the Original LTL Task}\label{sec:solution2mrta}
  This section presents the correction stage  that concretizes the high-level plan obtained in Section~\ref{sec:path} to satisfy the specification $\phi$; see also blocks \circled{6} and \circled{7} in Fig.~\ref{fig:overview}.
  We first extract a simple path from the NBA $\auto{subtask}^-$ that connects $v_0$ and $\vertex{accept}$, based on the time axis and the high-level plan, and then find the counterpart of this simple path from the NBA $\autop$. To satisfy the specification $\phi$, while following along the high-level plan, we formulate a sequence of generalized multi-robot path planning (GMRPP) problems  to design low-level executable paths. The feasibility of the formulated GMRPP is shown in Lemma~\ref{prop:valid}.

\subsection{Extraction of the simple path from the sub-NBA \upshape $\auto{subtask}^-$}\label{sec:run}
  %% Note that we operate on $\auto{subtask}^-$ other than the pruned NBA  $\auto{subtask}^-$. This is because independent elementary subtasks can occur simultaneously, which together consistitute a composite subtask whose associated edge  appears in the NBA $\auto{subtask}^-$ but not in~$\auto{subtask}^-$.

Recall that each distinct time instant in the time axis $\vec{t}$ obtained in Section~\ref{sec:path} has a one-to-one correspondence with subtasks in the set $X_P$, and the sorted time axis generates a linear extension of subtasks in $X_P$ that induces a simple path in $\auto{subtask}^-$ that connects $v_{0}$ and $\vertex{accept}$. In this section, we proceed along the time axis $\vec{t}$ to extract this simple path using a backtracking search algorithm. The outline of this algorithm is shown in Alg.~\ref{alg:extract}.

  To this end, we define $c\in \mathbb{N}$ as the {\it global counter} which keeps track of the progress made along the time axis $\vec{t}$. Specifically, $c$ is the index of the subtask that has  been completed most recently. Therefore, $\vec{t}(c+1)$ is  the  completion time of the  subtask, denoted by $e' = (v'_1, v_2')$, that is  the next one to be completed. Let $v_1$ denote the vertex in $\auto{subtask}^-$ that is the  most recently reached.  We start from the initial vertex $v_1= v_0$ with global counter $c=0$ [line~\ref{run:initialization}, Alg.~\ref{alg:extract}]. At each iteration, among all subtasks from the vertex $v_1$, we find the one $(v_1, v_2)$ that is  equivalent to subtask $e'$ [line~\ref{run:edgelabel}, Alg~\ref{alg:extract}]. Then, after time instant $\vec{t}(c+1)$,  vertex $v_2$ becomes the most recently reached vertex. We next increase the global counter by 1 and add it to a stack, i.e., a last-in-first-out container [line~\ref{run:put}, Alg.~\ref{alg:extract}]. The iteration will terminate when the accepting vertex $\vertex{accept}$ is reached.


 \begin{algorithm}[t]
      \caption{Extract the  simple path  from $\auto{subtask}^-$ }
      \LinesNumbered
      \label{alg:extract}
      \KwIn {time axis $\vec{t}$, sub-NBA $\auto{subtask}^-$}
      \Comment*[r]{Backtracking search}
      $v_1 = v_0, c = 0,  \text{stack} = \emptyset $ \Comment*[r]{Initialization}\label{run:initialization}
      \While{\upshape $v_1 \neq \vertex{accept}$}{
        Obtain the subtask $e'=(v'_1, v_2')$ that is associated with $\vec{t}(c+1)$\;
        \For{\upshape $(v_1, v_2) \in \auto{subtask}^-$}{
          \If{\upshape   $ \gamma(v_1, v_2) = \gamma(v'_1, v'_2)$ {\bf and} $\gamma(v_1) = \gamma(v'_1)$ \label{run:edgelabel}}{
            Determine {\it (I$_1$)} essential clause, {\it (I$_2$)} essential robots, {\it (I$_3$)} negative clause, and {\it (I$_4$)}  sequence of vertices leading to  $v_2$\label{run:info}\;
            $\text{stack.put}(v_2, c+1)$\label{run:put}\;

          }
        }
        $(v_1, c) = \text{stack.pop}()$\;
      }
      {\bf return} the simple path leading to $v_1$\;

 \end{algorithm}
\refstepcounter{phase}
 When a subtask $(v_1, v_2)$ in~$\auto{subtask}^-$ is matched with the subtask $e'$ that is completed at $\vec{t}(c+1)$, we keep track of information regarding \ref{essential:clause} the exact clauses that are\ satisfied in the vertex label $\gamma(v_1)$  and edge label $\gamma(v_1, v_2)$ since only one clause in each label is true by constraint~\eqref{eq:c} in the MILP,  \ref{essential:robots} the subset of robots that participate in satisfying each literal in these clauses,
 \ref{essential:negative} the negative subformula in $\autop$ that is in conjunction  with the satisfied clause found in \ref{essential:clause} but is replaced with $\top$ during the relaxation stage in Section~\ref{sec:prune}, and  {(\Alph{phase}$_4$)} the sequence of vertices in $\auto{subtask}^-$ that have been visited up to vertex $v_2$. These information will be used to formulate the generalized multi-robot path planning problems when planning the low-level paths in Appendix~\ref{sec:mapp}. In what follows, we discuss \ref{essential:clause}-\ref{essential:negative} in further detail.
 \subphase{Essential clauses}{Given the edge label or vertex label $\gamma=\bigvee_{p\in \ccalP} \bigwedge_{q\in \ccalQ_p} \ap{i}{j}{k,\chi}$ of subtask $(v_1, v_2)$ that is neither $\top$ nor $\bot$, we refer to the unique satisfied clause as the {\it essential clause} and denote it by $\gamma^+$. In the formulated MILP, we define a binary variable $b_p$ representing the truth of the $p$-th clause in a given label (see constraint~\eqref{eq:c}). Thus, we find the essential clause by locating the clause $\ccalC_{p}^{\gamma} \in \clause{\gamma}$ such that $b_p=1$. On the other hand, when the vertex or edge label is $\top$, by default, we define the essential clause as $\top$.}\label{essential:clause}
 \subphase{Essential robots}{We refer to the set of robots whose collective behavior satisfies the positive literals in the essential clause as the {\it essential robots}. For $q$-th literal $\ap{i}{j}{k,\chi}$ in the essential clause $\ccalC_p^\gamma$ of a vertex or edge label of subtask $(v_1, v_2)$, we determine its essential robots by locating the binary variable $x_{uvr}$ whose value is 1, representing one robot visiting a vertex in the routing graph $\ccalG$ associated with this literal (see Section~\ref{app:appendix_prefix_milp}). That is, for each associated vertex $v\in \ccalM_{\ccalV}^\mathsf{lits} (e, 0|1, p, q)$, find the robot $r\in \ccalM_\ccalK^\ccalV(v)$ such that $\exists\, (u,v)\in\ccalE_\ccalG$, making $x_{uvr}=1$.  On the other hand, if the essential clause is $\top$, there is no essential robots.}\label{essential:robots}
\subphase{Negative clause}{The collective behavior of essential robots satisfies the essential clauses in $\auto{subtask}^-$. For an essential clause that is not $\top$, there exists a unique clause in the NBA $\autop$ that only differs from the essential clause in that it may contain the conjunction of the negative literals that were removed during the relaxation stage. We refer to this conjunction of negative literals as the {\it negative clause} and denote it by $\gamma^-$, which will be respected when designing the low-level paths in Appendix~\ref{sec:mapp}. By default, we define the negative clause as $\top$, if the corresponding clause in $\autop$ does not have negative literals. Finally, the conjunction $\gamma^+ \wedge \gamma^-$ of an essential clause and its corresponding negative clause constitutes a {\it complete clause} in~$\autop$.}\label{essential:negative}

 When the vertex label $\gamma(v_1)$ or edge label $\gamma(v_1, v_2)$ of subtask $(v_1, v_2)$ in $\auto{subtask}^-$ is $\top$, the associated essential clause is also $\top$. However, the negative clause may not be $\top$, which happens when there exists a  clause in the corresponding label in $\autop$ that only includes negative literals.   Note that by condition~\hyperref[asmp:b]{\it (b)} in Assumption~\ref{asmp:same}, the complete clause of the vertex $v_1$ is implied by the complete clause of the edge that is immediately preceding the current subtask $(v_1, v_2)$. If the label is the edge label $\gamma(v_1, v_2)$, we randomly select one among clauses that only include negative literals. Otherwise,  if the label is the vertex label $\gamma(v_1)$, and further if the current subtask is not the first one, we select one as the negative clause (acting as the complete clause), that is  implied by the complete clause in the edge that is immediately preceding the current subtask $(v_1, v_2)$. We can obtain this edge since in step (H$_4$) we keep track of the sequence of vertices that lead to vertex $v_2$. This ensures that when the edge label $(v_1, v_2)$ is enabled due to the satisfaction of its complete clause, the complete clause in its end  vertex label can be satisfied automatically.   On the other hand, if the current subtask is indeed the first one, we randomly select a negative  clause that is satisfied by the initial robot locations. }}


 {\subsection{Generalized multi-robot path planning}\label{sec:mapp}
Leveraging the correspondence between the NBA  $\autop$ and the sub-NBA $\auto{subtask}^-$,  we can find the counterpart in $\autop$ of the simple path in $\auto{subtask}^-$ obtained in Appendix~\ref{sec:run}. We denote by $\theta_{\phi}$ this counterpart, which corresponds to a sequence of temporally sequential subtasks. Our goal is to find a collection of executable paths  that induce the simple path $\theta_{\phi}$ in $\autop$; see also block \circled{7} in Fig.~\ref{fig:overview}. To achieve this, we formulate the execution of each subtask in $\theta_{\phi}$ into a {\it generalized multi-robot path planning problem (GMRPP)}. Compared to the classical multi-robot path planning that, given an initial robot configuration, designs paths to reach the target configuration, the GMRPP imposes additional constraints on the intermediate configuration.


 %% \begin{figure}[t]
 %%  \centering
 %%  \includegraphics[width=0.9\linewidth]{adjustment.pdf}
 %%  \caption{\blue{Adjustment of time spans. Consider three consecutive subtasks $e_1, e_2, e_3$. Every green horizontal bar depicts the time interval when the vertex label of one subtask is true and the red triangle marks the satisfaction of the edge label, i.e., the completion of the subtask. The upper part illustrates the general relation between the spans of subtasks (unaligned in the vertical direction for better illustration) and the lower  part shows the overlapping at the endpoints after the alignment.}}
 %%  \label{fig:adjustment}
 %% \end{figure}
 %% We first  align the timing of subtasks, consisting of two consecutive vertices in the found run $\theta_{\phi}$,  along the timeline. Specially, we fix the completion time of each subtask as an ``anchor' and then align the time interval when the associated vertex label is true,  so that the activation time of this subtask is the same as  the completion time   of the previous subtask, and the last time when the associated vertex label is true is the same as the completion time of this subtask; see also Fig.~\ref{fig:adjustment}. In this way,  the union of all spans of subtasks covers the whole timeline and the spans of two consecutive subtasks only overlap at the endpoint. Also, the time interval when the vertex label is true is the same as the span of the subtask. To realize the alignment, each  pair of  time instants in $t_{r.j}$ that specify the time interval when a vertex label is true will be modified so that the first time instant equals the completion of the previous subtask and the second one equals the completion of the current subtask that this vertex label corresponds to.

 %% {Note that the plan $\{p_{r,j}\}$ and the timeline $\{t_{r,j}\}$ still satisfy the constraints in Section~\ref{sec:milp} except~\eqref{eq:4}. Because we adjusted the timeline by fixing the time instants associated with edge labels, only constraints related to time instants associated with vertex labels can be affected, that is, \eqref{eq:4}, \eqref{eq:17} and~\eqref{eq:20}. Specifically, the completion time of the subtask is the same as the completion time of the corresponding vertex label, thus, the containtment in~\eqref{eq:17} is satisfied. Furthermore, the activation time of the current subtask is same as the completion time of the subtask immediately preceding it, thus, temporal constraint~\eqref{eq:20} is satisfied. Constraints in~\eqref{eq:4} can be  violated since the alignment can bring forward the activation time of the vertex label or delay the completion time of the vertex label, which might make the time difference between visitation of connecting vertices slightly less than the required traveling time. However, since the traveling time used in~\eqref{eq:4} is the shortest traveling time between regions, the constraints~\eqref{eq:4} are the approximation of the real situation, thus, violation of~\eqref{eq:4} is acceptable and will be addressed in Section~\eqref{sec:solution2mapp}.}

 {Observe that given the completion time of two consecutive subtasks in the time axis $\vec{t}$, we can obtain the tightest span of the second subtask's vertex label (see Definition~\ref{defn:time}). Specifically, the activation time of the second subtask's vertex label is at most one time instant later than the completion time of the first subtask; see also constraint~\eqref{eq:20} in Appendix~\ref{app:appendix_prefix_milp} that captures the temporal relation between two subtasks. On the other hand, the  completion time of the vertex label of the second subtask is at most one time instant earlier than the completion time of the second subtask; see also constraint~\eqref{eq:17} in Appendix~\ref{app:appendix_prefix_milp} that captures the temporal relation for the same subtask.  To design the low-level paths,  we let each robot visit waypoints in its individual plan $p_{r,j}$ sequentially, maybe at different time instants than those in its timeline $t_{r,j}$ when taking the concrete workspace into account, but relative temporal relations with other robots  are kept. Also, we maintain the tightest span of the vertex label of the considered subtask between completion time of two consecutive subtasks.}



 To this end, for each robot $[r,j] \in \ccalR$, we define a {\it local counter} $\zeta_{r,j} \in \mathbb{N}$  that  keeps track of how much progress has been made along the individual plan $p_{r,j}$. Specifically, $\zeta_{r,j} = a$ indicates that the $a$-th waypoint in the plan $p_{r,j}$ is the one  visited by  robot $[r,j]$  most recently. Furthermore, recall that the  global clock $c$ monitors the index of the most recently completed subtask  along the time axis $\vec{t}$, which also captures the execution progress along the simple path  $\theta_{\phi}$ since a one-to-one correspondence exists between time instants in $\vec{t}$ and subtasks in $\theta_\phi$. In what follows, we provide the ingredients for the construction of GMRPP.

 %%  \blue{Next, we discuss the correspondence between clauses in the NBA $\auto{subtask}^-$ and those in $\autop$ in two cases:
 %% \domanda{(i) Label is neither $\top$ nor $\bot$} Given a subtask $e$ contained in the run $\theta_{\phi}$ in $\auto{subtask}^-$, only one clause (a conjunction of positive literals) can be true in every associated label $\gamma$, vertex or edge label by~\eqref{eq:c}, if it is neither $\top$ nor $\bot$. We refer to this clause as the {\it satisfied clause} and denote by $\gamma^+$. For every satisfied clause in $\auto{subtask}^-$, there exists a unique clause in the pruned NBA $\autop^-$ that only differs from the satisfied clause in that it may contain the conjunction of the negative literals that were removed  during the relaxation stage . We refer to this conjunction of negative literals  as the {\it negative clause} and denote by $\gamma^-$, which is defined as $\top$ by default, if the corresponding clause does not have negative literals. In this way, each label is associated with a satisfied clause and a negative clause which together constitute one clause.

 %% \domanda{(ii) Label is $\top$}  When the vertex or edge label is $\top$, the associated satisfied clause is $\top$ by default. However, the negative clause may not be $\top$, which happens when all clauses in the corresponding label in $\autop^-$ only include negative literals. For the edge label, we randomly select one of its clauses as the negative clause. For the vertex label, we select one among clauses that only include negative literals that is not mutually exclusive with the conjunction of the satisfied and negative clauses associated with  the edge label of the subtask that is immediately preceding the current subtask. Otherwise, if the robot locations in the designed low-level paths  satisfy the edge lalel of the previous subtask in $\autop^-$, then the next robot locations should satisfy the negative clause associated with the vertex label of the current subtask. Due to the mutual exclusion,  this situation is hard to realize.}  In what follows, we describe  the ingredients of a single instance of the generalized multi-robot path planning problem [line~\ref{seq:ingredients}, Alg.~\ref{alg:sequentialMAPP}].

 \subsubsection{Ingredients of GMRPP:}\label{sec:gmmpp1} Consider a subtask $e = (v_1, v_2)$ generated by the simple path $\theta_{\phi}$ that is the next one to be completed. Let $\gamma_1^+$ and $\gamma_1^-$ denote the essential and negative clauses associated with the vertex label $\gamma_\phi(v_1)$, respectively. Similarly, we define $\gamma_{1,2}^{+}$ and $\gamma_{1,2}^{-}$  for the edge label $\gamma_\phi(v_1, v_2)$. The goal of a GMRPP   is to determine a collection of executable paths such that robots complete the current subtask (by satisfying the complete clause  $\gamma_{1,2}^+ \wedge \gamma_{1,2}^-$ at the end while respecting the complete clause $\gamma_1^+ \wedge \gamma_1^-$ en route) and automatically activate the next subtask after completion since the complete clause $\gamma_{1,2}^+ \wedge \gamma_{1,2}^-$ implies the complete clause associated with the starting vertex of the next subtask. We refer to $\gamma_1^-$ as the {\it running constraint} and $\gamma_{1,2}^- $  as the {\it terminal constraint}. Next, we determine three types of robots that are directly involved in the execution of the current subtask $e$.
%% Let $\gamma_1^-$ denote the negative clause associated with the vertex label $\gamma(v_1)$. Let $\gamma_2^{+,1} (\gamma_2^{-,1}) $ and $\gamma_2^{+,2} (\gamma_2^{-,2})$ denote the satisfied (negative) clause associated with the edge label $\gamma(v_1, v_2)$ and the vertex label of the next subtask, respectively. Then, we define $\gamma_2^+ = \gamma_2^{+,1} \wedge \gamma_2^{+,2}$ and $\gamma_2^- = \gamma_2^{-,1} \wedge \gamma_2^{-,2}$. As mentioned  in the definition of subtasks (see Definition~\ref{defn:subtask}), the completion of a subtask requires the satisfaction of its edge label while respects its vertex label. Thus, the goal of a GMRPP is to determine a collection of executable paths that satisfy the clauses $\gamma^+_2 \wedge \gamma^-_2$ at the end and respect the clause $\gamma_1^-$ en route.\endnote{We do not consider the satisfied clause, denoted by $\gamma_1^+$, in the vertex label of the current subtask since it is satisfied at the end of the previous subtask and will maintain true since involved robots remain idle, same as that $\gamma_2^{+,2}$ of the next vertex label is addressed when dealing with the current subtask.} That is, robots complete the current subtask (by satisfying the corresponding edge label $\gamma_2^{+,1}\wedge \gamma_2^{-,1}$ and the vertex label $\gamma_1^-$) and activate the next subtask (by satisfying the next vertex label $\gamma_2^{+,2}\wedge \gamma_2^{-,2}$). We refer to $\gamma_1^-$ as the {\it running constraint},  $\gamma_2^-$ as the {\it terminal constraint}, and $\gamma_2^+$ as the {\it target}.



 \refstepcounter{phase}\label{robots}
\subphase{Essential robots associated with constraint $\gamma_1^+$}{We collect essential robots associated with essential clauses in $\gamma_{1}^{+}$ in the set $\ccalR_{1}$,  where robots need to remain at certain target regions.}\label{sec:essential_a}

\subphase{Essential robots associated with target $\gamma_{1,2}^{+}$}{We collect essential robots associated with the essential clause  $\gamma_{1,2}^{+}$ in the set $\ccalR_{1,2}$, where  robots need to reach certain target regions.}\label{sec:essential_b}

 \subphase{Robots associated with running and terminal constraints $\gamma_1^-$ and $\gamma_{1,2}^-$}{The robots, in this case, are different from the previous two types since they are related to negative clauses $\gamma_1^-$ or $\gamma_{1,2}^-$. These robots, unless they are involved in the first two cases, navigate without specific targets, only to satisfy the threshold imposed by the negative literals on the number of certain types of robots in some regions. We collect them in the set $\ccalR^-$, which contains all robots that belong to certain types involved
 in $\gamma_1^-$ or $\gamma_{1,2}^-$, i.e., $\ccalR^- = \left\{\ccalK_j: \neg \ap{i}{j}{k} \in \mathsf{lits}^- (\gamma_1^-  \vee \gamma_{1,2}^-) \right\}$.}\label{sec:essential_c}

 Let $\ccalR_e = \ccalR_1 \cup\ccalR_{1,2}  \cup \ccalR^-$ denote the set that collects all robots directly involved in the current subtask, and $\ccalR_0 = \ccalR \setminus\ccalR_e$ collects the remaining robots. To formulate the GMRPP,  we define by $X_I$ and $X_G$ the sets of initial and target locations, respectively, such that $X_I(r,j) \in S$ and $X_G(r,j)\subseteq S$ are the initial  and target locations of robot $[r,j] \in \ccalR$. Specifically, the initial robot locations are  where the robots are at the end of the subtask immediately preceding $e$. The target region of  robot $[r,j] \in \ccalR_{1,2}$ is determined  by its associated literal in $\gamma_{1,2}^+$, which is also given by  $p_{r,j}(\zeta(r,j)+1)$. Similarly, the target region of robot $[r,j] \in \ccalR_{1}$ can also be determined by its associated literal in $\gamma_1^+$. There are no specific target locations for robots in $\ccalR^- \cup \ccalR_0$.

 %% Furthermore, the target region of robot $[r',j'] \in \ccalR'_{1,2}$ is the  location from where robot $[r',j']$ can reach the region $p_{r',j'}(\zeta(r',j')+1)$ within time $\Delta t$ by taking the shortest route.
%% in the new workspace $S'$. If the selected target location of robot $[r',j']$ has already been assigned to another robot in $\ccalR'_{1,2}$, then we select another free cell on the shortest route to be this robot's target location, which is close to the previously selected occupied cell and has not been assigned.



Finally, let $\tau'_{r,j}$ denote the path segment of robot $[r,j] \in \ccalR$, where $\tau'_{r,j}(t)$ denotes the robot location at time $t$ for $ t = 0,  \ldots, T$, where time instants 0  and $T$ correspond to the completion time of the immediately preceding subtask and the current subtask, respectively. Next, the generalized multi-robot path planning problem in the partial execution scheme, adapted from~\cite{yu2016optimal}, is defined as follows.
 \begin{defn}[(Generalized multi-robot path planning)]\label{defn:gmmpp}
    Given a discrete workspace $E$, a set of robots $\ccalR= \ccalR_e \cup \ccalR_0$ where $\ccalR_e = \ccalR_1 \cup\ccalR_{1,2} \cup \ccalR^-$, a set of initial locations $X_I$, a set of target regions $X_G$, the running constraint $\gamma_1^-$, the terminal constraint $\gamma_{1,2}^-$, and the horizon $T$, find a collection of path segments $\tau'_{r,j}$ for all robots $[r,j]\in \ccalR$ such that {\it (i)} every robot $[r,j] \in \ccalR_{1,2}$ starts from the initial location and arrives at the target region at time instant $T$, i.e., $ \tau'_{r,j}(0) = X_I(r,j)$ and  $ \tau'_{r,j}(T) \in X_G(r,j)$, $\forall [r,j] \in  \ccalR_{1,2}$; {\it (ii)} every robot $[r,j] \in \ccalR_1$ remains in the target region for all time except $0$ and $T$, i.e., $ \tau'_{r,j}(0) = X_I(r,j)$ and $\tau'_{r,j}(t) \in X_G(r,j)$ for all $t=1,\ldots, T-1$;
  %% {\it (ii)} the paths of  any two distinct robots $[r,j]$ and $[r', j']$ are collision-free, that is, there does not exist  a atime instant $t \in [T+1]$ such that $\tau'_{r,j}(t) = \tau'_{r',j'}(t)$ (meet collision, that is, two robots occupy the same cell at the same time) or  $\tau'_{r,j}(t) = \tau'_{r',j'}(t-1) \wedge \tau'_{r',j'}(t) = \tau'_{r,j}(t-1)$ (head-on collision, that is, two robots at adjacent cells switch locations with each other);
  and {\it (iii)} the paths $\{\tau'_{r,j}\}, \forall [r,j] \in \ccalR^-$, must satisfy the running constraint $\gamma^-_1$ for all times except at $0$ and $T$, and also satisfy the terminal constraint $\gamma^-_{1,2}$ at time instant $T$.
 \end{defn}

 \begin{figure}[!t]
   \centering
   \includegraphics[width=0.9\linewidth]{timeline.pdf}
   \caption{The time relation within one GMRPP. The essential and negative clauses are aligned with the time instants when they should be satisfied.}
   \label{fig:timeline}
 \end{figure}

Fig.~\ref{fig:timeline} illustrates the time relation within one instance of GMRPP.  The paths do not need to satisfy  $\gamma_1^+$ and $\gamma_1^-$ at time instants 0 and  $T$ since the tightest span of the vertex label of the current subtask can be one time instant later than the completion of the immediately preceding subtask, which is indicated by time 0, and one time instant earlier than the completion of the current subtask, which is indicated by time $T$. In Appendix~\ref{sec:solution2mapp}, we discuss how to solve the GMMPP with horizon $T$.  The paths returned by this GMRPP complete the subtasks $(v_1, v_2)$  and meanwhile activate the vertex label of $v_2$, i.e., the next subtask. %% They navigate only to move out of the way of robots that head for their targets. Therefore, the new workspace $E'$ is the same as the original one $E$.

\begin{rem}
  In the formulation of GMRPP, we did not take into account the collision avoidance between robots, which will be addressed in Appendix~\ref{sec:extension_collision}.
\end{rem}

 \begin{rem}
   Note that subtasks are executed sequentially as discussed above since we only assign target regions to those robots $\ccalR_1 \cup \ccalR_{1,2}$ directly involved in the current subtask $e$.  Thus, we refer to this as the sequential execution scheme. However, robots that participate in subsequent subtasks of $e$ can move simultaneously with these robots heading toward some ``intermediate'' targets,  so that after the current subtask $e$ is completed, these robots associated with subsequent subtasks have traversed part of their routes towards finishing their respective subtasks. We will present this simultaneous execution scheme  in Appendix~\ref{sec:extension_essential}.
 \end{rem}

\begin{rem}
  We refer to the execution of the subtask $e$ discussed above as the full execution scheme since it mobilizes all robots in the workspace. However, most times not all robots need to move for one specific subtask since  only a subset of robots are responsible for the satisfaction of this subtask. In Appendix~\ref{sec:extension_partial} we will extend this to  the partial execution scheme where only necessary robots in $\ccalR_e$, are allowed to move and the rest of robots stay put. The partial execution scheme shares  most similarity with the full execution scheme.
\end{rem}




 {\begin{algorithm}[!t]
    \caption{Executable multi-robot path planning}
    \algorithmendnote{The right-side time instant $\vec{t}(c+1)$ in~line~\ref{seq:axis} is the one before updates.}
      \LinesNumbered
      \label{alg:sequentialMAPP}
      \KwIn {Workspace $E$,  robot team $\ccalR$, subtask sequence $\theta_{\phi}$, waypoint sequence $\{p_{r,j}\}$, time sequence $\{t_{r,j}\}$, NBA $\autop$ and $\auto{subtask}^-$}
      \Comment*[r]{Initilization}
      $\tau_{r,j} = s_{r,j}^0 $, $\zeta_{r,j} = 0, \forall\, [r,j] \in \ccalR$, $c = 0$ \label{seq:initilization}\;
      \Comment*[r]{Sequential GMRPP solutions}
      \For{$e = (v_1, v_2) \in \theta_{\phi}$ \label{seq:terminate_1}}{
        \If{\upshape $\vec{t}(1)=0$ \label{seq:initial}}{
          $\zeta_{r,j} = \zeta_{r,j} + 1, \; \forall \, [r,j] \in \ccalR_{1,2}$ \label{seq:counter_initial}\;
          $c = c + 1$ \label{seq:c_initial}\;
        }
        \Else{
          Formulate the GMRPP  \label{seq:ingredients}\;
          Solve the GMRPP for horizon $T$ as in Appendix~\ref{sec:solution2mapp} to obtain paths $\tau'_{r,j}$, $\forall [r,j]\in \ccalR$\label{seq:mapp}\;
          \Comment*[r]{Update}
          %% \If{\upshape $v_2 = \vertex{accept}$  \label{seq:terminate_1}}{
          %%   If $v_2$ has a self-loop, $\tau_{r,j} = \tau_{r,j} \cdot \tau'_{r,j}[1:T_e+1], \;\forall \,[r,j] \in \ccalR $, and repeat $T_e+1$ times the last waypoint in $\tau_{r,j}$ for robots in $[r,j] \in \{\ccalK_j\} \setminus \ccalR$; otherwise, add $\tau'_{r,j}[1:T_e]$ to $\tau_{r,j}$ and repeat $T_e$ times the last waypoint in $\tau_{r,j}$ \label{seq:finalpath}\;
          %%   {\bf break}\;
          %% }
          %% %% \ElseIf{\upshape $v_2 = \vertex{accept}$ {\bf and} $\gamma(v_2) = \bot$ \label{seq:terminate_2}}{
          %% %%   $\tau_{r,j} = \tau_{r,j} \cdot \tau'_{r,j}[1:T_e], \;\forall \,[r,j] \in \ccalR $, and repeat $T_e$ times the last waypoint in $\tau_{r,j}$ for robots in $[r,j] \in \{\ccalK_j\} \setminus \ccalR$ \label{seq:finalpath}\;
          %% %%   {\bf break}\;
          %% %% }
          Concatenate paths:
            $\tau_{r,j} = \tau_{r,j} \cdot \tau'_{r,j}[1:T_e], \;\forall \,[r,j] \in \ccalR $%% , and repeat  $T_e$ times  the last waypoint in $\tau_{r,j}$ for robots in $[r,j] \in \ccalR_0$
          \label{seq:path}\;
           Update individual timeline:  $t_{r,j}(\zeta) =  t_{r,j}(\zeta)  + T_e - (\vec{t}(c+1) - \vec{t}(c))$, $\forall \,\zeta \geq  \zeta_{r,j}$, $ \forall\, [r,j] \in  \ccalR$ \label{seq:timeline} \;
          Upadte time axis: $\vec{t}(c') = \vec{t}(c') + T_e - (\vec{t}(c+1) - \vec{t}(c))$, $ \forall \, c' \geq c+1$  \label{seq:axis}\;
          Update local counter: $\zeta_{r,j} = \zeta_{r,j} + 1, \; \forall \, [r,j] \in \ccalR_{1,2}$ \label{seq:counter}\;
           Update global counter: $c = c + 1$ \label{seq:c}\;

        }
      }
      %% \If{\upshape close the loop for the suffix plan}{
      %%   Formulate the GMRPP by determining the set $\ccalR$ of robots required to move, the updated workspace $E'$, sets of initial locations $X_I$ and target locations $X_G$, running constraint $\gamma_1^-$, and horizon $T$ \label{seq:ingredients_loop}\;
      %%   Solve the GMRPP for horizon $T$ as in Section~\ref{sec:solution2mapp} to obtain paths $\tau'_{r,j}$. If no solution exists, increment $T$ by a constant\label{seq:mapp_loop}\;
      %%    $\tau_{r,j} = \tau_{r,j} \cdot \tau'_{r,j}[1:T_e], \;\forall \,[r,j] \in \ccalR $ \label{seq:finalpath}\;
      %% }
\end{algorithm}}

 \subsubsection{Sequential GMRPP solutions to find low-level paths that induce the simple path $\theta_{\phi}$:}
 The algorithm to design executable paths based on GMRPP under the  partial execution scheme is outlined in Alg.~\ref{alg:sequentialMAPP}.  We initialize all local counters and the global clock with 0 [line~\ref{seq:initilization}, Alg.~\ref{alg:sequentialMAPP}]. The algorithm  terminates when iteration over  the subtasks in the simple path $\theta_{\phi}$ is finished [line~\ref{seq:terminate_1}, Alg.~\ref{alg:sequentialMAPP}].  We first check whether the first time instant $\vec{t}(1)$ in the time axis is 0. If $\vec{t}(1)=0$, then the first subtask in the simple path $\theta_{\phi}$, i.e., the edge label of the first subtask, is satisfied by the initial robot locations. Thus, we increase the local counters of robots that participate and the global counter by 1 [lines~\ref{seq:initial}-\ref{seq:c_initial}, Alg.~\ref{alg:sequentialMAPP}]. Otherwise, we solve the corresponding GMRPP as in Appendix~\ref{sec:solution2mapp}.  We initialize $T$ by $\vec{t}(c+1) - \vec{t}(c)$ (by default $\vec{t}(0)=0$),  which is the difference between the completion time of the immediately preceding subtask and the current one. %% Another instance of GMRPP is generated by incrementing $T$ until a solution is found and
we denote by $T_e$  the final $T$  when  the GMRPP has a solution [line~\ref{seq:mapp}, Alg.~\ref{alg:sequentialMAPP}]. {Given a solution to the generalized multi-robot planning problem, Alg.~\ref{alg:sequentialMAPP} proceeds with the following updates [lines~\ref{seq:path}-\ref{seq:c}, Alg.~\ref{alg:sequentialMAPP}].

%% {The iteration terminates when the end vertex $v_2$ of subtask $e$ is $\vertex{accept}$ [line~\ref{seq:terminate_1}, Alg.~\ref{alg:sequentialMAPP}]. For robot $[r, j] \in \ccalR$, we append the path segment $\tau'_{r,j}(t)$, for all $t = 1, \ldots, T_e$, to its already-executed path $\tau_{r,j}$, i.e.,  $\tau_{r,j} = \tau_{r,j} \cdot \tau'_{r,j}[1:T_e]$ where ``$\cdot$'' denotes the concatenation of two path segments. Then, for other robot $[r,j] \in \{\ccalK_j\}\setminus \ccalR$, we  append  $T_e$ times  the last waypoint of  $\tau_{r,j}$  to $\tau_{r,j}$, that is, these robots  remain idle for $T_e$ time instants [line~\ref{seq:finalpath}, Alg.~\ref{alg:sequentialMAPP}]. In the full execution scheme, path segments of all robots will be provided by the solution of GMRPP. If the  end vertex $v_2$ of subtask $e$ is $\vertex{accept}$ and $\vertex{accept}$ does not have a self-loop, the iteration also terminates and  we take similar steps to append $T_e$ waypoints in the path segments to already-executed ones [line~\ref{seq:finalpath}, Alg.~\ref{alg:sequentialMAPP}].

  First, for each robot $[r, j] \in \ccalR$, we append the path segment $\tau'_{r,j}(t)$, for all $t=1,\ldots, T_e$, to its already-executed path $\tau_{r,j}$ [line~\ref{seq:path}, Alg.~\ref{alg:sequentialMAPP}]. %% Then, for other robots $[r,j] \in  \ccalR_0$ that remain idle, we  append  $T_e$ times the last waypoint of  $\tau_{r,j}$  to $\tau_{r,j}$ [line~\ref{seq:path}, Alg.~\ref{alg:sequentialMAPP}]
 Note that the final waypoints will be the initial locations of the next instance of GMRPP.  Moreover, for each robot $[r,j] \in \ccalR$, we increase the time instants in $t_{r,j}$ with indices larger than or equal to  $\zeta_{r,j}$ by $T_e - (\vec{t}(c+1) - \vec{t}(c))$ [line~\ref{seq:timeline}, Alg.~\ref{alg:sequentialMAPP}], where $\vec{t}(c+1) - \vec{t}(c)$ is the time span of the current subtask  given by the high-level plan whereas $T_e$ is the actual time span given by the low-level executable path.
    Similarly, we increase the time instants in $\vec{t}$ with indices larger than or equal to  $c+1$ by $T_e - (\vec{t}(c+1)- \vec{t}(c))$.
    In this way,  the subsequent subtasks in the high-level plan  that have not been executed are shifted into the future by the same amount in order to maintain the correct temporal relation (precedence or simultaneity) between visits to waypoints in $\{p_{r,j}\}$. Next, we increase  the local counter by 1 for all robots in $\ccalR_{1,2}$, which reflects local progress towards completing their individual plans [line~\ref{seq:counter}, Alg.~\ref{alg:sequentialMAPP}]. Similarly, we increase the global counter $c$ by 1 [line~\ref{seq:c}, Alg.~\ref{alg:sequentialMAPP}].}




\subsection{Solution to the Generalized Multi-Robot Path Planning}\label{sec:solution2mapp}

{ Conventional multi-robot path planning problems  find feasible or optimal paths for groups of robots starting from a set of initial locations and ending at a set of desired target locations; see, e.g., \cite{yu2016optimal} and the references therein. To find executable paths satisfying the subtasks, we generalize the multi-robot path planning problem in several ways. First,  we extend the notion of a single target location to a target region such that reaching any cell in the target region suffices. Second, the path segments that complete the  subtask  satisfy the complete clauses in the corresponding vertex label and edge label. Third, in the partial execution scheme,  only a subset of robots  directly involved in the current or future subtasks are allowed to move.
\begin{figure}[t]
  \centering
  \includegraphics[width=0.8\linewidth]{mapp.pdf}
  \caption{Time-expanded graph over horizon $T$} (modified from~\cite{yu2016optimal})
  \label{fig:mapp}
\end{figure}

\begin{figure}[t]
  \centering
  \includegraphics[width=0.5\linewidth]{gadget.pdf}
  \caption{Merge-split gadget for avoiding head-on collision} (from~\cite{yu2016optimal})
  \label{fig:gadget}
\end{figure}

  In what follows, we adapt the method proposed in~\cite{yu2016optimal} to solve GMRPP under the full execution scheme with given horizon $T$.  The key idea is to construct a time-expanded graph $\ccalG_T = (\ccalV_T, \ccalE_T)$ of the workspace which contains $T$ copies of the free cells in the workspace $E$; see Fig.~\ref{fig:mapp}. We organize the vertices and edges of this time-expanded graph $\ccalG_T$ in a matrix structure, so that each row corresponds to a free cell in the workspace $E$ and each column corresponds to a time instant $t\in \{0,\ldots,T\}$. Then, a vertex $u_t \in \ccalV_T$ that appears in the $t$-th column of this matrix structure indicates whether the cell $u\in E$ is occupied by a robot at the time instant $t$. The edges in $\ccalG_T$ capture  adjacency relations between neighboring cells in $E$ and consecutive time instants in $\{0,\ldots,T\}$. Specifically, for any two adjacent cells $u$ and $v$ in $E$, an ``X''-shape structure, referred to as a {\it merge-split gadget}, is created to capture the transition from vertex $u$ at time $t$ to vertex $v$ at time $t+1$; see also Fig.~\ref{fig:gadget}. In this way, robots traveling along a given row in the matrix structure corresponding to $\ccalG_T$ effectively remain idle at their current cell, while robots switching between different rows in $\ccalG_T$ transition between adjacent cells in $E$. We say that a sequence of transitions in $\ccalG_T$ form $t=0$ to $t=T$ produces a robot path in the workspace $E$.

Next, we formulate an Integer Linear Programming (ILP) to solve the GMRPP. Let $s_{uvrj} \in\{0,1\}$ be the routing variable such that $s_{u_{t}v_{t+1}rj} = 1$ if robot $[r,j] \in \ccalR$ traverses the edge $(u_t,v_{t+1}) \in \ccalE_T$. In what follows, we describe the constraints and objective of this ILP.

\subsubsection{Routing constraints:}
The constraint that each edge can be traversed by at most one robot at the given time is encoded as}
\begin{align}
  \sum_{[r,j] \in \ccalR} s_{u_t v_{t+1}rj} \leq 1, \quad \forall \,(u_t,v_{t+1}) \in \ccalE_T,
\end{align}
for all $t=0,\ldots, T-1$. Furthermore, the flow conservation constraint is encoded as,
  \begin{align}\label{equ:flow}
  \sum_{u_{t-1}:(u_{t-1}, v_t) \in \ccalE_T}   s_{u_{t-1} v_t rj} &  =   \sum_{w_{t+1}:(v_t, w_{t+1}) \in \ccalE_T} s_{v_t w_{t+1} rj},
  \end{align}
for all robots $[r,j]\in \ccalR$ and all $t=1,\ldots,T-1$. This means that every robot that arrives at a vertex in $\ccalG_T$ has to leave that vertex at the next time step. Next, the constraints at the initial time are encoded as,
\begin{subequations}\label{equ:source}
  \begin{align}
    \sum_{v_1:(u_0, v_1) \in \ccalE_T} s_{u_0v_1 rj} &  = 1,  \\
    \sum_{v_1:(w_0, v_1) \in \ccalE_T} s_{w_0v_1 rj} & = 0, \quad \forall\, w \in E\setminus u,
  \end{align}
\end{subequations}
for all robots $[r,j]\in \ccalR$, where $u_0$ is the vertex associated with the cell $u = X_I(r,j)$ where robot $[r,j]$ is at the initial time. Constraints~\eqref{equ:source} state that robot $[r,j]$ has to depart from its initial location. Note that this departure is in the graph $\ccalG_T$ and is associated more with time than physical location.

\subsubsection{Target constraint:}
The general constraints that robot $[r,j]$ in $\ccalR_1$ and $\ccalR_{1,2}$  arrives at a cell   in the target region $X_G(r,j)$ at certain time instant $t$ can be encoded as
  \begin{align}\label{equ:sink}
  \sum_{v: v \in X_G(r,j) } \;\sum_{u_{t-1}:(u_{t-1}, v_{t}) \in \ccalE_T} s_{u_{t-1} v_{t} rj} &  = 1.
  \end{align}
 Specifically, $t$ in constraint~\eqref{equ:sink} takes the value ranging from $1, \ldots, T-1$ when encoding the constraint that robot $[r,j] \in\ccalR_1$  stays at the target region $X_G(r,j)$ to maintain the truth of  the vertex label of the current subtask.  For the constraint that robot $[r,j]\in\ccalR_{1,2} $ arrives at a cell in $X_G(r,j)$ at the time instant $T$ to complete the current subtask, we have $t = T$ in constraint~\eqref{equ:sink}. %% Similarly,  the constraint that robot $[r,j] \in \ccalR_2$ arrives at a cell that is in the target region $X_G(r,j)$ at the time $T$ to activate the next subtask  can be encoded by assigning $T$ to $t$ in~\eqref{equ:sink}.

 \subsubsection{Running and terminal constraints:} The general running and terminal constraints that negative literals $\neg \ap{i}{j}{k}$ should be respected at certain time instant $t$ is encoded as
\begin{align}\label{equ:avoid}
  \sum_{[r,j]\in \ccalK_j} \sum_{v \in \ell_k}   \sum_{u_{t-1}: (u_{t-1}, v_{t}) \in \ccalE_T} s_{u_{t-1} v_{t} r j } \leq i - 1.
\end{align}
The running constraint that any
negative literal $\neg\ap{i}{j}{k} \in \mathsf{lits}^-(\gamma_1^-)$ in the vertex label of the current subtask should be respected (excluding time instants $0 $ and $T$), can be encoded by assigning to $t$ in constraint~\eqref{equ:avoid} values ranging from $1$ to $T-1$. Similarly, we encode the terminal constraint that the negative literal  $\neg\ap{i}{j}{k}$ in $\mathsf{lits}^-(\gamma_{1,2}^-)$  should be satisfied at the time $T$ by letting $t$ in constraint~\eqref{equ:avoid} take the value $T$.
\subsubsection{ILP objective:} The ILP objective is to minimize the total traveling cost and is defined as
\begin{align}
  \text{min} \sum_{[r,j] \in \ccalR} \; \sum_{t\in \{0,\ldots, T-1\}} \sum_{(u_t, v_{t+1}) \in \ccalE_T} d_{uv} s_{u_{t} v_{t+1} r j}   .
\end{align}
where $d_{uv} \in \mathbb{N}$ is the traveling cost between cells $u$ and $v$.

When a solution does not exist for a given horizon $T$, we increment $T$ to solve the ILP again.  The solution provides  a collection of executable paths that satisfy  the current subtask   as well as activates the next subtask at time $T$.

\subsection{Extensions of GMRPP}\label{sec:extension_gmrpp}
In this section, we present several extensions of the GMRPP. We first address the collision avoidance between robots, then we  show  how essential robots for other subtasks can simultaneously move with those of the current subtask and finally show  how only necessary robots move.


\subsubsection{Collision avoidance:}\label{sec:extension_collision}
To handle collision avoidance, we first add one more step to  pre-process the NBA $\autop$ (see Section~\ref{sec:nba}), which removes infeasible clauses due to limited size of regions:
\paragraph{(6) Violation of region size:} \label{prune:violation2} For each clause $\cp{p}{\gamma} \in \clause{\gamma}$, let $\mathsf{lits}^+(k)$ denote literals in $\mathsf{lits}^+(\cp{p}{\gamma})$ that involve region $\ell_{k}$. We delete the clause $\cp{p}{\gamma}$ (replacing it with $\bot$) if the required total number of robots  visiting region $\ell_{k}$ exceeds the number of free cells it covers, i.e., if there exists $k\in[l]$ such that $ \sum_{\ap{i}{j}{k,\chi}\in\mathsf{lits}^+(k)}   i > |\ell_k|$.

Collision avoidance is mostly addressed in the low-level path planning component  since the high-level plan generation abstracts out the workspace. In one instance of GMRPP, the paths of  any two distinct robots $[r,j]$ and $[r', j']$ are collision-free if there does not exist  a time instant $t \in [T]$ such that $\tau'_{r,j}(t) = \tau'_{r',j'}(t)$ (meet collision, that is, two robots occupy the same cell at the same time) or  $\tau'_{r,j}(t) = \tau'_{r',j'}(t-1) \wedge \tau'_{r',j'}(t) = \tau'_{r,j}(t-1)$ (head-on collision, that is, two robots at adjacent cells switch locations with each other). Furthermore, if the partial execution scheme that will be introduced in Appendix~\ref{sec:extension_partial} is employed, we treat those robots that are not allowed to move  as obstacles, giving rise to a new workspace $E'=(S', \to_{E'})$. If the full execution scheme is employed, we have $E' = E$.
The time-expanded graph in Fig.~\ref{fig:mapp} that captures the connectivity of the workspace is constructed based on the new workspace $E'$. Finally, we add the following collision avoidance constraints to the ILP for the GMRPP.

Avoiding meet collisions,  $\forall v \in E'$, can be captured by the constraint
\begin{align}\label{eq:meet}
 \sum_{[r,j]\in\ccalR}  \, \sum_{u_t: (u_t, v_{t+1}) \in \ccalE_T} s_{u_t v_{t+1} r j } \leq 1,  \; \forall \,(u_t, v_{t+1}) \in \ccalE_T,
\end{align}
for all $t=0,\ldots,T-1$. Moreover, avoiding head-on collisions at every  gadget, $\forall u, v \in E'$ with $u\not= v$ can be captured by the constraint
\begin{align}\label{eq:headon}
 \sum_{[r,j]\in \ccalR} \left( s_{u_t v_{t+1} r j } + s_{v_t u_{t+1} r j } \right) \leq 1, \; \forall \,(u_t, v_{t+1}) \in \ccalE_T,
\end{align}
for all $t=0,\ldots,T-1$.


\subsubsection{Simultaneous execution scheme:}\label{sec:extension_essential}
When identifying robots in Appendix~\ref{sec:gmmpp1} that are involved in one instance of GMRPP, we only identify robots $\ccalR_e =\ccalR_1 \cup \ccalR_{1,2} \cup \ccalR^-$ that are directly involved in the completion of the current subtask (see~\ref{sec:essential_a}-\ref{sec:essential_c}). However, the rest of robots that are not involved in the current subtask may participate in subsequent subtasks of  the current subtask $e$. These robots can move simultaneously  heading towards  waypoints associated with subsequent subtasks. In what follows, we find essential robots associated with these subsequent subtasks.

 \paragraph{(\ref*{robots}$_4$) Essential robots associated with subsequent subtasks:} These robots move simultaneously with the first two types of robots in \ref{sec:essential_a}-\ref{sec:essential_b} heading towards  waypoints associated with subsequent subtasks of the current subtask $e$. We collect these robots in the set $\ccalR'_{1,2}$ and identify them in the following way. First, we identify the completion time  of the current subtask, which is given by $\vec{t}(c+1)$.  Next, we iterate over the remaining robots that are not in $\ccalR_1 \cup \ccalR_{1,2}$ since they have been assigned target locations. For every robot $[r,j] \in \ccalR \setminus(\ccalR_1 \cup \ccalR_{1,2})$, the time when it should visit the next waypoint based on its local counter $\zeta_{r,j}$ is given by $t_{r,j}(\zeta_{r,j}+1)$. Note that {$t_{r, j}(\zeta_{r,j}+1) > \vec{t}(c+1)$} since we proceed along the simple path $\theta_{\phi}$ and the completion time of  subtasks that have not been considered %% by the precedence relation in~\eqref{eq:12} and the increasing time axis,
 will be larger than that of the current subtask. Finally, we calculate the time difference $\Delta t = t_{r, j}(\zeta_{r,j}+1) - \vec{t}(c+1)$  and then check whether the robot $[r, j]$ can arrive at the target region $p_{r,j}(\zeta_{r,j}+1)$  within time $\Delta t$ starting from  its current location by taking the shortest route. {If not, robot $[r, j]$ should move simultaneously when completing the current subtask.} In this case, the set of robots that are involved in some subtasks becomes $\ccalR_e = \ccalR_1 \cup \ccalR_{1,2} \cup \ccalR'_{1,2}\cup \ccalR^-$.

 Next, we determine the target location $X_G(r,j)$ for robot $[r,j] \in \ccalR'_{1,2}$, which is the  location from where robot $[r,j]$ can reach the region $p_{r,j}(\zeta(r,j)+1)$ within time $\Delta t$ by taking the shortest route in the new workspace $S'$ (obtained by treating robots in the partial execution scheme that do not move as obstacles). To avoid collision, if the selected target location of robot $[r,j]$ has already been assigned to another robot in $\ccalR'_{1,2}$, then we select another free cell on the shortest route to be this robot's target location, which is close to the previously selected occupied cell and has not been assigned. More importantly, if a negative literal $\neg \ap{i}{j}{k}$ exists in running or terminal constraints $\gamma_1^- \vee \gamma_{1,2}^-$,  the selected free cell for robot $[r,j]$  should not be inside region $\ell_k$. In the worst scenario where such a free cell is not available for robot $[r,j]\in \ccalR_{1,2}'$, then we do not assign a specific target location to it, similar to the sequential execution. After determining the target location,  the requirement in Definition~\ref{defn:gmmpp} of GMRPP on robot $[r,j] \in \ccalR'_{1,2}$ is that it should arrive at the target waypoint at time $T$, that is, design the path $\tau'_{r,j}$ such that $\tau'_{r,j}(0) = X_I(r,j)$ and $\tau'_{r,j}(T)= X_G(r,j)$. Note that the target $X_G(r,j)$ for $[r,j] \in \ccalR_{1,2}'$ is a single cell, other than a region for robots in $\ccalR_{1,2}$.
 Similar to robots in $\ccalR_{1,2}$ that complete the current subtask, this requirement can be encoded by setting $t$ as $T$ in constraint~\eqref{equ:sink} that handles the target constraint.
 %% {\it (ii)}

 \subsubsection{Partial execution scheme:}\label{sec:extension_partial}
 In Appendix~\ref{sec:gmmpp1}, all robots are involved in the formulation of GMRPP, which leads to large-sized ILP in Appendix~\ref{sec:solution2mapp} when the size of robots is large.  To reduce the complexity, we introduce the partial execution scheme in which only necessary robots are allowed to move and the remaining are treated as obstacles.

 First, we identify robots that need to move, which include essential robots in $\ccalR_1 \cup \ccalR_{1,2}$ and $\ccalR_{1,2}'$ when simultaneous execution scheme is adopted. These robots have target locations. In the full execution scheme, the set $\ccalR^-$ is defined as $\ccalR^- = \left\{\ccalK_j: \neg \ap{i}{j}{k} \in \mathsf{lits}^- (\gamma_1^-  \vee \gamma_{1,2}^-) \right\}$, which contains all robots whose types are involved in the running and terminal constraints. To shrink the size of $\ccalR^-$, for every negative literal $\neg \ap{i}{j}{k} \in \gamma_1^- \vee \gamma_{1,2}^-$, we identify the number $i'$ of robots of type $j$ that is at region $\ell_k$ at time instant 0 in each instance of GMRPP. If $i' < i$, we remove robots of type $j$, i.e., $\ccalK_j$, from $\ccalR^-$ and update this literal $\neg \ap{i}{j}{k}$ to be $\neg \ap{i-i'}{j}{k}$. Otherwise, if $i' \geq i$, this only happens when $\neg \ap{i}{j}{k} \in \gamma_{1,2}^-$ since in each instance of GMRPP robot locations at time instant 0 satisfy the starting vertex label, thus also satisfy $\gamma_1^-$. In this case, we replace $\ccalK_j$ in $\ccalR^-$ with $i'-i+1$ robots of type $j$ that are at region $\ell_k$ and update this literal $\neg \ap{i}{j}{k}$ to be $\neg \ap{1}{j}{k}$. In this way, we  minimize the number of robots in $\ccalR^-$. Then, the robots that need to move constitute the set $\ccalR_e = \ccalR_1 \cup \ccalR_{1,2} \cup \ccalR_{1,2}' \cup \ccalR^-$, and the remaining $\ccalR_0 = \ccalR \setminus \ccalR_e$ are treated as obstacles, giving rise to a new workspace $E' = (S', \to_{E'})$.

The formulation of ILP to solve the GMRPP remains the same except that no variables are created corresponding to unmoved robots. After obtaining a solution to GMRPP, we follow similar steps in lines~\ref{seq:path}-\ref{seq:c} in Alg.~\ref{alg:sequentialMAPP} to update. The exception is that in the full execution scheme, we can concatenate paths for each robot in $\ccalR$ [line~\ref{seq:path}], while in the partial execution scheme, the GMRPP only finds paths for robots in $\ccalR_e$. For other robot $[r,j]\in \ccalR_0$, we append $T_e$ times the last waypoint of the already-executed $\tau_{r,j}$ to $\tau_{r,j}$ since they remain idle.


\section{Extensions and Discussions}\label{sec:extension}
In this section, we present several extensions of the proposed method. First we demonstrate possible extensions of the \ltlx formula such as two subtasks are completed by two different fleet of robots and  introduce variations to the MILP formulation by considering more interesting constraints. Then, we discuss the relaxation of the strong implication in the definition of restricted accepting runs.


\subsection{Variations of MILP for the high-level plan}\label{sec:extension_milp}
Leveraging that the MILP formulation deals with each subtask directly, we can add more constraints to cater to different restrictions on specific subtasks.
\subsubsection{Whether specific robots participate in a subtask:}
Given an atomic proposition $\ap{i}{j}{k,\chi}$ that appears in the \ltlx formula, we can demand  a specific subset of robots, denote by  ${\ccalK}'_j \subseteq \ccalK_j$,  to or not to participate in its satisfaction. Suppose the set of vertices  in $\ccalG$ that are associated with this literal is $\ccalM_{\ccalV}^\mathsf{lits} (e, 0|1, p, q)$,  then for each specific robot $r \in \ccalK'_j$, we have that
\begin{align}
  \sum_{u:(u,v) \in \ccalE_\ccalG} x_{uvr} = I, \quad  \forall \, v \in \ccalM_{\ccalV}^\mathsf{lits} (e, 0|1, p, q)
\end{align}
where $I\in \{0, 1\}$. We set $I$ as 1 if we require every robot in $\ccalK'_j$ to participate in the satisfaction of $\ap{i}{j}{k,\chi}$ (where $|\ccalK'_j|\leq i$); otherwise $I=0$ if any robot in $\ccalK'_j$ should not be involved. %% Note that we iterate all if there are multiple subsets of vertices that are associated with this literal due to that it appears in multiple labels.
\subsubsection{Managing the number of involved robots:}
When completing the task specified by \ltlx formula, it may be desirable to dispatch as few robots as possible, so  every dispatched robot engages in more subtasks. On the other hand, considering the resource-constrained component like battery,  we may want dispatched robots to be  as diverse as possible. For instance, if several areas need to be patrolled by robots, in the first  case, we deploy one robot to patrol all areas sequentially. However, if areas are not near to each other, we deploy more robots such that one robot per area. This requirement can be handled by adding another term to the MILP objective in~\eqref{equ:obj}, which becomes
\begin{align}\label{eq:objective1}
  \min \; \; &  \alpha_1 \sum_{(u,v)\in \ccalE_\ccalG}  \sum_{r \in \ccalM^\ccalV_{\ccalK}(v)} d_{uv} x_{uvr} +  \alpha_2  \sum_{e\in X_P} t_e  \nonumber \\ & \pm  \alpha_3 \sum_{v\in \ccalV_{\text{init}}}   \sum_{w:(v,w)\in \ccalE_\ccalG} x_{vwr_v},
\end{align}
where $\alpha_1 + \alpha_2 + \alpha_3=1$, $r_v$ is the specific robot at vertex $v \in \ccalV_{\text{init}}$, and the final term  captures the number of robots that leave their initial locations,  equivalent to  number of robots that are assigned to some subtasks. Objective~\eqref{eq:objective1} adds the final term if fewer robots are desirable otherwise subtracts it if more diverse robots are desirable.

\subsubsection{Prohibitive use of the same robots:} In the Definition~\ref{defn:valid} of \ltlx formula, we handle such requirement such two atomic propositions with the same nonzero connector are satisfied by the same fleet of robots. On the other hand, we can impose the restriction that some atomic propositions involving the same robot type but different nonzero connectors are satisfied by two disjoint fleets of robots. For instance, the formula $\lozenge \ap{1}{1}{1,1} \wedge \lozenge \ap{2}{1}{2,2}$ can require that the robot that visits region $\ell_1$ are different from those two robots that visit region $\ell_2$. Given such two atomic propositions that are to be  satisfied by different robots, suppose the sets of vertices in $\ccalG$ that are associated with these two literals are $\ccalM_{\ccalV}^\mathsf{lits} (e, 0|1, p, q)$ and $\ccalM_{\ccalV}^\mathsf{lits} (e', 0|1, p', q')$, then, $\forall \, r \in \ccalK_j$, this requirement can be encoded as
\begin{align}\label{eq:atmost1}
  \sum_{v\in \ccalM_{\ccalV}^\mathsf{lits} (e, 0|1, p, q)} & \sum_{u: (u,v) \in \ccalE_\ccalG} x_{uvr} + \nonumber \\
 & \hspace{-2em}  \sum_{v\in \ccalM_{\ccalV}^\mathsf{lits} (e', 0|1, p', q')} \sum_{u: (u,v) \in \ccalE_\ccalG}  x_{uvr} \leq 1.
\end{align}
Constraint~\eqref{eq:atmost1} says that robot $r$ of type $j$ can visit at most one vertex among vertices that are associated with these two literals.


\subsubsection{Returing to initial locations in one step:}\label{app:loop}
In Section~\ref{sec:suf_milp}, we take two steps to close robot trajectories. To achieve the goal of robots returning to initial locations and progression return to the accepting vertex $\vertex{accept}$ in one step, we first define a positive atomic proposition $\pi_{\text{init}}$ which is true if all robots return to there initial locations at the end of the suffix paths. Then, we replace $\ccalC_{\text{prior}}^+$ on the the edge label of last subtasks with $\pi_{\text{init}}$ (see Fig.~\ref{fig:suffix}). If $\pi_{\text{init}}$ is satisfied, the original edge label $ \gamma_\phi(\vertex{prior}', \vertex{accept})$ in $\autop$ will also be satisfied since initial robot locations satisfy $\ccalC_{\text{prior}}$ in $\gamma_\phi(\vertex{prior}, \vertex{accept})$ and $\gamma_\phi(\vertex{prior}, \vertex{accept}) \simplies \gamma_\phi(\vertex{prior}', \vertex{accept})$. Thanks to the similarity between $\ccalC_{\text{prior}}^+$, we can adopt the first step in Section~\ref{sec:suf_milp} with all exceptions related to $\pi_{\text{init}}$, where only robots participating in the satisfaction of $\ccalC_{\text{prior}}^+$ in the prefix part are required to return to their respective regions.

Recall that the vertex set $\ccalV_\text{init} \subseteq \ccalV_\ccalG$ contains vertices pointing to the initial robot locations. When building vertices in $\ccalV_\ccalG$ for the literal $\pi_{\text{init}}$, we create a copy of vertices in $\ccalV_{\text{init}}$ and associate these vertices  with the literal $\pi_{\text{init}}$, so that each vertex points to one single cell which is the initial location of a specific robot. The incoming edges of these vertices are constructed by treating $\pi_{\text{init}}$ as a regular clause (single literal with connector $\chi=0$) of an edge label. Specifically, given a subtask $e\in P_{\text{min}}$, let robot $r_v$ denote the specific robot that should visit vertex $v$ associated with its literal $\pi_{\text{init}}$. We find all vertices in $\ccalV_\ccalG$ that are associated with robots of the same type as $r_v$ and are related to initial locations (see case~\ref{sec:a}), prior subtasks of $e$ (see case~\ref{sec:b}) or vertex label of the same subtask (see case~\ref{sec:c}). Then, we create an edge from each vertex to vertex $r_v$. No outgoing edges exist for these vertices.  The remaining steps to build the routing graph are the same as those in Section~\ref{sec:suf_milp}.

When formulating the MILP, the only change is constraint~\eqref{eq:return_suffix}, that is, $\pi_{\text{init}}$ is true if and only if each vertex in $\ccalG$ that is associated with  $\pi_{\text{init}}$ is visited by a specific robot among the whole fleet of $n$ robots:
\begin{align}
  \left.   \left[ \sum_{v \in \ccalM_\ccalV^\mathsf{lits}(e, 1, p_e, 1)}   \sum_{u: (u,v) \in \ccalE_\ccalG}     x_{uvr_v} \right] \middle/ {n} \right. = b_e,
 \end{align}
where robot $r_v$ is the specific robot that should visit vertex $v$. Note that taking one step to achieve the goal of robot returning to initial locations  does not guarantee the completeness of our proposed method.

\subsection{Relaxation of strong implication in condition~(d) of Definition~\ref{defn:run}}\label{sec:discussion}
 Condition~\hyperref[cond:d]{\it(d)} in Definition~\ref{defn:run} requires that an edge label strongly implies its end vertex label. This condition ensures  both that the satisfaction of an edge label leads to the satisfaction of its end vertex label and that when constructing the routing graph $\ccalG$ (sec Section~\ref{sec:graph}), robots satisfying the  positive subformula in an end vertex label belong to robots satisfying the corresponding edge label. This condition can be relaxed to that an edge label implies its end vertex label (see Definition~\ref{defn:implication}), which can still ensure that the satisfaction of an edge label leads to  the satisfaction of its end vertex label, so that the previous instance of GMRPP still activates the immediately following instance of GMRPP. The only change is that in the pre-processing steps in Section~\ref{sec:nba} we remove any clause in an end vertex label if it is not a subformula of any clause in the corresponding edge label, so that the edge label strongly implies the remaining clauses in its end vertex label.
%% \subsubsection{Selection of a fixed number of simple paths:} In Section~\ref{sec:poset}, we collect all simple paths in the sub-NBA $\auto{subtask}^-$ to infer the posets. The number of simple paths may be large when the size of sub-NBA $\auto{subtask}^-$ remains large after pruning. To mitigate this issue, we can select a fixed number of simple paths at most, similar to finding a fixed number of runs in work~\cite{kloetzer2020path}. This will not severely compromise the diversity of the selected simple paths since a lot of simple paths are combinations of the same set of elementary subtasks.



 \section{Proof of Theorem~\ref{thm:completeness}}\label{app:correctness}
This section includes the proofs of the completeness in Theorem~\ref{thm:completeness}. Before presenting the main results, we first provide the necessary notation.
\subsection{Notation}
Given an NBA $\auto{}$, e.g., $\autop, \auto{relax}$ and $\auto{subtask}$, we define $\ccalL_E(\auto{})$ as the set of words in  $\ccalL(\auto{})$ that can be realized by robot paths. Recall that we can always map a run  in $\auto{}$ to its counterpart in $\autop$. If $\auto{}=\autop$, then the counterpart of a run is itself. We define $\ccalL^\phi_E(\auto{})$ as the set of realizable words in $\ccalL_E(\auto{})$ such that for the accepting run in $\ccalA$ induced by a realizable word $w \in \ccalL^\phi_E(\auto{})$, its counterpart in $\autop$  is a restricted accepting run. In words, considering $\auto{} = \auto{subtask}^-$, if a path $\tau$ generates a word $w$ in $\ccalL_E^\phi(\auto{subtask}^-) \subseteq \ccalL_E(\auto{subtask}^-)$ and further $w$ induces a run $\rho$ in $\auto{subtask}^-$ connecting a pair $v_0$ and $\vertex{accept}$, we can get its corresponding run from $\autop$, which motivates us to modify the path $\tau$  to produce this run  in $\autop$.  Additionally, let $\tilde{\ccalL}^{\phi}_E(\auto{}) \subseteq \ccalL^{\phi}_E(\auto{})$ collect those words in $\ccalL^{\phi}_E(\auto{})$ that can be generated by paths that satisfy Assumption~\ref{asmp:same}.

Next, we consider the prefix and suffix parts separately. Given a pair of initial and accepting vertices, $v_0$ and $v_\text{accept}$, let $\ccalL^{\phi, v_0 \scriptveryshortarrow \vertex{accept}}_E(\auto{})$ be the set that collects finite realizable words that can generate a run in $\auto{}$ connecting $v_0$ and  $\vertex{accept}$, and further the corresponding run in $\autop$ satisfies the requirements on the prefix part of a restricted accepting run (see conditions~\hyperref[cond:a]{\it (a)}-\hyperref[cond:d]{\it (d)} in Definition~\ref{defn:run}). Recall that when building the sub-NBA $\auto{subtask}^-$ for the suffix part, we rely on the last subtask $(\vertex{prior}, \vertex{accept})$ in $\auto{subtask}^-$ for the prefix part to extract the sub-NBA $\auto{subtask}$ for the suffix part (see Section~\ref{sec:suf_extract}), and also rely on final robot locations of the prefix part, denoted by $s_{\text{prior}}$, to interpret the augmented clause $\ccalC_{\text{prior}}^+$ (see Section~\ref{sec:suf_milp}). Therefore, we define  $\ccalL^{\phi, \vertex{accept} \scriptveryshortarrow \vertex{accept}}_E(\auto{}; s_{\text{prior}}, \vertex{prior})$ as the set that collects finite realizable words of which each  can generate a run in $\auto{}$ starting from $\vertex{accept}$ and ending at $\vertex{accept}$ whose corresponding run in $\autop$ is the suffix part of a restricted accepting run. Furthermore,  the path generating such a  word starts from $s_{\text{prior}}$ and the prefix part of this restricted accepting run  traverses $\vertex{prior}$ right before $\vertex{accept}$. In what follows, we  present the main results.

\subsection{Existence of feasible paths in the sub-NBA $\auto{subtask}^-$}
 The following proposition  states that paths exist that can induce accepting runs in the pruned sub-NBA $\auto{subtask}^-$, which will be used to show the feasibility of the MILP formulation.
\begin{prop}[(Feasible paths of the sub-NBA $\auto{subtask}^-$)]\label{thm:nba}
  Given a workspace satisfying Assumption~\ref{asmp:env} and a valid specification $\phi\in \textit{LTL}_{-\bigcirc}^\chi$, if there exists a path $\tau = \tau^\textup{pre} [\tau^\textup{suf}]^\omega$ inducing a restricted accepting run $\rho =  \rho^\textup{pre} [\rho^\textup{suf}]^\omega=  v_0, \ldots, \vertex{prior}, \vertex{accept} [\vertex{next}, \ldots, \vertex{prior}', \vertex{accept}]^\omega$ in $\autop$ and satisfies Assumption~\ref{asmp:same}, then there exists another path $\overline{\tau} = \overline{\tau}^{\textup{pre}}[\overline{\tau}^{\textup{suf}}]^\omega$ such that $\overline{\tau}^{\textup{pre}}$ generates a word in $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-) \not= \emptyset$. Furthermore, if $ \vertex{accept} \neq \vertex{next}$, then $\overline{\tau}^{\textup{suf}}$ generates a word in  $\tilde{\ccalL}^{\phi,\vertex{accept} \scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-; s_{\textup{prior}},v_\textup{prior}) \not= \emptyset$, where $s_\textup{prior}$ is the final robot locations of the assumed prefix path $\tau^{\textup{pre}}$.
\end{prop}

To prove Proposition~\ref{thm:nba},  we  go through main steps  to obtain the sub-NBA $\auto{subtask}^-$ and show results regarding the relations between different NBA; see Lemmas~\ref{prop:prune}-\ref{prop:sub-NBA2}. The first proposition shows that the pruning steps in Section~\ref{sec:prune} do not affect the set of restricted accepting runs  in $\autop$ that can be induced by realizable words.
 \begin{lem}[($\autop$ and $\autop^-$)]\label{prop:prune}
After pruning steps in Section~\ref{sec:prune}, it holds that  $\ccalL_E^\phi(\autop^-) = \ccalL^\phi_E(\autop)$.
  \end{lem}
 The proof can be found in Appendix~\ref{app:prune}. Note that any word in $\ccalL_E^\phi(\autop)$ induces a restricted accepting run in $\autop$.  A direct consequence of Lemma~\ref{prop:prune} is that, any path  generating a word $w \in \ccalL_E^\phi(\autop^-)$ satisfies  $\phi$ since the word $w$ also belongs to $\ccalL^\phi_E(\autop)$. The following proposition shows that relaxation expands the set of realizable words accepted by $\auto{relax}$ compared to that of $\autop^-$.
  \begin{lem}[($\autop^-$ and $\auto{relax}$)]\label{prop:inclusion}
 After the relaxation stage of replacing all negative literals with $\top$ in Section~\ref{sec:prune}, it holds that $\ccalL^\phi_E(\autop^-) \subseteq \ccalL^\phi_E(\auto{relax})$.
  \end{lem}
  The proof can be found in Appendix~\ref{app:inclusion}. Lemma~\ref{prop:inclusion} implies that a word in $\ccalL^\phi_E(\auto{relax})$ may not belong to $\ccalL^\phi_E(\autop^-)$. Hence, a path generating a word in $\ccalL^\phi_E(\auto{relax})$ may not satisfy the specification $\phi$, which is obvious since $\auto{relax}$ ignores the negative literals. Next, we consider the prefix part.  The following two statements show that extraction and pruning of the sub-NBA $\auto{subtask}$ for the prefix part do not empty the subset of words in $\ccalL^{\phi, v_0 \scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$ that can be generated by feasible paths satisfying Assumption~\ref{asmp:same}. The detailed proof can be found in Appendix~\ref{app:nonempty}-~\ref{app:sub-NBA}.
  \begin{lem}[($\auto{relax}$ and $\auto{subtask}$)]\label{prop:nonempty}
 After the extraction of the sub-NBA $\auto{subtask}$ in Section~\ref{sub-NBA:1}, it holds that  $\ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{relax}) = \ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask})$.
  \end{lem}

 \begin{lem}[($\auto{subtask}$ and $\auto{subtask}^-$)]\label{prop:sub-NBA}
After the pruning steps in Section~\ref{sub-NBA:2}, it holds that $\ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-) \subseteq \ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask})$. Additionally,  there is a path $\overline{\tau}^{\textup{pre}}$, modified from $\tau^{\textup{pre}}$ in Proposition~\ref{thm:nba}, that generates a word in $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$, i.e.,  $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-) \not= \emptyset$.
 \end{lem}

 %% Proposition~\ref{thm:nba} follows directly from  Lemma~\ref{prop:sub-NBA}.
 The following corollary is the direct consequence of the proof of Lemma~\ref{prop:sub-NBA}, which implies that we can construct a sub-NBA $\auto{subtask}^-$ based on $s_{\text{prior}}$ and $v_{\text{prior}}$ after passing through $\auto{subtask}^-$ for the prefix part.
 \begin{cor}[($s_{\text{prior}}$ and $v_\text{prior}$)]\label{prop:path}
  The  final configuration of the path $\overline{\tau}^{\textup{pre}}$ is $s_{\textup{prior}}$, same as that in the prefix path $\tau^{\textup{pre}}$, and the induced run  traverses $v_{\textup{prior}}$ right before $\vertex{accept}$, same as  $\rho^{\textup{pre}}$.
 \end{cor}
 The following proposition  draws the similar conclusion to Lemma~\ref{prop:nonempty} and~\ref{prop:sub-NBA} for the suffix part; see Appendix~\ref{app:sub-NBA2} for the proof.
 \begin{lem}[($\auto{subtask}$ and $\auto{subtask}^-$)]\label{prop:sub-NBA2}
   After the extraction and pruning  steps in Section~\ref{sec:suf_prune}, it holds that $\ccalL^{\phi,\vertex{accept}\scriptveryshortarrow \vertex{accept}}_E(\auto{relax}; s_{\textup{prior}},\vertex{prior}) = \ccalL^{\phi,\vertex{accept}\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}; s_{\textup{prior}}, \vertex{prior})$.  Additionally,  there is a path $\overline{\tau}^{\textup{suf}}$, modified from $\tau^{\textup{suf}}$ in Proposition~\ref{thm:nba}, that generates a word in  $\tilde{\ccalL}^{\phi, \vertex{accept} \scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-; s_{\textup{prior}}, \vertex{prior})$, i.e.,   $\tilde{\ccalL}^{\phi, \vertex{accept} \scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-; s_{\textup{prior}}, \vertex{prior}) \not= \emptyset$.
 \end{lem}

 Finally, Proposition~\ref{thm:nba} can be established by combining Lemmas~\ref{prop:sub-NBA} and~\ref{prop:sub-NBA2}.

\subsection{Completeness}\label{app:completeness}
To prove the completeness in Theorem~\ref{thm:completeness}, we first show the completeness of the prefix part and then the completeness as a whole. For each part, we analyze the feasibility of MILP for the high-level plans based on Proposition~\ref{thm:nba} and the feasibility of GMRPP for the low-level paths.
\subsubsection{Completeness of the prefix part:}
The following proposition states that, with mild assumptions, we can find a path that induces a run in $\autop$ connecting  $v_0$ and $\vertex{accept}$, which ensures the completeness of our method for specifications in \ltlx that can be satisfied by finite-length paths.
\begin{prop}[(Completeness of the prefix part)]\label{thm:prefix}
Given a workspace satisfying Assumption~\ref{asmp:env} and a valid specification $\phi\in \textit{LTL}_{-\bigcirc}^\chi$, if there exists a path $\tau = \tau^\textup{pre} [\tau^\textup{suf}]^\omega$  inducing a restricted accepting run $\rho =  \rho^\textup{pre} [\rho^\textup{suf}]^\omega = v_0, \ldots, \vertex{prior}, \vertex{accept} [\vertex{next}, \ldots, \vertex{prior}', \vertex{accept}]^\omega$ in $\autop$ and satisfying Assumption~\ref{asmp:same}. We can find a robot path $\tilde{\tau}^{\textup{pre}}$ that generates a word $\tilde{w}^{\textup{pre}}$ which induces a run $\tilde{\rho}^{\textup{pre}}$ in $\autop$  connecting the pair $v_0$ and $\vertex{accept}$. %% Furthermore, the run $\tilde{\rho}^{\textup{pre}}$ satisfies the requirements on the prefix part in conditions~\hyperref[cond:a]{\it (a)}-\hyperref[cond:e]{\it (d)} in Definition~\ref{defn:run} and the path $\tilde{\tau}^{\textup{pre}}$ satisfies conditions~\hyperref[asmp:a]{\it (a)}-\hyperref[asmp:b]{\it (b)} in Assumption~\ref{asmp:same}.
\end{prop}
 %% The detailed proof can be found in Appendix~\ref{app:prefix}.
  %% The Assumption~\ref{asmp:env} on the workspace ensures the completeness when there are negative atomic propositions in \ltlx, which is not necessary when there do not exist negative atomic propositions in \ltlx.
%% \begin{cor}\label{thm:prefix_no_negative}
%% If $\tilde{\ccalL}_E^\phi(\autop) \neq \emptyset$ and there are not negative atomic propositions in the \ltlx specification $\phi$, we can find an executable robot path $\tilde{\tau}^{\textup{pre}}$ that generates a word $\tilde{w}^{\textup{pre}}$ which induces a run $\tilde{\rho}^{\textup{pre}}$ in $\autop$ that connects a certain pair of initial and accepting vertices. Furthermore, the run $\tilde{\rho}^{\textup{pre}}$ satisfies the requirements on the prefix part in conditions~\hyperref[cond:a]{\it (a)}-\hyperref[cond:d]{\it (d)} in Definition~\ref{defn:run} and the path $\tilde{\tau}^{\textup{pre}}$ satisfies conditions~\hyperref[asmp:a]{\it (a)}-\hyperref[asmp:b]{\it (b)} in Assumption~\ref{asmp:same}.
%%   %% belonging to $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\autop)$, where $v_0$ and $\vertex{accept}$ is a certain pair of initial and accepting vertices. That is, the path $\tau$ can induce a run in $\autop$ that the a prefix part of a restricted accepting run.
%% \end{cor}

We first provide the following three lemmas and then combine with Proposition~\ref{thm:nba} to conclude the proof of Proposition~\ref{thm:prefix}.
Lemma~\ref{prop:feasibility} states that, if the poset $P$ is inferred from a set of simple paths that includes  a  simple path associated with a feasible prefix path, then the MILP formulation in Section~\ref{sec:milp} that is based on this poset $P$ is feasible; Lemma~\ref{prop:run} states that a simple path in $\auto{subtask}^-$ can be extracted from the solution to the MILP with certain temporal properties, and Lemma~\ref{prop:valid} states that the  sequence of instances of GMRPP from the extracted
simple path is feasible.
 \begin{lem}[(Feasibility of the MILP)]\label{prop:feasibility}
If there exists a path $\overline{\tau}^{\textup{pre}}$ generating a finite word $\overline{w}^{\textup{pre}} \in \tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$, and the word $\overline{w}^{\textup{pre}}$ induces a simple path $\overline{\theta}^{\textup{pre}}$ in $\auto{subtask}^-$ belonging to the set of simple paths from which the  poset $P$ is inferred,
then  in Section~\ref{sec:milp} the  MILP formulation based on this poset $P$  is feasible. %% with any positive integer $M_{\textup{min}}$.
 \end{lem}
    The detailed proof can be found in Appendix~\ref{app:feasibility}-\ref{app:milp}. In essence, the path $\overline{\tau}^{\textup{pre}}$  generating the word $\overline{w}^{\textup{pre}}$ can give rise to a high-level plan  satisfying constraints~\eqref{eq:1}-\eqref{eq:lastclause} in Appendix~\ref{app:appendix_prefix_milp}.

\begin{lem}[(Properties of the simple path)]\label{prop:run}
  If the MILP formulation based on the poset $P$ produces a solution, then in Appendix~\ref{sec:run} a simple path $\tilde{\theta}$ that is within the set of simple paths from which the poset $P$ is inferred, can be extracted from the sub-NBA $\auto{subtask}^-$. Additionally, the following properties hold for subtasks in the simple path $\tilde{\theta}$:
  \begin{noindlist}
  \item \label{property:a} The first subtask in the simple path $\tilde{\theta}$ is activated at time 0;
    \item \label{property:b}  For any subtask  $e \in \tilde{\theta}$, if its starting vertex has a self-loop, then the completion time of the subtask $e$ is no earlier than the activation of its starting vertex label, and at most one time instant later than the completion of its starting  vertex label;
  \item \label{property:c}  For any two consecutive subtasks  $e, e'\in \tilde{\theta}$, the latter subtask $e'$ is activated at most one time instant later than the completion of the former subtask $e$.
  \end{noindlist}
\end{lem}

The detailed proof can be found in Appendix~\ref{app:run}. Property~\ref{property:a} guarantees the initialization of the sequence of subtasks in $\tilde{\theta}$, property~\ref{property:b} ensures that each subtask in $\tilde{\theta}$ is correctly implemented, and property~\ref{property:c} prevents gaps between the transition of two consecutive subtasks. Altogether, these three properties establishes that once the first subtask is activated at time 0, each subtask is completed successfully and inter-subtasks transition occurs seamlessly, until the completion of the last subtask. Note that the extracted simple path $\tilde{\theta}$ may not be identical to that induced by the word $\overline{w}^{\text{pre}} \in \tilde{\ccalL}_E^{\phi, v_0 \scriptveryshortarrow \vertex{accept}} (\auto{subtask}^-)$ in Lemma~\ref{prop:feasibility}. The following Lemma~\ref{prop:valid} states that low-level  paths can be generated based on the solution to the MILP, whose  proof can be found in Appendix~\ref{app:valid}.
 \begin{lem}[(Feasibility of the GMRPP)]\label{prop:valid}
 Assuming the workspace satisfies Assumption~\ref{asmp:env}, then in Appendix~\ref{sec:mapp} the sequence of instances of GMRPP  for the simple path $\tilde{\theta}$ extracted  based on the solution to the MILP for the prefix part, is feasible. That is, each instance of GMRPP is feasible for some horizon $T$'s.
 \end{lem}
 Combining Proposition~\ref{thm:nba} with Lemmas~\ref{prop:feasibility}-\ref{prop:valid}, we finalize the proof of Proposition~\ref{thm:prefix}. Proposition~\ref{thm:prefix} assumes the existence of a feasible path,  then by  Proposition~\ref{thm:nba},  $\tilde{\ccalL}_E^{\phi, v_0 \scriptveryshortarrow \vertex{accept}}(\auto{subtask}^-) \neq \emptyset$, a path $\overline{\tau}^{\text{pre}}$ exists that generates a word $\overline{w}^{\text{pre}} \in \tilde{\ccalL}_E^{\phi, v_0 \scriptveryshortarrow \vertex{accept}}(\auto{subtask}^-) $.  Because in Section~\ref{sec:sort} we iterate all pairs of initial and accepting vertices whose total length is not infinite, we will deal with the NBA $\auto{subtask}^-$ associated with this pair. In Section~\ref{sec:poset}, we collect all simple paths  connecting $v_0$ and $\vertex{accept}$, infer  posets from each subset of equivalent simple paths and treat each simple path as a poset if no such poset exists, so by iterating over all posets, we will formulate the MILP over the poset including the simple path induced by the path $\overline{\tau}^{\text{pre}}$. According to Lemma~\ref{prop:feasibility}, this MILP has a solution. Then, following Lemma~\ref{prop:valid}, we get that a path $\tilde{\tau}^{\textup{pre}}$ can be obtained by concatenating paths from each instance of GMRPP since the final locations of the previous instance of GMRPP are identical to the initial locations of the immediately following one, which completes the proof.
 %% see Appendix~\ref{app:prefix} for the detailed  proof.

\subsubsection{Completeness as a whole:}
Similar to Lemma~\ref{prop:feasibility}, we show the feasibility of the MILP formulation for the suffix part; see Appendix~\ref{app:suffix_feasibility} for the detailed proof.
\begin{lem}[(Feasibility of the MILP)]\label{prop:suffix_feasibility}
Considering a valid specification $\phi\in \textit{LTL}_{-\bigcirc}^\chi$, given  $s_{\textup{prior}}$ and $v_{\textup{prior}}$, which are the final configuration of the path $\tau^{\textup{pre}}$ and the vertex before $\vertex{accept}$ in the  run $\rho^{\textup{pre}}$ in Theoprem~\ref{thm:completeness},  if there exists a path $\overline{\tau}^{\textup{suf}}$ generating a finite word $\overline{w}^{\textup{suf}} \in \tilde{\ccalL}^{\phi,\vertex{accept}\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-; s_{\textup{prior}}, v_{\textup{prior}})$, and the word $\overline{w}^{\textup{suf}}$ induces a simple path  $\overline{\theta}^{\textup{suf}}$ blonging to  the set of simple paths  from which the poset $P$ is inferred,
  then the formulation of MILP  based on this poset $P$, composed of constraints~\eqref{eq:1}-\eqref{eq:same} in Appendix~\ref{app:appendix_prefix_milp} and constraints~\eqref{eq:one_suffix}-\eqref{eq:same_suffix} in Appendix~\ref{app:appendix_suffix_milp},  is feasible.
\end{lem}

Next, the results in Lemmas~\ref{prop:run} and~\ref{prop:valid} apply to the suffix part.  Finally, combining Propositions~\ref{thm:nba} and~\ref{thm:prefix} with Lemma~\ref{prop:suffix_feasibility}, we are ready to establish the completeness of our proposed method; see Appendix~\ref{app:completeness_}. Although both Proposition~\ref{thm:prefix} and Lemma~\ref{prop:suffix_feasibility} address larger class of {\it LTL}$_{-\bigcirc}^\chi$, Lemma~\ref{prop:suffix_feasibility} is based on the condition that the suffix path $\overline{\tau}^{\text{suf}}$ exists, which allocates the same fleet of robots to satisfy the same induced atomic propositions as the assumed prefix path $\overline{\tau}^{\text{pre}}$. However,  the prefix path $\tilde{\tau}^{\text{pre}}$ in Proposition~\ref{thm:prefix} is obtained by solving the MILP, which may allocate another different fleet of robots than $\overline{\tau}^{\text{pre}}$ to satisfy the same induced atomic propositions. This undermines the existence of such a suffix path and further the satisfaction of constraint~\eqref{eq:same} regarding same-$\ag{i}{j}$ constraints. Therefore, we restrict the specification to  \ltlz in the proof.


\subsection{Detailed proofs}\label{app:proofforproof}
\subsubsection{Proof of Lemma~\ref{prop:prune}:}\label{app:prune}

%% We first show that $\ccalL_E^\phi(\autop^-) = \ccalL^\phi_E(\autop)$ holds after the first 6 steps, then states that this equivalence is not affected by the last step. First, steps~\hyperref[prune:exclusion1]{\it (1)}-\hyperref[prune:violation2]{\it (6)} in Section~\ref{sec:prune} merely  remove infeasible clauses and merge redundant literals. Obviously,  removing  infeasible clauses does not have any effect on the realizable words in $\ccalL_E(\autop)$. Morevoer, given any remaining clause $\ccalC$ in $\autop$, merging redundant literals results in a clause, denoted by $\ccalC'$, in $\autop^-$ that is a subformula of the original one, therefore, the satisfaction of $\ccalC$ implies the satisfaction of $\ccalC'$. On the other hand, the satisfaction of a literal in $\ccalC'$ leads to the satisfaction of the same literal in $\ccalC$ and the merged literals because of this literal, therefore, the satifaction of $\ccalC'$ implies the satisfaction of $\ccalC$. Thus, $\ccalC$ and $\ccalC'$ are logically equivalent, which implies that $\autop$ and $\autop^-$ are logically equivalent in terms of realizability, that is, any realizable words can be accepted by both $\autop$ and $\autop^-$.  %% Therefore, $\autop$ and $\autop^-$ are logically equivalent after steps~\hyperref[prune:exclusion1]{\it (1)}-\hyperref[prune:violation2]{\it (6)}.
%% Therefore, after steps~\hyperref[prune:exclusion1]{\it (1)}-\hyperref[prune:violation2]{\it (6)}, we conclude that  $\ccalL_E(\autop^-)= \ccalL_E(\autop)$. Next, we prove that $\ccalL_E^\phi(\autop^-) = \ccalL^\phi_E(\autop)$ after steps~\hyperref[prune:exclusion1]{\it (1)}-\hyperref[prune:violation2]{\it (6)}.

%% First, we show that $\ccalL_E^\phi(\autop^-) \subseteq \ccalL^\phi_E(\autop)$. Due to $\ccalL_E^\phi(\autop^-) \subseteq \ccalL_E(\autop^-)$ and $\ccalL_E(\autop^-)= \ccalL_E(\autop)$,  any word $w$ in $\ccalL_E^\phi(\autop^-)$ is also in  $ \ccalL_E(\autop)$. Furthermore, because $w \in \ccalL_E^\phi(\autop^-)$, the corresponding run in $\autop$ of the run that $w$ induces in $\autop^-$ is a restricted accepting run. This restricted accepting run  can be directly induced by $w$ in $\autop$ since $w \in \ccalL_E(\autop)$ and $\autop^-$ and $\autop$ are logically equivalent in terms of realizability, making $w \in \ccalL^\phi_E(\autop)$.
%% Thus, $\ccalL_E^\phi(\autop^-) \subseteq \ccalL^\phi_E(\autop)$. Next, we show that the reverse also holds, i.e., $\ccalL^\phi_E(\autop) \subseteq \ccalL_E^\phi(\autop^-)$. For any word $w \in \ccalL^\phi_E(\autop)$, we have that $w \in \ccalL_E(\autop)  = \ccalL_E(\autop^-)$. Since $w$ is in $\ccalL^\phi_E(\autop)$, the induced run in $\autop$ is a restricted accepting run. We can map this run to $\autop^-$ and the mapped run can be induced by $w$ as well, since $w = \ccalL_E(\autop^-)$ and $\autop$ and $\autop^-$ are logically equivalent in terms of realizability. Thus, $w \in \ccalL_E^\phi(\autop^-)$ and further $\ccalL^\phi_E(\autop) \subseteq \ccalL_E^\phi(\autop^-)$. Therefore, $\ccalL_E^\phi(\autop^-) = \ccalL^\phi_E(\autop) $.

The basic idea is that the pruning steps in Section~\ref{sec:prune} does not affect any restricted accepting runs. First,  removing infeasible transitions and unreachable vertices will not exclude any realizable words. Therefore, the set of realizable words $\ccalL_E(\autop)$ does not change after this operation. Second, according to condition \hyperref[cond:c]{\it (c)} in Definition~\ref{defn:run}, any restricted  accepting run  does not contain vertices without self-loops except  initial and accepting vertices. Thus, removing such vertices  will not affect the  set of restricted accepting runs in $\autop$. Third, by condition~\hyperref[cond:d]{\it (d)}, any edge whose label does not strongly imply its end vertex label, except that its end vertex is an accepting vertex,  can not appear in any restricted accepting run, thus removing such edges does not affect the set of restricted accepting runs, either.  We conclude that operations in Section~\ref{sec:prune}  do not affect the set of restricted accepting runs in $\autop$ that can be induced by the realizable words  in $\ccalL^\phi_E(\autop)$. Equivalently, these restricted accepting runs also exist in $\autop^-$ as accepting runs, which implies that $\ccalL^\phi_E(\autop^-) = \ccalL^\phi_E(\autop)$, completing the proof.


%% which leads to that the runs in $\autop^-$ that corrspond to these restricted accepting runs are not affected, either. Hence, $\ccalL^\phi_E(\autop^-)$ does not change. Due to also  that $\ccalL^\phi_E(\autop)$ is irrelevant to any processing, we conclude that $\ccalL^\phi_E(\autop^-) = \ccalL^\phi_E(\autop)$, completing the proof.
\subsubsection{Proof of Lemma~\ref{prop:inclusion}:}\label{app:inclusion}
The inclusion is straightforward in that, given a clause $\ccalC$ in $\autop^-$, the clause $\ccalC'$ in $\auto{relax}$ obtained by replacing negative literals in $\ccalC$ with $\top$ is a subformula of the original clause $\ccalC$. In other words, the satisfaction of the original clause $\ccalC$ implies the satisfaction of $\ccalC'$, which implies that any realizable word $w$ in $\ccalL_E(\autop^-)$ belongs to $\ccalL_E(\auto{relax})$. Thus, any word $w \in \ccalL^\phi_E(\autop^-)  \subseteq  \ccalL_E(\autop^-)$ belongs to $\ccalL_E(\auto{relax})$. Next, we prove that indeed any word $\tilde{w} \in \ccalL^\phi_E(\autop^-)$ belongs to  $\ccalL^\phi_E(\auto{relax})$ inside $ \ccalL_E(\auto{relax})$.

Because $\tilde{w} \in \ccalL^\phi_E(\autop^-)$, it can induce  a run in $\autop^-$ whose corresponding run in $\autop$ is a restricted accepting run. Also because $\tilde{w}$ is in $\ccalL_E(\auto{relax})$ and clauses in $\auto{relax}$ are the subformulas of the clauses in $\autop^-$, $\tilde{w}$ can induce the same run in $\auto{relax}$ as the run in $\autop^-$ (same sequence of vertices). Additionally, these two runs correspond to the same restricted accepting run in $\autop^-$. Therefore, $\tilde{w} \in \ccalL^\phi_E(\auto{relax})$, i.e.,  $\ccalL^\phi_E(\autop^-)\subseteq \ccalL^\phi_E(\auto{relax})$, completing the proof.

%% \subsubsection{Proof of Corollary~\ref{prop:equality}:} \label{app:equality}
%%  We first show that  $\Omega_E^\phi(\autop^-) \subseteq  \Omega_E^\phi(\auto{relax})$. For any run $\rho$ in $\Omega_E^\phi(\autop^-)$, we denote by $w  \in  \ccalL^\phi_E(\autop^-)$ a word that induces it.  Because  $\ccalL^\phi_E(\autop^-) \subseteq \ccalL^\phi_E(\auto{relax})$ by Lemma~\ref{prop:inclusion}, we have that $w \in\ccalL^\phi_E(\auto{relax})$. Furthermore, it can induce the same run in $\auto{relax}$ as $\rho$  in $\autop^-$ since clauses in $\auto{relax}$ are implied by  clauses in $\autop^-$, i.e., $\rho \in \Omega_E^\phi(\auto{relax}) $. Therefore, $\Omega_E^\phi(\autop^-) \subseteq  \Omega_E^\phi(\auto{relax})$.

%%  Moreover, the inclusion relation $\Omega_E^\phi(\auto{relax}) \subseteq \Omega^\phi(\autop^-)$ is straightforward. Because $\auto{relax}$ and $\autop^-$ are graphically equivalent, any run  $\rho \in \Omega_E^\phi(\auto{relax})$ in  $\auto{relax}$ is also in $\autop^-$, i.e., $\rho \in \Omega^\phi(\autop^-)$, Thus, $\Omega_E^\phi(\auto{relax}) \subseteq \Omega^\phi(\autop^-)$, completing the proof.

   \subsubsection{Proof of Lemma~\ref{prop:nonempty}:}\label{app:nonempty}
Given the pair of initial and accepting vertices, $v_0$ and $\vertex{accept}$, the corresponding sub-NBA $\auto{subtask}$ is composed of all vertices and edges in $\auto{relax}$ that are in some paths that connect $v_0$ and $\vertex{accept}$, except that  all other initial and accepting vertices other than $v_0$ and $\vertex{accept}$ are removed, and the self-loop of $v_0$ (if exists) is removed if the initial robot locations do not satisfy its corresponding vertex label in $\autop$, along with the removing of  outgoing edges of the initial vertex if the initial robot locations do not satisfy their corresponding edge labels in $\autop$; see Section~\ref{sub-NBA:1}. %% {\it (\Alph{mycounter}$_3$)} if $\vertex{accept}$ has a self-loop, any incoming edge of $\vertex{accept}$ is removed if the corresponding edge label in $\autop$ does not strongly  imply $\gamma_{\phi}(\vertex{accept})$ (see  Section~\ref{sub-NBA:1}).

 First, according to condition \hyperref[cond:b]{\it (b)} in the Definition~\ref{defn:run}, the prefix part  will not include more than one initial vertices and more than one accepting vertices. Since $\ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{relax})$ are related to the initial and accepting vertices $v_0$ and $\vertex{accept}$, removing other initial and accepting vertices does not affect $\ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{relax})$.

Second, any word $w$ that at the beginning satisfies the label of the initial vertex $v_0$ whose self-loop is removed or labels of outgoing edges that are removed, cannot be generated by feasible paths since initial robot locations violate these labels. Therefore, any such word $w$ does not belong to $\ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{relax})$.  The removing of self-loops and outgoing edges  does not affect $\ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{relax})$, completing the proof.

%% {\it (\Alph{mycounter}$_3$)} Similarly, if $\vertex{accept}$ has a self-loop, according to condition~\hyperref[cond:f]{\it (f)} in the Definition~\ref{defn:run}, any restricted accepting run with $\vertex{accept}$ constituting the suffix part requires that the incoming edge label of $\vertex{accept}$ strongly implies the label $\gamma_{\phi}(\vertex{accept})$. Therefore, removing the incoming edge whose label does not strongly imply $\gamma_\phi(\vertex{accept})$ does not affect $\ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{relax})$.


\subsubsection{Proof of Lemma~\ref{prop:sub-NBA}:}\label{app:sub-NBA}
The inclusion relation is trivial since $\auto{subtask}^-$ is obtained by removing edges from  $\auto{subtask}$  that is decomposable according to the sequential triangle property (see Definition~\ref{defn:st}). In what follows, we focus on the non-emptiness of $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$. We first show that the given prefix path $\tau^{\text{pre}}$ (see Proposition~\ref{thm:nba}) can generate a word in $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask})$, and then show that  based on $\tau^{\text{pre}}$ another prefix path $\overline{\tau}^{\text{pre}}$ can be synthesized to generate a word in $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$.

To show that the given prefix path $\tau^{\text{pre}}$ can generate a word in $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask})$,  we prove that results in Lemmas~\ref{prop:prune}-\ref{prop:nonempty} can be applied to languages $\tilde{\ccalL}(\cdot)$ that consider Assumption~\ref{asmp:same}. Note that  Assumption~\ref{asmp:same} is regarding how a restricted accepting run is implemented by robots. For an accepting  word belonging to two languages $\ccalL_E^\phi(\ccalA_1)$ and $\ccalL_E^\phi(\ccalA_2)$, if it can be generated by robot paths that satisfy Assumption~\ref{asmp:same}, then this word should belong to two languages $\tilde{\ccalL}_E^\phi(\ccalA_1)$ and $\tilde{\ccalL}_E^\phi(\ccalA_2)$. Therefore, how an accepting word is implemented does not affect the relations between languages. We can get that
$ \tilde{\ccalL}_E^\phi(\ccalA_\phi^-) = \tilde{\ccalL}_E^\phi(\ccalA_\phi)$ by Lemma~\ref{prop:prune},
$\tilde{\ccalL}_E^\phi(\ccalA_\phi^-) \subseteq \tilde{\ccalL}_E^\phi(\auto{relax})$ by Lemma~\ref{prop:inclusion},
$\tilde{\ccalL}_E^{\phi,v_0\scriptveryshortarrow \vertex{accept}}(\auto{relax}) =  \tilde{\ccalL}_E^{\phi,v_0\scriptveryshortarrow \vertex{accept}}(\auto{subtask})$ by Lemma~\ref{prop:nonempty} and  $\tilde{\ccalL}_E^{\phi,v_0\scriptveryshortarrow \vertex{accept}}(\auto{subtask}^-) \subseteq \tilde{\ccalL}_E^{\phi,v_0\scriptveryshortarrow \vertex{accept}}(\auto{subtask})$ at the beginning of this proof.


Next, because the accepting  word $w= w^\text{pre} [w^\text{suf}]^\omega$  generated by the path $\tau= \tau^\text{pre} [\tau^\text{suf}]^\omega$ induces a restricted accepting run and satisfies Assumption~\ref{asmp:same} (see Proposition~\ref{thm:nba}), i.e., $w \in \tilde{\ccalL}_E^\phi(\ccalA_\phi)$, we have that  $w \in \tilde{\ccalL}_E^\phi(\ccalA_\phi^-)$ and further  $w^{\text{pre}} \in \tilde{\ccalL}_E^{\phi,v_0\scriptveryshortarrow \vertex{accept}}(\auto{relax})$.
Therefore, $w^{\text{pre}} \in \tilde{\ccalL}_E^{\phi,v_0\scriptveryshortarrow \vertex{accept}}(\auto{subtask})$, that is, $\tau^{\text{pre}}$ generates a word in $\tilde{\ccalL}_E^{\phi,v_0\scriptveryshortarrow \vertex{accept}}(\auto{subtask})$. In what follows, we synthesize another prefix path $\overline{\tau}^{\text{pre}}$ based on $\tau^{\text{pre}}$.




First, consider 3 different vertices $v_1, v_2, v_3$ in $\auto{subtask}$ that have the ST property. Assume $\auto{subtask}$ is in the vertex $v_1$, we show that, given robot configuration $s$ in a path that completes the subtask $(v_1, v_3)$, i.e., driving the transition to vertex $v_3$, we can  simply repeat this robot configuration one more time so that the sub-NBA $\auto{subtask}^-$ reaches $v_3$ by  traversing edges $(v_1, v_2)$ and $(v_2, v_3)$.
Specifically, according to Definition~\ref{defn:st} regarding ST property, since the robot configuration $s$ satisfies the edge label $\gamma(v_1, v_3)$ and $\gamma(v_1, v_3) = \gamma(v_1, v_2) \wedge \gamma(v_2, v_3)$, we have that the robot configuration $s$ satisfies the edge label $\gamma(v_1, v_2)$. Thus, $s$ can drive the transition to vertex $v_2$ from $v_1$. At the next time instant, if robots remain idle, the edge label $\gamma(v_2, v_3)$ can be satisfied since the robot configuration $s$ satisfies $\gamma(v_1, v_3)$ and $\gamma(v_1, v_3)$ implies $\gamma(v_2, v_3)$. Therefore, by simply repeating this robot configuration, the sub-NBA $\auto{subtask}^-$ traverses edges $(v_1, v_2)$ and $(v_2, v_3)$ to reach $v_3$, without satisfying the vertex label $\gamma(v_2)$.
%% %% Furthermore, the construction of the path segment $\tau'_{\text{seg}}$ ensures that the Assumption~\ref{asmp:same} is met since the robots remain idle after satisfying the  edge label $\gamma(v_1, v_2)$.

Based on this observation, we continue showing the non-emptiness of $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$. With a slight abuse of notation, let $\rho^{\text{pre}}$ denote the run in $\auto{subtask}$ induced by the word $w^{\text{pre}}$. We assume the run $\rho^{\text{pre}}$ traverses an edge $(v_1, v_3)$ in $\auto{subtask}$ corresponding to a composite subtask, which  will be removed according to ST property. Otherwise, the run $\rho^{\text{pre}}$ will persist in $\auto{subtask}^-$. When the run $\rho^{\text{pre}}$ traverses a composite edge, we locate the robot configuration $s$ in $\tau^{\text{pre}}$ that enables this composite subtask, let robots remain idle for one time instant as discussed above, and then continue along the path $\tau^{\text{pre}}$. Let $\overline{\tau}^{\text{pre}}$ denote the new path, which also meets conditions~\hyperref[asmp:a]{\it (a)}-\hyperref[asmp:b]{\it (b)} in Assumption~\ref{asmp:same} since robots just stay put for one time instant. Furthermore, the path $\overline{\tau}^{\text{pre}}$  generates a word $\overline{w}^{\text{pre}}$ that induces a run $\overline{\rho}^{\text{pre}}$ in $\auto{subtask}^-$  traversing the two elementary edges $(v_1, v_2)$ and $(v_2, v_3)$.

Next, we prove that based on the condition that $\rho^{\text{pre}}$ is a prefix part that  meets the requirements on the prefix part in conditions~\hyperref[cond:a]{\it (a)}-\hyperref[cond:d]{\it (d)}, so is the run  $\overline{\rho}_\phi^{\text{pre}}$, which is the corresponding run of $\overline{\rho}^{\text{pre}}$. Observe that $\overline{\rho}^{\text{pre}}$ differ from $\rho^{\text{pre}}$ only in that $\rho^{\text{pre}}$ traverses edge $(v_1, v_3)$ while $\overline{\rho}^{\text{pre}}$ traverses edges $(v_1, v_2)$ and $(v_2, v_3)$ consecutively. Apparently, the run $\overline{\rho}^{\text{pre}}_{\phi}$ meets conditions~\hyperref[cond:a]{\it (a)}-\hyperref[cond:c]{\it (c)} in Definition~\ref{defn:run}.  Furthermore, $\gamma_{\phi} (v_1, v_2) \simplies_s \gamma_{\phi} (v_2)$ and $\gamma_{\phi}(v_2, v_3) \simplies_s \gamma_{\phi}(v_3)$; otherwise, they are pruned in Section~\ref{sec:prune}. Thus, the run $\overline{\rho}^{\text{pre}}_\phi$  satisfies condition \hyperref[cond:d]{\it (d)}, that is, the word $\overline{w}^{\text{pre}}$ generated by $\overline{\tau}^{\text{pre}}$ belongs to $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$, completing the proof.%% \stepcounter{mycounter}
%% Moreover, (\Alph{mycounter}$_1$) if $v_3= \vertex{accept}$, according to condition {\it (e)} in Definition~\ref{defn:st}, $\gamma_{\phi}(v_3) = \top$ if $(v_1, v_3)$ is removed. In this case, the run  $\rho'_{\phi}$ itself is a restricted accepting run, since $\gamma_{\phi}(\vertex{accept})=\top$ is satisfied unconditionally.  Thus, we also have $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-) \neq \emptyset$.
%% (\Alph{mycounter}$_2$) Finally, if $v_3 = \vertex{accept}$ and $\gamma_{\phi}(v_3)\neq \top$, we do not remove the subtask $(v_1, v_3)$. Therefore, $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask})$ is not affected, which completes the proof.

\subsubsection{Proof of Lemma~\ref{prop:sub-NBA2}:}\label{app:sub-NBA2}
The proof is much similar to proofs of Lemma~\ref{prop:nonempty} and~\ref{prop:sub-NBA}. Recall in Section~\ref{sec:suf_prune}, to obtain the sub-NBA $\auto{subtask}$, we remove  all other accepting vertices from $\auto{relax}$ and all initial vertices without self-loops  any outgoing edge of $\vertex{accept}$ if the corresponding label is not implied by the label $\gamma_\phi(\vertex{prior}, \vertex{accept})$, which is the  edge label in the NBA $\autop$ that corresponds to the last completed subtask in the prefix part, and  any incoming edge of $\vertex{accept}$ if the corresponding label is not implied by the label $\gamma_\phi(\vertex{prior}, \vertex{accept})$. According to condition \hyperref[cond:b]{\it (b)} and~\hyperref[cond:f]{\it (f)} in Definition~\ref{defn:run}, the suffix part does not traverse these removed vertices and edges. Therefore, removing these vertices and edges does not affect $\ccalL^{\phi,\vertex{accept} \scriptveryshortarrow \vertex{accept}}_E(\auto{relax}; s_{\textup{prior}}, \vertex{prior})$, i.e., $\ccalL^{\phi,\vertex{accept} \scriptveryshortarrow \vertex{accept}}_E(\auto{relax};  s_{\textup{prior}}, \vertex{prior}) = \ccalL^{\phi,\vertex{accept} \scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}; s_{\textup{prior}}, \vertex{prior})$.

To prove that $\tilde{\ccalL}^{\phi,\vertex{accept} \scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-; s_{\textup{prior}},\vertex{prior}) \neq \emptyset$, we follow similar steps to prove  Lemma~\ref{prop:sub-NBA}. First, we get that $\tau^{\text{suf}}$ (see Proposition~\ref{thm:nba}) can generate a word in $\tilde{\ccalL}^{\phi,\vertex{accept} \scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}; s_{\textup{prior}},\vertex{prior})$, similar to  $\tau^{\text{pre}}$ generating a word in $\tilde{\ccalL}^{\phi,v_0 \scriptveryshortarrow \vertex{accept}}_E(\auto{subtask})$. Second, we can obtain the path $\overline{\tau}^{\text{suf}}$ from $\tau^{\text{suf}}$ by  repeating the robot configuration one more time that completes a composite subtask, the resulting run traverses two elementary edges successively, driving the transition to the same vertex as that reached by traversing a composite edge.
Since $\vertex{accept}$ does not have a self-loop,  when $v_3 = \vertex{accept}$, we will not remove the composite edge $(v_1, v_3)$ from $\auto{subtask}^-$ for the  suffix part (see Definition~\ref{defn:st}). Thus, we can reuse the  robot configuration that enables the edge $(v_1, \vertex{accept})$, which meets condition~\hyperref[asmp:c]{\it (c)} in Assumption~\ref{asmp:same} that robots return to $s_{\text{prior}}$, completing the proof.

%\subsubsection{Proof of Lemma~\ref{thm:nba}}\label{app:nba}


%% Furthermore, the path $\overline{\tau}^{\text{pre}}$ that generates $\overline{w}^\text{pre}$ differs from $\tau^\text{pre}$ (which generates $w^\text{pre}$) in that $\overline{\tau}^{\text{pre}}$ contains repetitions of some robot configurations, so the final robot configurations in these two paths are identical.


%% Therefore, the word $\overline{w}^\text{pre} [w^\text{suf}]^\omega$ that are generated by  the concatenated path $\overline{\tau}^{\text{pre}}[\tau^\text{suf}]^\omega$ also belongs to $\tilde{\ccalL}_E^\phi(\ccalA_\phi)$. If follows that $w^\text{suf} \in \tilde{\ccalL}_E^{\phi,\vertex{accept}\scriptveryshortarrow \vertex{accept}}(\auto{subtask})$ where $\auto{subtask}$ for the suffix part is built on the identical  final locations of $\overline{\tau}^\text{pre}$ and ${\tau}^\text{pre}$. By Corollary~\ref{prop:sub-NBA2}, we have that $\tilde{\ccalL}_E^{\phi, \vertex{accept} \scriptveryshortarrow \vertex{accept}}(\auto{subtask}^-; \vertex{prior}) \neq \emptyset$, completing the proof.


\subsubsection{Proof of Lemma~\ref{prop:feasibility}:}\label{app:feasibility}
Given a path $\overline{\tau}^\text{pre}$ that generates a finite word $\overline{w}^\text{pre} \in \tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$ inducing a simple path $\overline{\theta}^{\text{pre}}$ in $\auto{subtask}^-$, we first show that it can give rise to another path so that the starting  vertex label of each subtask in the simple path $\overline{\theta}^{\text{pre}}$, if exists, is satisfied at least once. This is because constraint~\eqref{eq:c} encodes that exactly one clause in any label (vertex or edge) of each subtask is satisfied. Since the new path is very similar to the given path, with a slight abuse of notation, we still use $\overline{\tau}^{\text{pre}}$ to denote the new path. Given the new path $\overline{\tau}^\text{pre}$,  our goal is to show that $\overline{\tau}^\text{pre}$ gives rise to a high-level plan that satisfies the MILP formulation. To this end, we first obtain an {\it essential word} $w^*$ based on the word $\overline{w}^\text{pre}$  generated by the path $\overline{\tau}^\text{pre}$, such that the path $\overline{\tau}^\text{pre}$ can also generate the essential word and the essential word $w^*$ is the tightest word that can induce the same run $\overline{\rho}^\text{pre}$ as $\overline{w}^\text{pre}$ does; see Appendix~\ref{app:word}. Then, we show that the essential word $w^*$ can produce a graph that is a subgraph of the routing graph $\ccalG$ built in Section~\ref{sec:graph}; see Appendix~\ref{app:graph}. Finally, we show that the subgraph  can be viewed as a graphical solution to the MILP; see Appendix~\ref{app:milp}.


The construction of new path is straightforward.  According to condition~\hyperref[cond:d]{\it (d)} in Definition~\ref{defn:run}, for any subtask $e$ in the simple path $\overline{\theta}^{\text{pre}}$ that is not the first one to be completed, its starting vertex label  is  strongly implied by the edge label of the subtask $e'$ immediately preceding $e$. Therefore, when the  edge label of subtask $e'$ is enabled, robots can remain idle for one time instant to satisfy the starting vertex label of subtask $e$. Also, the satisfied clause in the edge label of $e'$ implies the satisfied clause in the starting vertex label of subtask $e$. On the other hand, if subtask $e$ is the first subtask in the simple path $\overline{\theta}^{\text{pre}}$, and also the vertex $v_0$ has a self-loop, then the initial robot locations satisfy the label of $v_0$. Similarly robots can remain idle to make the label of $v_0$ true at least once. We still use $\overline{\tau}^\text{pre}$ to denote the new path as the only change is the idleness of robots. The new path $\overline{\tau}^\text{pre}$ still generates a word belonging to $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$ and induces the same simple path $\overline{\theta}^{\text{pre}}$ as the original path. Note that $\overline{\theta}^{\text{pre}}$ is a linear extension of the poset $P$ based on which the MILP is formulated. No two subtasks are completed at the same time in the path $\overline{\tau}^\text{pre}$.


\subsubsection{Construction of the essential word:}\label{app:word}
Given the path $\overline{\tau}^\text{pre}$ that induces the simple path $\overline{\theta}^{\text{pre}}$, let $\overline{w}^\text{pre} = \sigma_0 \sigma_1 \sigma_2\ldots \sigma_k$ denote the generated finite  word in $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$, and $\overline{\rho}^\text{pre}=v_0 v_1 v_2\ldots \vertex{accept}$  denote the induced run in $\auto{subtask}^-$. Next we obtain  an {\it essential word}, denoted by $w^* =  \sigma^*_0 \sigma^*_1 \sigma^*_2\ldots \sigma^*_k$, such that  $\sigma^*_i \subseteq \sigma_i$ is the tightest subset of atomic propositions that enables a clause of label $\gamma(v_i, v_{i+1})$ where $v_i$ and $ v_{i+1}$ are consecutive vertices in the run $\overline{\rho}^\text{pre}$, so that  removing any atomic proposition from $\sigma^*_i$ dissatisfies this clause. We identify the satisfied clause in the label $\gamma(v_i, v_{i+1})$  and add all positive literals in this clause  to $\sigma^*_i$. If two sets of atomic propositions $\sigma_i$ and $\sigma_j$ correspond to  the  same vertex label, then $\sigma^*_i = \sigma^*_j$ since by  condition~\hyperref[asmp:a]{\it (a)} in Assumption~\ref{asmp:same}, it is always the same clause that is satisfied in a vertex label. Furthermore, if $\sigma_i$ corresponds to an edge label and $\sigma_{i+1}$ corresponds to the immediate following  vertex label, then $\sigma^*_{i+1} \subseteq \sigma^*_i$ since by condition~\hyperref[asmp:b]{\it (b)}, the satisfied clauses in the  edge labels implies the satisfied clauses in the immediately following vertex labels. By default, $\sigma_i^* = \{\top\}$ if $\gamma(v_i, v_{i+1})=\top$.  In this way, we have that $w^* \in \tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$
since it induces the same run $\overline{\rho}^\text{pre}$ as $\overline{w}^\text{pre}$ does, and that the path $\overline{\tau}^\text{pre}$ generating the word $\overline{w}^\text{pre}$ can generate the word $w^*$.

\subsubsection{Construction of a subgraph of the routing graph $\ccalG$:}\label{app:graph}
In this part, we construct a routing graph $\ccalG_{w^*}$ based on the essential word $w^*$ which turns out to be a subgraph of the routing graph $\ccalG$ built in Section~\ref{sec:graph}.
Given the essential word $w^*$, we can divide it into parts by locating the components where edges in the induced run $\overline{\rho}^\text{pre}$ in $\auto{subtask}^-$ are enabled. Fig.~\ref{fig:word} demonstrates such partition where green columns represent single time instants when edges  are enabled, i.e., subtasks are completed, e.g., $t_{e'}$ and $t_{e}$ where $e'$ is the subtask that is completed immediately preceding $e$, and the white areas between any two green columns represent the time intervals, e.g., $t_{e'}+1, \ldots, t_{e}-1$, when the vertex labels are satisfied. Note that $t_{e}-1 \geq t_{e'}+1$ since we adjusted the path $\overline{\tau}^{\text{pre}}$ so that each starting vertex label is satisfied at least one. In this way,  the time interval $t_{e'}+1, \ldots, t_{e}-1$ and the time instant $t_e$ make up the time span of the  subtask $e$ in the simple path $\overline{\theta}^{\text{pre}}$. Thus, given the path $\overline{\tau}^\text{pre}$, we can obtain an array of time spans of subtasks in $\overline{\theta}^{\text{pre}}$ such that every time span is disjoint with each other and subtasks are completed sequentially. In what follows, we build a graph $\ccalG_{w^*}$ based on the essential word $w^*$.
\paragraph{(1) Construction of the vertex set:}\label{app:vertex} We begin with the vertex set.
\begin{figure}[!t]
  \centering
  \includegraphics[width=\linewidth]{word.pdf}
  \caption{The divided essential word $w^*$.}
  \label{fig:word}
\end{figure}


\refstepcounter{phase}
 \subphase{Vertices associated with initial locations}{First, we create the vertex set $\ccalV_{\text{init}}$ that corresponds to initial robot locations, as in case~\ref{vertex:initial} in Section~\ref{sec:vertex} for $\ccalG$. We assign visit time $t_{vr}^- = t_{vr}^+ = 0$ to each vertex $v \in \ccalV_{\text{init}}$,  where robot $r$ is the specific robot that is associated with $v$. In what follows, we create vertices associated with clauses in edge or vertex labels that are satisfied by the path $\overline{\tau}^\text{pre}$.}\label{app:initial}

  \subphase{Vertices associated with the edge label}{Consider a time instant $t_e$ when the edge $e = (v_1, v_2)$ in  $\overline{\theta}^{\text{pre}}$ is enabled. The set $\sigma_{t_e}^*$ of atomic propositions  contains all literals appearing in the single clause satisfied in the edge label $\gamma(v_1, v_2)$. If $\gamma(v_1, v_2) = \top$, then $\sigma_{t_e}^* = \{\top\}$ and we do not create any vertex, as in case~\ref{vertex:edge}. Otherwise, for each atomic proposition $\ap{i}{j}{k,\chi}$ in $\sigma_{t_e}^*$, we know that there are $i$ robots of type $j$ at region $\ell_k$ in the $t_e$-th configuration of the path $\overline{\tau}^\text{pre}$, and we also know which are these $i$ robots. Similar to building the routing graph $\ccalG$ in case~\ref{vertex:edge}, we construct $i$ vertices pointing to region $\ell_k$. Recall that we associate all robots of type $j$ with each of these $i$ vertices in $\ccalG$. However, for $\ccalG_{w^*}$, we have the information about which specific $i$ robots of type $j$ visit region $\ell_k$ at time $t_e$ by checking the path $\overline{\tau}^\text{pre}$. We create a one-to-one correspondence between these $i$ robots with these $i$ vertices. In this way, each vertex is visited by one specific robot. These robots are referred to as the essential robots in Appendix~\ref{sec:run}. Furthermore, the time the specific  robot $r$ visits its assigned vertex $v$ is $t_e$, which is denoted by $t_{vr}^- = t_{vr}^+ = t_e$. Continuing this way, we create vertices for other atomic propositions in $\sigma_{t_e}^*$, which only correspond to one single clause  satisfied in $\gamma(v_1, v_2)$. Recall that when building the vertex set of $\ccalG$ in case~\ref{vertex:edge}, we build such vertices for each clause in the given edge label. Therefore, the set of vertices in $\ccalG_{w^*}$ corresponding to the edge label satisfied at $t_e$ is a subset of the vertex set in $\ccalG$ for the same edge label.}\label{app:edge}

    \subphase{Vertices associated with the vertex label}{Following the same logic, we build the vertex set for the satisfied clause in the starting vertex label of $e$. We proceed depending on whether $e$ is the first completed subtask. If $e$ is not the first completed subtask in the simple path $\overline{\theta}^{\text{pre}}$,  according to Assumption~\ref{asmp:same}, the clauses satisfied in this vertex label remain the same, that is, $\sigma^*_t$'s remain the same for all $t= t_{e'}+1, \ldots, t_{e}-1$ where $e'$ is the subtask immediately preceding $e$. Also, it is the same fleet of robots satisfy this clause. Likewise, we can associate each vertex with one single robot, and the visit time interval is set as $[t_{e'}+1, t_{e}-1]$. That is, the robot $r$ remains at its assigned vertex $v$  within this time interval,
%% needs to visit its assigned vertex $v$ at the time instant  no later than  $t_{e-1}+1$ and leave its assigned vertex at the time instant no earlier than $t_{e}-1$,
which are denoted by $t_{vr}^- = t_{e'}+1$ and $t_{vr}^+ = t_{e}-1$. This vertex set will be created in $\ccalG$ since vertices are created for any starting vertex label in case~\ref{vertex:vertex}. Otherwise, if  $e$ is the first completed subtask in the path $\overline{\tau}^\text{pre}$ and its starting vertex has a self-loop, then,  we create vertices for the satisfied clause as usual and associate them with time interval $[0, t_e-1]$. That is, $t_{vr}^-=0$ and $t_{vr}^+ = t_e-1$. Recall also that, the routing graph $\ccalG$ creates vertices for all clauses in all starting  vertex labels.
Furthermore, we do not create vertices for labels either $\top$ or $\bot$, same as in case~\ref{vertex:vertex}. Therefore, we can conclude that the vertex set of $\ccalG_{w^*}$ is a subset of that of $\ccalG$.}\label{app:vertex}





\paragraph{(2) Construction of the edge set:}\label{app:edge_set} Next, we prove that the edge set in $\ccalG_{w^*}$ is also a subset of the edge set in $\ccalG$. Still, consider the edge label that is satisfied at the time instant $t_e$. For a vertex $v$ among those associated with this edge label, we already know the robot $r$ that visits  $v$. Our goal is to determine the unique vertex in $\ccalG_{w^*}$ from which robot $r$ comes. Let $\overline{\tau}_{r,j}$ denote by the path of robot $r$ of type $j$. Tracing backward from the $(t_{e}-1)$-th waypoint in $\overline{\tau}_{r,j}$ (included), we identify the most recent time instant $t\leq t_e -1$  when robot $r$ takes part in the satisfaction of a literal $\ap{i}{j}{k,\chi}$ that appears in the set $\sigma^*_{t}$ of atomic propositions, that is, participate in certain subtask. \refstepcounter{phase}

\subphase{Time instant $t$ does not exist}{In this case, subtask $e$ is the first subtask that robot $r$ participates, then we create an edge starting from the vertex $u$ that points to the initial location of robot $r$ and ending at vertex $v$. We assign the traveling time $T_{uv}=t_e$ to the edge $(u,v)$, which is obtained from  $T_{uv} = t_{vr}^- - t_{ur}^+ = t_e - 0$.
According to case~\ref{sec:a} in Section~\ref{sec:edge_set}, the edge $(u,v)$ is  also  created in $\ccalG$.}

\subphase{Time instant $t$ exists}{In this case, let $e'$ denote the subtask this literal $\ap{i}{j}{k,\chi}$ corresponds to. If $e\neq e'$, we have that $e'$ occurs before $e$ in the given path $\overline{\tau}^\text{pre}$ since time spans of subtasks are disjoint and $t < t_e$. Thus, $e' \in X_{<_P}^{e} \cup X_{\|_P}^e$. We locate the vertex $u$ in $\ccalG_{w^*}$ that is associated with this literal $\ap{i}{j}{k,\chi}$ and is visited by robot $r$, then create an edge starting from $u$ and ending at $v$. Furthermore, we assign the weight $t_{vr}^- - t_{ur}^+$ to this edge (where $t_{vr}^-=t_e$), which is the traveling time the robot $r$ takes between these two consecutive subtasks it undertook. We state that the edge $(u, v)$ also exists in $\ccalG$, since vertices $u$ and $v$ are associated with the same robot $r$, thus same robot type, and $u$ is associated with a prior subtask $e'$ of $e$. According to the case~\ref{sec:b} regarding leaving vertices from prior subtasks, the edge $(u,v)$ exists in $\ccalG$.}

\subphase{$e'=e$}{In this case, the vertex $u$ that robot $r$ visits is associated with the starting vertex label of the same subtask  $e$. We create the edge $(u,v)$ and assign the traveling time  $T_{uv} = t_{vr}^- - t_{ur}^+$. This edge will be created in $\ccalG$ following case~\ref{sec:c} in Section~\ref{sec:edge_set}. Therefore, all edges in $\ccalG_{w^*}$ with end vertices being associated with edge labels exist in $\ccalG$.}

\refstepcounter{phase}

Following the same logic, we create edges associated with the starting vertex label of subtask $e$.  Given a vertex $v$ in $\ccalG_{w^*}$ that is associated with the vertex label $\gamma(v_1)$ of subtask $e$,  we find  the associated specific  robot $r$ of type $j$.

\subphase{Subtask $e$ is the first completed subtask in the path $\overline{\tau}^\textup{pre}$} {If its starting vertex $v_0$ has a self-loop, then the initial locations should satisfy the starting vertex label of $e$. We locate the vertex $u$ pointing to the initial location of robot $r$ of type $j$, create an edge starting from vertex $u$ and ending at $v$, and assign the traveling time $T_{uv}=0$. This edge will be created in cases~\ref{edge:vertex1} or~\ref{edge:vertex2} in Section~\ref{sec:edge_set}.}

\subphase{Subtask $e$ is not the first completed subtask}{We start tracing backward from the $t_{e'}$-th waypoint (the subtask $e'$ immediately precedes  $e$) in the path $\overline{\tau}_{r,j}$ to find the most recent time instant $t$ this robot joins another subtask. Condition~\hyperref[asmp:b]{\it (b)} in Assumption~\ref{asmp:same} says that the robots satisfying starting vertex labels come from those satisfying  edge labels immediately preceding them, which implies that $t$ should be identical to $t_{e'}$ since the path $\overline{\tau}^\text{pre}$ satisfies condition~\hyperref[asmp:b]{\it (b)}.  We locate the vertex $u$ associated with the edge label of subtask $e'$ that robot $r$ visits, create an edge between $u$ and $v$, and assign the traveling time $T_{uv} = t_{vr}^- - t_{ur}^+$ to the edge. This edge will also be created in case~\ref{edge:vertex2} in Section~\ref{sec:edge_set}.  Thus, the edge set of in $\ccalG_{w^*}$ is a subset of the edge set of $\ccalG$. Finally, we can conclude that the graph $\ccalG_{w^*}$ based on the essential word $w^*$ is a subgraph of the routing graph $\ccalG$ based on which the MILP is formulated.}\label{app:strongly}


The graph $\ccalG_{w^*}$ has the property that there are no cycles and any two paths in $\ccalG_{w^*}$, starting from vertices pointing to initial robot locations  and ending at vertices without outgoing edges, do not share the same vertex since each path is associated with a specific robot. Therefore, every vertex except the starting and end vertices in one path has indegree 1 (number of incoming edges) and outdegree 1 (number of outgoing edges). What's more, vertices in $\ccalG_{w^*}$ are assigned with the tightest visit time intervals for the specific robot. Consequently, starting from the vertex corresponding to the initial location of robot $r$ of type $j$, we can extract a high-level plan $p_{r,j}$ for this robot by traversing along edges, which is a concise description of the low-level path $\overline{\tau}_{r,j}$. Observe that, given a feasible solution to the MILP, we can build a subgraph of $\ccalG$ by removing any vertices and edges that are not visited by any robots and assigning robots and visit time to the remaining vertices. In some sense, such subgraph can be viewed as the graphical depiction of the solution to the MILP. In what follows, we show that the graph $\ccalG_{w^*}$ can be one of such graphs. That is, it can give rise to a feasible solution that satisfies constraints~\eqref{eq:1}-\eqref{eq:lastclause}.

\subsubsection{Satisfaction of MILP constraints:}\label{app:milp}
\paragraph{(1) Routing constraints:} Any vertex in $\ccalG_{w^*}$ is visited by a single robot of certain type, thus, constraint~\eqref{eq:1} that each vertex is visited by at most one robot of certain type is satisfied. Specially, given a vertex $v\in \ccalG_{w^*}$, its associated robot $r$ and unique vertex $u$ that is connected to $v$, we set $x_{uvr}=1$  and $x_{uvr'}=0$ for other robots $r'$ of the same type as $r$. In what follows, we omit the detailed assignment when it is clear to recognize. Furthermore, each vertex outside $\ccalV_{\text{init}}$  is either a sink vertex (indegree is 1, outdegree is 0) or a vertex with indegree equaling outdegree. Therefore, the flow constraint~\eqref{eq:2} is satisfied. For each vertex in $\ccalV_\text{init}$ of $\ccalG_{w^*}$, its outdegree is either 0 or 1, thus, constraint~\eqref{eq:2.5a} is satisfied. Each vertex in $\ccalV_\text{init}$ is associated with a unique robot, which satisfies constraint~\eqref{eq:2.5b}.
\paragraph{(2) Scheduling constraints:} Since the visit time of each vertex  is non-negative and the visit time associated with the vertices in $\ccalV_{\text{init}}$ is set as $t_{vr}^- = t_{vr}^+ = 0$ (see case~\ref{app:initial}), constraints~\eqref{eq:3} and~\eqref{eq:3.5} are satisfied trivially. When creating edges in $\ccalG_{w^*}$, we set the traveling time $T_{uv}$  between connected vertices $u$ and $v$ in $\ccalG_{w^*}$ as $t_{vr}^- - t_{ur}^+$, which is the actual time robot $r$ takes to travel between regions associated with $u$ and $v$. Obviously, $T_{uv}$ is no less than the shortest traveling time $T^*_{uv}$ between these two regions, i.e., $T_{uv}^* \leq T_{uv}$. When $u \in \ccalV_\text{init}$ or $u <_P v$ or $(u,v)\in X_P$ and  when robot $r$ travels the edge $(u, v)$, i.e., $x_{uvr}=1$, constraint~\eqref{eq:4b} holds since $t^+_{ur} + T^*_{uv} \leq t^+_{ur} + T_{uv} = t^-_{vr}$. Next, we show that, when $u \|_P v$, constraint~\eqref{eq:4a} can be satisfied if all robots are frozen for one time instant within the time interval $[t_{ur}^+, t_{vr}^-]$. More importantly, the elongated path can still generate a word belonging to $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$. This analysis proceeds depending on the types of NBA vertices that vertices $u$ and $v$ are associated with.
\refstepcounter{phase}

\subphase{Starting vertex $u$ in $\ccalG_{w^*}$ is associated with a vertex label in $\auto{subtask}^-$}{Recall that we assign $t_e-1$ to $t_{ur}^+$ when constructing the vertex set, that is, the time instant right before the subtask is completed (see case~\ref{app:vertex}). Thus, at the time instant $t_{ur}^+$, the run $\overline{\rho}^{\text{pre}}$ has not left the NBA vertex in $\auto{subtask}^-$ that vertex $u$ is associated with. We can repeat one more time the locations of all robots in the path $\overline{\tau}^\text{pre}$ at the time instant $t_{ur}^+$  so that the run visits the same NBA vertex  one more time. In this way, the traveling time assigned to  the edge $(u,v)$ becomes $T_{uv}+1$, where $T_{uv}$ is the time robot $r$ takes in the path $\overline{\tau}^\text{pre}$ and 1 is the extra time it takes when all robots remain idle for one time instant. Therefore, constraint~\eqref{eq:4a} is satisfied.}

\subphase{End vertex $v$ is associated with a vertex label in $\auto{subtask}^-$}{Recall that we assign $t_{e'}+1$ to $t_{vr}^-$ when constructing the vertex set, that is, the time instant right after a subtask is completed (see case~\ref{app:vertex}). The vertex label is satisfied at $t_{vr}^-$ since the  label of each vertex in the simple path $\overline{\theta}^{\text{pre}}$ is satisfied at least once according to the construction of the path $\overline{\tau}^\text{pre}$ at the beginning of Appendix~\ref{app:feasibility}. Thus, we can repeat one more  time the locations of all robots in the path $\overline{\tau}^\text{pre}$ at the time instant $t_{vr}^-$  so that the run visits the same NBA vertex  one  more time. Same as before, the traveling time assigned to  the edge $(u,v)$ becomes $T_{uv}+1$.}

\subphase{Both $u$ and $v$ in $\ccalG_{w^*}$ are associated with an edge label in $\auto{subtask}^-$}{These two vertices must correspond to two different subtasks. Furthermore, there must be an NBA vertex with a  self-loop between these two subtasks in the simple path $\overline{\theta}^{\text{pre}}$. This is because  according to condition~\hyperref[cond:b]{\it (b)} in Definition~\ref{defn:run}, only initial and accepting vertices can have no self-loops but they cannot be between two edges in the path $\overline{\theta}^{\text{pre}}$ if they do not have self-loops. In this case, robots can remain idle for one more time  when this vertex label is true. Same as before, the traveling time assigned to  the edge $(u,v)$ becomes $T_{uv}+1$.}


Therefore, constraint~\eqref{eq:4a} are satisfiable in these three cases. We emphasize that the path $\overline{\tau}^\text{pre}$ after modification still produces a prefix part of a restricted accepting run since the result of idleness is  that a vertex in the run $\overline{\rho}^{\text{pre}}$ is visited one more time.  Thus, all robots remaining idle for a period of time does not affect the satisfaction of other constraints. In what follows, we still focus on the path $\overline{\tau}^\text{pre}$ since if it satisfies the others constraints, so does the modified path.

\paragraph{(3) Logical constraints:} Each set $\sigma^*_i$ of atomic propositions in the essential word $w^*$ collects all literals inside one clause, and all $\sigma^*_i$'s that are associated with the same vertex label collect literals of the same clause. Therefore, constraint~\eqref{eq:c} that one and only one clause is true is satisfied. Although the path $\overline{\tau}^\text{pre}$ can simultaneously satisfy more than one clauses in a label, we construct the essential word $w^*$ by selecting only one clause, and build the graph $\ccalG_{w^*}$ based on $w^*$. In this sense, we can state that only one clause is true on the graph $\ccalG_{w^*}$. Moreover, because every vertex in $\ccalG_{w^*}$ associated with the same clause is visited by one robot, constraint~\eqref{eq:6} regarding one robot per vertex is satisfied.  When constructing the vertex set of $\ccalG_{w^*}$ associated with edge labels (see case~\ref{app:edge}), we associate each vertex $v$ corresponding to the same edge label with time $t_{vr}^- = t_{vr}^+ = t_e$. Therefore, the simultaneous visiting constraint~\eqref{eq:7} is satisfied.

\paragraph{(4) Temporal constraints:}
\paragraph{(i) Temporal constraints on one subtask:} As said before, each vertex $v$ in $\ccalG_{w^*}$ associated with the same edge label is assigned time $t_{vr}^- = t_{vr}^+ = t_e$, and only one clause is true, therefore, constraint~\eqref{eq:edgetime} regarding the computation of the completion time is satisfied. In case~\ref{app:vertex}, we associate each vertex $v$ corresponding to the same vertex label (neither $\bot$ nor $\top$) with the same arriving time $t_{vr}^- = t_{e'}+1$ and the same leaving time $t_{vr}^+ = t_{e}-1$, where $t_e$ is the completion time of the subtask that the vertex label corresponds to and $t_{e'}$ is the completion time of the subtask immediately preceding $e$. As subtasks in  the simple path $\overline{\theta}^{\text{pre}}$ are sequentially completed, we have that $t_{vr}^- = t_{e'}+1\leq t_e$, thus the left side of constraint~\eqref{eq:17} holds. The right side holds trivially since $t_e = t_e-1+1 = t_{vr}^+ +1$. Next, if the initial vertex does not have a self-loop, and if the outgoing edge in the simple path $\overline{\theta}^{\text{pre}}$ is labeled with $\top$, there is no vertex in $\ccalG_{w^*}$ that corresponds to this edge. We can just define the completion time of this edge label as 0, as stated by~\eqref{eq:tis0}. Otherwise, if the outgoing edge label is not $\top$, then the initial robot locations  satisfy it, that is, the set $\sigma^*_0$ of atomic propositions include literals that appear in the satisfied clause in the edge label.
Therefore, vertices are created in $\ccalG_{w^*}$ for these literals and the assigned visit time corresponds to the index of $\sigma_0^*$, i.e., 0. Thus, in this case~\eqref{eq:tis0} also holds.

\paragraph{(ii) Temporal constraints on the completion of two sequential subtasks:}
Since the simple path $\overline{\theta}^{\text{pre}}$ in $\auto{subtask}^-$, induced by the path $\overline{\tau}^\text{pre}$, is a linear extension of the poset $P$, so  the temporal  order of subtasks in $\overline{\theta}^{\text{pre}}$ respects the partial order in the poset $P$. Thus, given a subtask $e$ in the simple path $\overline{\theta}^{\text{pre}}$, any subtask $e'\in \overline{\theta}^{\text{pre}}$ with $e' \prec_P e$ is completed before $e$ in the path $\overline{\tau}^\text{pre}$. Therefore, $t_{e'} +1 \leq t_e$, which satisfies constraint~\eqref{eq:12}.
\paragraph{(iii) Temporal constraints on the completion of the
current subtask and the activation of subsequent
subtasks:}
For each subtask $e$ except the last one in the simple path $\overline{\theta}^{\text{pre}}$, the subtask $e'$ immediately following it belongs to the set $X_{\succ_P}^e \cup X_{\|_P}^e$. If $e' \in X_{\succ_P}^e \neq \emptyset$ as in \ref{activation:a}, since it is only subtask $e'$ in the simple path $\overline{\theta}^{\text{pre}}$ that immediately follows $e$, constraint~\eqref{eq:bafter} holds. The completion time  of subtasks $e'$ immediately following  $e$ in the simple path is larger than that of $e$ by at least 1, therefore, constraint~\eqref{eq:after} is satisfied. %% As discussed in the temporal constraints on the completion of two sequential subtasks, robots can remain idle to satisfy the vertex label, making constraint~\eqref{eq:after} satisfiable no that what positive integer that $M_{\text{min}}$ takes.
Furthermore, for each vertex $v$ associated with the edge label of subtask $e'$, we associate it with the arriving time $t_{vr}^- = t_{e}+1$, which satisfies constraint~\eqref{eq:20}. Since the simple path $\overline{\theta}^{\text{pre}}$ is a linear extension of the poset $P$, no subtasks are completed at the same time, which satisfies constraint~\eqref{eq:diff}. If $X_{\succ_P}^e = \emptyset$ as in \hyperref[activation:b]{\it (K$_2$)}, then $e' \in X_{\|_P}^e$. Because subtask $e'$ follows $e$, i.e., $b_e^{e'}=0$, and  subtask $e$ is not the last completed one, constraints~\eqref{eq:afterparallel_a}-\eqref{eq:afterparallel_c} are satisfied by setting $b_{ee'}=1$.  If $e$ is the last subtask in the simple path, $b_{ee'}=0$ and $b_{e}^{e'}=1$ in~constraints~\eqref{eq:afterparallel_a}-\eqref{eq:afterparallel_c}.

On the other hand, for any subtask $e$ in the simple path $\overline{\theta}^{\text{pre}}$ except the first one, it immediately follows a subtask, denoted by $e'$, which should be in $X_{\prec_P}^e \cup X_{\|_P}^e$. If $e'\in  X_{\prec_P}^e \neq \emptyset$, since there is only the subtask $e'$ in the simple path $\overline{\theta}^{\text{pre}}$ that immediately precedes $e$, constraint~\eqref{eq:follow1} holds. Otherwise, if $X_{\prec_P}^e = \emptyset$, then $e \in X_{\|_P}^e$. As subtask $e'$ precedes $e$, i.e., $b_e^{e'}=1$, and subtask $e$ is not the first completed one, constraints~\eqref{eq:follow_a}-\eqref{eq:follow_c} are satisfied by setting $b_{e'e}=1$.  If $e$ is the first subtask in the simple path, $b_{e'e}=0$ and $b_e^{e'}=0$ in~constraints~\eqref{eq:follow_a}-\eqref{eq:follow_c}.

\paragraph{(iv) Temporal constraints on the activation of the first subtask:}
Consider the first completed subtask $e$ in the path $\overline{\tau}^\text{pre}$. If its starting vertex has a self-loop, and also the vertex label is not $\top$,
then this vertex label is satisfied at least once by the construction of the path $\overline{\tau}^\text{pre}$, and  there are vertices in $\ccalG_{w^*}$ associated with the satisfied clause in this vertex label. Since the assigned time $t_{vr}^-$ to these vertices is 0 (see case~\ref{app:vertex}), constraint~\eqref{eq:zeroactivation} is satisfied. For the first subtask $e$, since there is no subtask before it, the robots  visiting vertices associated with the starting vertex label of $e$ comes from  vertices in $\ccalV_{\text{init}}$. Thus, constraint~\eqref{eq:routingforactivation_a} is satisfied for subtask $e$. For subtasks in $P_{\text{max}}$ other than $e$, the vertices associated with their vertex labels are connected to vertices associated with the edge labels of subtasks that are completed immediately before them (see case~\ref{app:strongly}). Therefore, constraint~\eqref{eq:routingforactivation_b} is satisfied.


\paragraph{(5) Same-$\ag{i}{j}$ constraints:}
Give any two vertex subsets in $\ccalG_{w^*}$ that are associated with two literals that share the same nonzero connector, they are visited by the same fleet of robots since the essential word $w^*$ belong to $\title{\ccalL}_E^{v_0 \scriptveryshortarrow \vertex{accept}}(\auto{subtask}^-)$. We enumerate these two vertex subsets such that there is a one-to-one correspondence between vertices in these two subsets and the matched pair of vertices are visited by the same robot. In this way, constraint~\eqref{eq:same} is satisfied.

\paragraph{(6) Constraints on the transition between the prefix and suffix parts:}
Since at each time we formulate the MILP, we iterate over all subtasks that can be the last one to be completed and also iterate over all clauses in the edge label of the selected last subtask, we can formulate a MILP in which the selected last subtask and the clause are  the same as that induced by the feasible path $\overline{\tau}^\text{pre}$. Therefore, constraints~\eqref{eq:lastsubtask0} and~\eqref{eq:lastclause} are satisfied, which completes the proof.


%%  (b) If its starting vertex has a self-loop whereas the starting vertex only appears once in the run $\rho$, which means the edge label is satisfied at time 0. In this case, as in step (b) in Appendix~\ref{app:vertex} when constructing the vertex set, there are no vertices created in $\ccalG_{w^*}$ associated with this vertex label. However, there are vertices in $\ccalG$ for this vertex label since we create vertices in $\ccalG$ for each vertex label that is neither $\top$ nor $\bot$. Therefore, constraint~\eqref{eq:zeroactivation} should be still satisfied regarding these vertices in $\ccalG$. That is, those vertices associated with the clause that is set as true by constraint~\eqref{eq:c} should be visited at time 0, which is achievable. First, since the starting vertex has a self-loop, the initial robot locations satisfy its vertex label, otherwise, its self-loop will be removed in Section~\ref{sub-NBA:1} when extracting the sub-NBA $\auto{subtask}$. Second, in $\ccalG$ edges exist that end at these vertices and start from  vertices pointing to initial robot locations (see steps~\hyperref[edge:vertex1]{\it (a)} and~\hyperref[edge:vertex2]{\it (b)} when constructing the edge set). The shortest traveling time is 0 since initial robot locations satisfy the starting vertex label. Furthermore, the leaving time from vertices in $\ccalV_{\text{init}}$ that point to initial robot locations are set as 0 when constructing the graph $\ccalG_{w^*}$. Thus, according to scheduling constraint~\eqref{eq:4b}, $t_{vr}^-$ can be 0. In this way, constraint~\eqref{eq:zeroactivation} is satisfied. Note that additionally,  the subtask $e$ is completed  by the path $\tau$ at time 0, thus the vertices in $\ccalG$ associated with the satisfied clause in the edge label of $e$ should be visited at time 0, which is also achievable.
%% First, edges in $\ccalG$ exist ending at these vertices and starting from vertices pointing to initial robot locations and vertices associated with the starting vertex label of $e$. The shortest traveling time is 0 since the both the clause in the starting vertex label and the clause in the edge label are   satisfied by initial robot locations. Furthermore, the leaving time from vertices pointing to initial robot locations and vertices associated with the starting vertex label of $e$ can be 0, therfore, scheduling constraint~\eqref{eq:4b} allows these vertices associated with the satisfied clause in the edge label to be visited at time 0. In other words, when the starting vertex labell of the first complete subtask $e$ in the path $\tau$ is not satisfied for once, in $\ccalG_{w^*}$ robots leave from vertices pointing to their initial locations and reach the vertices associated with the edge label of $e$ at time 0; while in $\ccalG$, robots first reach the vertices associated with the starting vertex label and then reach the vertices associated with the edge label of $e$. Because the traveling time is 0, robots can reach these two kinds of vertices both at time 0, so that achieve the goal of respecting the path $\tau$ and satisfying  the constraint~\eqref{eq:zeroactivation} at the same time.

%% \subsubsection{Proof of Lemma~\ref{prop:adjustment}}\label{app:adjustment}
%% We note that if two subtasks are completed at the same time, then these two subtasks are temporally independent since otherwise, the completion time of two temporally dependent subtasks are different according to constraint~\eqref{eq:12}. Cosider such two independent subtasks $(v_1, v_4)$ and $(v_4, v_3)$ in Fig.~\ref{fig:id}.  Given a path segment $\tau_{\text{seg}}$ that completes these two independent subtasks at the same time, as shown in the proof of Lemma~\ref{prop:sub-NBA},  we can construct another path segment $\tau'_{\text{seg}}$ by freezing the movement of all robots for two more time instants, so that subtask $(v_4, v_3)$ are completed right after $(v_1, v_4)$. Based on this, given a solution to the MILP formulation, we construct another solution in the following way. First, we keep the values of all routing variables $x_{uvr}$ unchanged since we only adjusted time. Next, let $t$ denote by the time in the solution when two subtasks are completed simultaneously. We select one between these two subtasks and fixed
%% We increase all scheduling variables $t_{vr}^-, t_{vr}^+$ and $t_e$ in the solution whose values are

\subsubsection{Proof of Lemma~\ref{prop:run}:}\label{app:run}
To prove that a simple path $\tilde{\theta}$ can be extracted from the sub-NBA $\auto{subtask}^-$,  our goal is to show that the solution to the MILP gives rise to a simple path   in the set of simple paths $\Theta$ from which the poset $P$ is inferred. Then, leveraging the completeness of the  backtracking search algorithm,  such simple path is ensured to be found in $\auto{subtask}^-$. In the MILP formulation, we define a variable for each subtask in $X_P$ which indicates its completion time (see Appendix~\ref{sec:temporal}) and require that completion time of two subtasks are different (see constraint~\eqref{eq:diff}).  Thus, we can sort the subtasks in $X_P$  in an ascending order with respect to their completion time. The sorted subtasks respect the partial order in $P$ since precedence relations among subtasks are captured by constraint~\eqref{eq:12}, which means the the sequence  of sorted subtasks is a linear extension of the poset $P$. Furthermore, the set of simple paths $\Theta$ is equivalent to the set of  linear extensions of the poset $P$, which is ensured in Section~\ref{sec:poset}. Therefore, the sequence of sorted subtasks corresponds to a simple path in $\Theta$, which is in $\auto{subtask}^-$.


In what follows, we prove the properties this simple path $\tilde{\theta}$ has: First, for the first subtask in the simple path $\tilde{\theta}$, if the initial vertex $v_0$ does not have a self-loop, then according to constraint~\eqref{eq:tis0}, it must be completed at time 0, thus, the activation time is also 0. Otherwise, if $v_0$ has a self-loop and also the vertex label in $\auto{subtask}^-$ is $\top$, then we can view that it is activated at anytime, including 0; else if $v_0$ has a self-loop  whose label is not $\top$, according to constraint~\eqref{eq:zeroactivation}, the activation of the vertex label is 0. Therefore, property~\ref{property:a} holds.

Second, for any subtask $e$ in the simple path $\tilde{\theta}$, if its starting vertex label has a self-loop and the vertex label is $\top$, the property~\ref{property:b} holds trivially, else if the vertex label is not $\top$,  constraint~\eqref{eq:17} ensures that  property~\ref{property:b} holds.

Finally,  for  property~\ref{property:c}, given any two consecutive subtasks $e$ and $e'$ in the simple path $\tilde{\theta}$, we  prove that it is exactly $e' \in S_3^e = X^e_{\succ_{P}} \cup X^e_{\|_{P}}$ that makes $b_{ee'}=1$ in constraint~\eqref{eq:bafter}. If so, according to constraint~\eqref{eq:20}, subtask $e'$ is activated at most one time instant later than the completion of $e$. Therefore, property~\ref{property:c} holds. We prove this  by induction.

Consider $e_0$ and $e_1$ that are the first two subtasks in the simple path $\tilde{\theta}$. Because $e_1$ is completed immediately after $e_0$, we have that $e_1\in X^{e_0}_{\succ_{P}} \cup X^{e_0}_{\|_{P}} $. Thus, ${e_0} \in X^{e_1}_{\prec_{P}} \cup X^{e_1}_{\|_{P}}$. Since subtask $e_1$ is not the first one in $\tilde{\theta}$, it must immediately follow a subtask. According to constraints~\eqref{eq:follow1}-\eqref{eq:follow}, there must exist  a subtask $e \in X^{e_1}_{\prec_{P}} \cup X^{e_1}_{\|_{P}} $ such that $b_{e e_1}=1$.
Assume that $e \neq e_0$. According to constraint~\eqref{eq:after}, subtask $e$ must be completed before $e_1$, but it is only subtask $e_0$ that occurs before $e_1$ in the simple path $\tilde{\theta}$, a contradiction. Therefore, $e  = e_0$, i.e., it is exactly subtask $e_1$ that makes $b_{e_0 e_1}=1$. Next,  assume that for any two consecutive subtasks $e_{i-1}$ and $e_{i}$ in the simple path $\tilde{\theta}$,  it holds that $b_{e_{i-1} e_i} = 1$. Given the next two subtasks $e_{i}$ and $e_{i+1}$, assume that $e_{i+1}$ immediately follow subtask $e'$ but $e' \neq e_i$. According to constraint~\eqref{eq:after}, $e'$ is completed before $e_{i+1}$. However, $e'$ can not be any subtask in $e_0, \ldots, e_{i-1}$, since it will contradict constraint~\eqref{eq:bafter} that the immediately following subtask of any subtask in $e_0, \ldots, e_{i-1}$ is unique. Therefore, $e' = e_i$, completing the proof.




%% we first show that we can build a one-to-one correspondence between any subtask and the subtask that immediately follows it. Recall that $b_{ee'}=1$ if subtask $e'$ is immediately after $e$. The one-to-one correspondence is that for any two different subtasks $e$ and $e'$, if $b_{ee'}=1$,  there does not exist a third different  subtask $e''$ in $X_P$ such that  $b_{ee''}=1$ or $b_{e''e'}=1$.




\subsubsection{Proof of Lemma~\ref{prop:valid}:}\label{app:valid}
Given a subtask $e = (v_1, v_2)$ in the simple path $\tilde{\theta}$, the goal of the formulated  GMRPP is to design paths for robots to reach locations that satisfy the complete clause $\gamma_{1,2}^+ \wedge \gamma_{1,2}^-$ in the edge label $\gamma(v_1, v_2)$ so as to complete the current subtask and activate the next subtask, while respecting the complete clause $\gamma_1^+ \wedge \gamma_1^-$ in the starting vertex label $\gamma(v_1)$ en route. By starting from the first subtask in the simple path $\tilde{\theta}$, we proceed along the simple path to prove that each instance of GMRPP with initial locations generated by the previous instance is feasible.


Consider the first subtask $(v_1, v_2)$ with $v_1 = v_0$. We first discuss the case where  the initial vertex $v_0$ has a self-loop in the sub-NBA $\auto{subtask}^-$, which implies that the initial robot locations satisfies the label $\gamma_{\phi}(v_0)$ in the NBA $\autop$, otherwise we will remove its self-loop (see Sections~\ref{sec:sort} and \ref{sub-NBA:1}). We continue based on whether the sets of essential robots $\ccalR_1$ and $\ccalR_{1,2}$ are disjoint.
\refstepcounter{phase}
\subphase{$\ccalR_1 \cap \ccalR_{1,2} = \emptyset$}{According to property~\ref{property:b} in Lemma~\ref{prop:run}, the complete clause $\gamma_1^+ \wedge \gamma_1^-$ can only become false at the same time $\gamma_{1,2}^+ \wedge \gamma_{1,2}^-$ becomes true. At the initial time 0, according  to property~\ref{property:a} in Lemma~\ref{prop:run}, the robot locations satisfy $\gamma_1^+ \wedge \gamma_1^-$, including those robots in $\ccalR_{1,2}$, so they can move around safely  within their respective regions without violating $\gamma_1^-$. By Assumption~\ref{asmp:env}, there is a label-free path between any two regions, and between any label-cells and any regions.  These robots in $\ccalR_{1,2}$ can move to label-free cells without traversing other regions, and take this label-free path to  some label-free cells that are adjacent to their target regions. This process does not  violate  the negative clause $\gamma_1^-$. Also, $\gamma_1^+$ is satisfied due to $\ccalR_1 \cap \ccalR_{1,2} = \emptyset$. At this point, the essential clause $\gamma_{1,2}^+$ can be satisfied in one  time instant. If, at this time, some robots in $\ccalR^-\setminus \ccalR_{1,2}$ violate $\gamma_{1,2}^-$ (robots in $\ccalR_{1,2}$ stay at label-free cells now), then without traversing other regions, these robots  move to somewhere within their respective regions from which they can reach the label-free cells in one time instant. This process also respects the complete clause $\gamma_1^+ \wedge \gamma_1^-$. Finally, at the same time, robots in $\ccalR_{1,2}$ move to their target regions and these robots in $\ccalR^-\setminus \ccalR_{1,2}$ that violate $\gamma_{1,2}^-$   move from their regions to label-free cells, then the complete label $\gamma_{1,2}^+ \wedge \gamma_{1,2}^-$ is satisfied. Note that robots moving to target regions to satisfy $\gamma_{1,2}^+$ will not contradict the negative clause $\gamma_{1,2}^-$ since infeasible clauses are removed in pre-processing step~\hyperref[prune:exclusion2]{\it (4)} in Section~\ref{sec:nba}.}\label{app:gmrpp_a}


\subphase{$\ccalR_1 \cap \ccalR_{1,2} \neq \emptyset$}{In this case, for a robot $r \in  \ccalR_1 \cap \ccalR_{1,2}$, the shortest traveling time between its source region and target region is less than or equal to 1 since by constraint~\eqref{eq:17}, the completion time of the subtask is at most one time instant later than the completion time of its starting vertex label. This implies that its source  region and target region are identical or adjacent. As in case~\ref{app:gmrpp_a}, robots in $\ccalR_{1,2} \setminus \ccalR_1$ move to label-free cells from which their target regions can be reached in one time instant, while robots in $\ccalR_{1,2} \cap \ccalR_1$ move to somewhere within their respective source regions from which they can reach the target regions and leave the source regions in one time instant. Without traversing other regions, the complete clause $\gamma_1^+ \wedge \gamma_1^-$ remains satisfied. Next, similar to case~\ref{app:gmrpp_a}, robots in $\ccalR^-\setminus \ccalR_{1,2}$ move to somewhere within their respective regions from which they can reach the label-free cells in one time instant. In this way, $\gamma_{1,2}^+ \wedge \gamma_{1,2}^-$ can be satisfied at the next time instant.}\label{app:gmrpp_b}

We have shown the feasibility of GMRPP when the initial vertex $v_0$ in $\auto{subtask}^-$ has a self-loop. In the case where $v_0$ does not have a self-loop in $\auto{subtask}^-$, we have that the initial robot locations satisfy the complete clause  $\gamma_{1,2}^+ \wedge \gamma_{1,2}^-$ in the  edge label; otherwise, the edge will be  removed (see Sections~\ref{sec:sort} and \ref{sub-NBA:1}). We will not formulate the GMRPP in this case; see line~\ref{seq:terminate_1}, Alg.~\ref{alg:sequentialMAPP}.


Whether or not $v_0$ has a self-loop, the complete clause $\gamma_{1,2}^+ \wedge \gamma_{1,2}^-$ is satisfied at last. According to condition~\hyperref[cond:d]{\it (d)} in  Definition~\ref{defn:run} and conditions~\hyperref[asmp:b]{\it (b)} in Assumption~\ref{asmp:same}, the complete clause in the end vertex label $\gamma_\phi(v_2)$ can be satisfied automatically, which activates the next subtask, aligning with the property~\ref{property:c} in Lemma~\ref{prop:run} that  the next subtask will be activated at most one time instant later than the current one.  We can apply the same logic in \ref{app:gmrpp_a} and \ref{app:gmrpp_b} to the remaining subtasks in the simple path $\tilde{\theta}$ since each subtask being activated by the previous subtask is similar to the first subtask being activated by initial robot locations, completing the proof.

%% We differentiate the last subtask since, when the end vertex $\vertex{accept}$ has a self-loop in $\auto{subtask}^-$, it may be the case where the edge label does not strongly imply the label of $\vertex{accept}$. In this case, after satisfying the complete clause in the edge label, robots need to move  to satisfy the label of $\vertex{accept}$ in the next time instant. We claim that the corresponding GMRPP falls into one of the following 3 categories: (a) the complete clause in the end vertex label $\gamma(v_2)$ is a subformula of the compositve clause in the edge label $\gamma(v_1, v_2)$, so that it suffices to satisfying the edge label at last. Most instances of GMRPP belong to this category due to condition~\hyperref[cond:d]{\it (d)} in the Definition~\ref{defn:run} and conditions~\hyperref[asmp:b]{\it (b)}~\hyperref[asmp:c]{\it (c)} in the Assumption~\ref{asmp:same}; (b) the complete clause in the end vertex is $\bot$, which occurs when the end vertex is the accepting vertex $\vertex{accept}$ without a self-loop. In this case, it suffices to satisfy the edge label as well; (c) the complete clause in the end vertex $v_2$ is not the subformula of the complete clause in the edge label, which occurs when the end vertex is the accepting vertex with a self-loop. In what follows, we first discuss the first two categories and then the last category. For categories (a) and (b), we first consider the case where the sets of  essential robots $\ccalR_1$ and $\ccalR_{1,2}$ do not overlap. The robot location As two free cells in the workspace are connected, $\ccalR$

%% \subsubsection{Proof of Theorem~\ref{thm:prefix}:}\label{app:prefix}
%% As stated in Proposition~\ref{thm:nba}, if Problem~\ref{prob:1} is feasible, then there exists a pair of initial and accepting vertices, denoted by $v_0$ and $\vertex{accept}$, such that $\tilde{\ccalL}_E^{\phi, v_0 \scriptveryshortarrow \vertex{accept}}(\auto{subtask}^-) \neq \emptyset$. Since in Section~\ref{sec:sort}, we iterate all pairs of initial and accepting vertices whose total length is not infinite, we will deal with the NBA $\auto{subtask}^-$ that are associated with this pair. In Section~\ref{sec:poset}, we collect all simple paths that connect $v_0$ and $\vertex{accept}$, infer the poset from each subset of equivalent simple paths and treat each simple path as a poset if no such poset exists, so we will formulate the MILP over the poset that includes the simple path that a feasible path to Problem~\ref{prob:1} induces. According to Lemma~\ref{prop:feasibility}, the MILP has a solution. Then, following Lemma~\ref{prop:valid}, we get that a path $\tilde{\tau}^{\textup{pre}}$ can be obtained by concatenating paths from each instance of GMRPP since the final locations of the previous instance of GMRPP are identical to the initial locations of the immediately following one.


%% Next, we show that the run $\tilde{\rho}^{\textup{pre}}$ induced by this path $\tilde{\tau}^{\textup{pre}}$ satisfies~conditions~\hyperref[cond:a]{\it (a)}-\hyperref[cond:d]{\it (d)} in Definition~\ref{defn:run}. The run  follows along the simple path extracted according to the solution to the MILP, thus condition~\hyperref[cond:a]{\it (a)} is met. This simple path only has one initial vertex and one accepting vertex since we remove other initial and accepting vertices in Section~\ref{sub-NBA:1}, thus condition~\hyperref[cond:b]{\it (b)} is met. In Section~\ref{sec:prune} we remove vertices that do not self-loops except initial and accepting vertices, and  edges that do not strongly imply their end vertex labels, hence conditions~\hyperref[cond:c]{\it (c)} and \hyperref[cond:d]{\it (d)} are  met.

%% Finally, we show that the path $\tilde{\tau}^{\textup{pre}}$ meets Assumption~\ref{asmp:same}. Firsr, because the path $\tilde{\tau}^{\textup{pre}}$ induces a simple path in $\autop$, constraint~\eqref{eq:c} requires that only one clause is true, and if the clause is associated with a vertex label, the robots visiting vertices associated with this satisfied clause stay there until the edge is enabled (see constraints~\eqref{eq:6} and~\eqref{eq:17}), we have that the same clause is satisfied  by the same fleet of robots, which satisfies condition~\hyperref[asmp:a]{\it (a)} in Assumption~\ref{asmp:same}. Condition \hyperref[asmp:b]{\it (b)} is the direct consequence of the construction of the edge set of vertices in the routing graph $\ccalG$ that are associated with vertex labels in $\auto{subtask}^-$ (see step~\hyperref[edge:vertex2]{\it (F$_2$)} in Section~\ref{sec:edge_set}) and constraint~\eqref{eq:routingforactivation_b} that requires that robots visiting vertices in $\ccalG$  associated with vertex labels of subtasks that are not the first one, should come from vertices that are associated with edge labels of  subtasks that immediately preceding them. Note that the generation of low-level paths will not change the task allocation made in the high-level plan, which completes the proof.

\subsubsection{Proof of Lemma~\ref{prop:suffix_feasibility}:}\label{app:suffix_feasibility}
The MILP for the suffix part shares most constraints with that for the prefix part,  so we go through procedures in Appendix~\ref{app:feasibility}-\ref{app:milp}.

First, we construct an essential word $w^*$ based on the given path $\overline{\tau}^{\text{suf}}$, as in Appendix~\ref{app:word}.  Note that the essential word is constructed with respect to the sub-NBA $\auto{subtask}^-$ in Fig.~\ref{fig:suffix} where we add a  clause $\ccalC_{\text{prior}}^+$ to each edge label of subtasks that can be the last one to be completed. By condition~\hyperref[asmp:c]{\it (c)} in Assumption~\ref{asmp:same}, all robots return to  $s_{\text{prior}}$ at last while driving the transition back to $\vertex{accept}$, which implies that those robots involved in the clause $\ccalC^+_{\text{prior}}$ of $\gamma(\vertex{prior}, \vertex{accept})$ return to regions corresponding to their initial locations. According to Assumption~\ref{asmp:env}, any region spans consecutive cells. Therefore, the last waypoint in $\overline{\tau}^{\text{suf}}$ must satisfy the clause $\ccalC_{\text{prior}}^+$, and further the last set of atomic propositions in $w^*$ is $\ccalC_{\text{prior}}^+$. By taking steps in Appendix~\ref{app:graph}, we can build a graph $\ccalG_{w^*}$ that is also a subgraph of the routing graph $\ccalG$.

Next, as the MILP formulation for the suffix part includes constraints~\eqref{eq:1}-\eqref{eq:same} appearing in the prefix part, our analysis about these constraints is the same as that in Appendix~\ref{app:milp}. Thus, we focus on constraints~\eqref{eq:one_suffix}-\eqref{eq:same_suffix} in Appendix~\ref{app:appendix_suffix_milp}. First, no two subtasks are satisfied at the same time in the given path $\overline{\tau}^{\text{suf}}$, thus, constraints~\eqref{eq:one_suffix} and~\eqref{eq:lastsubtask} are  satisfied. Each vertex in $\ccalG_{w^*}$  associated with  clause $\ccalC_{\text{prior}}^+$ of the last subtask is visited by a specific  robot. Therefore, constraint~\eqref{eq:return_suffix} is satisfied. %% Robots return to respective regions where their initial locations are located   when completing the last subtask, which satisfies the clause $\pi_{\text{init}}$.
Furthermore, after solving  the prefix part, a fleet of robots are associated with literals that are  satisfied in the prefix part and share the same nonzero connector. In the subgraph $\ccalG_{w^*}$,  vertices   associated with a literal with a nonzero connector are visited by  robots belonging to the obtained fleet of robots in the prefix part. We enumerate these vertices to  have a one-to-one-correspondence between robots visiting them and robots in the obtained fleet in the prefix part, so that  two  robots that are matched  are the same robot. Therefore, constraint~\eqref{eq:same_suffix} is satisfied.
%% \subsubsection{Proof of Lemma~\ref{prop:suffix_valid}}\label{app:suffix_valid}
%% The proof is similar to proof of Lemma~\ref{prop:valid} for the prefix part. The exception is the GMRPP that corresponds to the last subtask in the simple cycle $\theta$. In the last subtask, robots need to return to their initial locations. Since the initial locations satisfy the complete clause $\gamma_{1,2}^+ \wedge \gamma_{1,2}^-$,  we seek to show that, without violating the complete clause $\gamma_1^+ \wedge \gamma_1^-$ of the last subtask,  robots can move somewhere  adjacent to their respective initial locations so that  together they can move to their initial locations at the next time instant.

%% First, for those robots in $\ccalR_{1}$ that satisfy $\gamma_1^+$, they can move somewhere adjacent to their initial locations without violating $\gamma_{1}^+$ since according to constraint~\eqref{eq:17}, the completion time of the subtask  is at most one time instant later than the completion time of its starting vertex label, that is,  robots in $\ccalR_1$ remain at their respective regions until moving to their initial locations to complete the subtask. Next, for other robots not in $\ccalR_{1}$, they need to move somewhere adjacent to their initial locations while respecting the negative clause $\gamma_1^-$. According to the assumption, the simple cycle $\theta$ is in $\Theta_{\text{safe}}$, thus each negative literal in $\gamma_1^-$ belongs to $\Pi_{\text{safe}}$. We get that the initial locations of those robots in $\ccalR_1$
%%  do not violate $\gamma_1^-$ since the safe constraints should be satisfied all the time. Therefore, those robots not in $\ccalR_1$ can start from where they are at the end of the previous subtask (satisfying $\gamma_1^-$ as well due to strongly implication), travel to label-free paths without passing other regions, go to regions where their initial locations are and move somewhere in these regions thare are adjacent to their initial locations. Robots traveling within their respective regions will not violate $\gamma_1^-$ since the observaions do not change. In this way, at the next time instant, all robots move together to return to initial locations and complete the last subtask, completing the proof.

\subsubsection{Proof of Theorem~\ref{thm:completeness}:}\label{app:completeness_}
We emphasize that we discuss the class of \ltlz in this proof. Because \ltlz$\subset$ {\it LTL}$_{-\bigcirc}^\chi$, Proposition~\ref{thm:prefix} and Lemma~\ref{prop:suffix_feasibility} apply to the class of {\it LTL}$_{-\bigcirc}^0$. Proposition~\ref{thm:prefix} has proved the finding of a feasible prefix part $\tilde{\tau}^{\text{pre}}$ that induces a run $\tilde{\rho}^{\text{pre}}$ connecting $v_0$ and $\vertex{accept}$, so we focus on the suffix part.

We proceed in two cases depending on whether the suffix part $\rho^{\text{suf}}$ of the run induced by the assumed path in Theorem~\ref{thm:completeness} is a single vertex. When $\rho^{\text{suf}}$ only consists of the accepting vertex $\vertex{accept}$, we next show that condition~\hyperref[cond:e]{\it (e)} in Definition~\ref{defn:run} can be  met. If $\gamma_{\phi}(\vertex{accept})=\top$, which is satisfied automatically. Otherwise, if $\gamma_\phi(\vertex{accept})\neq \top$, because in condition {\it (e)} in Definition~\ref{defn:st} we do not remove any composite edge leading to $\vertex{accept}$ and in constraints~\eqref{eq:lastsubtask0} and~\eqref{eq:lastclause} we loop over  subtasks that can be the last one to be completed, eventually we can formulate a MILP for the prefix part  where the edge label of the  last subtask implies the label of vertex $\vertex{accept}$. Therefore, condition~\hyperref[cond:e]{\it (e)} is  met, which means that the final locations of the prefix path $\tilde{\tau}^{\text{pre}}$ satisfies the vertex label $\gamma_\phi(\vertex{accept})$. Combined with Proposition~\ref{thm:prefix}, we can find a path that induces a run in $\autop$  connecting $v_0$ and $\vertex{accept}$ and enables the NBA $\autop$ to remain at $\vertex{accept}$ forever, satisfying the specification $\phi$.

Next, we discuss the case where the suffix part $\rho^{\text{suf}}$ includes more than one different vertices. Recall that ${s}_{\text{prior}}$ and ${v}_{\text{prior}}$ are the last waypoint in the prefix path $\tau^{\text{pre}}$  and the last vertex before $\vertex{accept}$ in the induced run $\rho^{\text{pre}}$. We denote by   $\tilde{s}_{\text{prior}}$ and $\tilde{v}_{\text{prior}}$  the last waypoint in the found prefix path $\tilde{\tau}^{\text{pre}}$  and the last vertex before $\tilde{v}_\text{accept}$ in its induced run, respectively. By Proposition~\ref{thm:nba}, there exists a suffix path $\overline{\tau}^{\text{suf}}$ generating a word in $\tilde{\ccalL}_E^{\phi, \vertex{accept}\scriptveryshortarrow \vertex{accept}} (\auto{subtask}^-;  s_{\text{prior}}, v_{\text{prior}})$. However, this word may not belong to $\tilde{\ccalL}_E^{\phi, \vertex{accept}\scriptveryshortarrow \vertex{accept}} (\auto{subtask}^-;  \tilde{s}_{\text{prior}}, \tilde{v}_{\text{prior}}) $, since the pair ${s}_{\text{prior}}$ and $\vertex{prior}$ may not be same as the pair $\tilde{s}_{\text{prior}}$ and $\tilde{v}_{\text{prior}}$. In what follows  we show that a feasible suffix path $\doverline{\tau}^{\text{suf}}$, modified from $\overline{\tau}^{\text{suf}}$, exists that generates a finite word $\doverline{w}^{\text{suf}} \in \ccalL_E^{\phi, \vertex{accept}\scriptveryshortarrow \vertex{accept}} (\auto{subtask}^-;  \tilde{s}_{\text{prior}},  \tilde{v}_{\text{prior}})$ and satisfies conditions~\hyperref[asmp:a]{\it (a)} and~\hyperref[asmp:b]{\it (b)} in Assumption~\ref{asmp:same}. Then, we rely on Lemma~\ref{prop:suffix_feasibility}   to get closer to the final result. Note that word belong to language $\ccalL(\cdot)$ instead of $\tilde{\ccalL}(\cdot)$ since the path $\doverline{\tau}^{\text{suf}}$ does not satisfy condition \hyperref[asmp:c]{\it (c)} in Assumption~\ref{asmp:same}.


First, we show that eventually we have $\tilde{v}_{\text{prior}} = {v}_{\text{prior}}$ and $\tilde{s}_{\text{prior}}$ and ${s}_{\text{prior}}$ satisfy the same clause $\ccalC_{\text{prior}}$. As we loop over subtasks that can be the last one to be completed in the prefix part (see constraint~\eqref{eq:lastsubtask0} in Appendix~\ref{sec:transition}), we can formulate a MILP to which the solution gives rise to a run with $\tilde{v}_{\text{prior}} = {v}_{\text{prior}}$. Furthermore, as we loop over clauses in the selected last subtask (see constraint~\eqref{eq:lastclause}), we can obtain the final configuration $\tilde{s}_{\text{prior}}$ such that $\tilde{s}_{\text{prior}}$ and ${s}_{\text{prior}}$ satisfy the same clause $\ccalC_{\text{prior}}$ in the edge label $\gamma_\phi(\vertex{prior}, \vertex{accept})$. However, it is possible that different robots in $\tilde{s}_{\text{prior}}$ and $s_{\text{prior}}$ satisfying the positive subformula $\ccalC_\text{prior}^+$. Based on $\tilde{s}_{\text{prior}}$ and $\vertex{prior}$, we can obtain a sub-NBA $\auto{subtask}^-$ for the suffix part (see Section~\ref{sec:suf_prune}), which  differs from the sub-NBA obtained based on  $s_{\text{prior}}$ and $\vertex{prior}$ only in the interpretation of the  clause $\ccalC_\text{prior}^+$, that is, which robots return to their respective regions (these regions are identical for $\tilde{s}_{\text{prior}}$ and $s_{\text{prior}}$ since they satisfy the same clause $\ccalC_{\text{prior}}^+$). That is, these two sub-NBA are graphically equivalent. To tell those two sub-NBA, we denote by $\auto{subtask}^-( \tilde{s}_{\text{prior}},  {v}_{\text{prior}})$ the sub-NBA based on $\tilde{s}_{\text{prior}} $ and $  {v}_{\text{prior}}$.

Next, based on the fact that $\overline{\tau}^{\text{suf}}$ generates a word $\overline{w}^{\text{suf}} \in \ccalL_E^{\phi, \vertex{accept}\scriptveryshortarrow \vertex{accept}} (\auto{subtask}^-;  {s}_{\text{prior}},  {v}_{\text{prior}})$ we construct another feasible path $\doverline{\tau}^{\text{suf}}$, modified from $\overline{\tau}^{\text{suf}}$, that generates a word $\doverline{w}^{\text{suf}} \in \ccalL_E^{\phi, \vertex{accept}\scriptveryshortarrow \vertex{accept}} (\auto{subtask}^-;  \tilde{s}_{\text{prior}},  {v}_{\text{prior}})$. The path $\doverline{\tau}^{\text{suf}}$ begins with the final locations $\tilde{s}_{\text{prior}} $ of the found prefix part $\tilde{\tau}^{\text{pre}}$ in Proposition~\ref{thm:prefix}. By condition~\hyperref[cond:f]{\it (f)} in Definition~\ref{defn:run}, $\gamma_\phi(\vertex{prior}, \vertex{accept}) \simplies \gamma_\phi(\vertex{accept}, \vertex{next}) $, we have that $\tilde{s}_{\text{prior}}$ and ${s}_{\text{prior}}$ satisfy the same clause in label  $\gamma_\phi(\vertex{accept}, \vertex{next})$ since they satisfy the same clause $\ccalC_{\text{prior}}$ in $\gamma_\phi(\vertex{prior}, \vertex{accept})$. Moreover,  by conditions~\hyperref[cond:d]{\it (d)} and~\hyperref[cond:f]{\it (f)} in Definition~\ref{defn:run}, $\tilde{s}_{\text{prior}}$ and ${s}_{\text{prior}}$ satisfy the same clauses in the edge label $\gamma_\phi(\vertex{accept}, \vertex{next})$ and vertex label $\gamma_\phi(\vertex{next})$, respectively. Therefore, $\tilde{s}_{\text{prior}}$ and ${s}_{\text{prior}}$ satisfy the same clause in $\gamma(\vertex{next})$ in the sub-NBA $\auto{subtask}^-( \tilde{s}_{\text{prior}},  {v}_{\text{prior}})$. We state that, at the time  the sub-NBA $\auto{subtask}^-( \tilde{s}_{\text{prior}},  {v}_{\text{prior}})$ remains at the vertex $\vertex{next}$,  robots can start from $\tilde{s}_{\text{prior}}$ and reach a configuration  $\overline{s}_{\text{prior}}$ that is almost identical to $s_{\text{prior}}$ except the specific robots at the specific cells. In other words, if we do not differentiate robots belonging to the same type, $\overline{s}_{\text{prior}}$ is identical to $s_{\text{prior}}$. To show this,  we  build a one-to-one correspondence between robots in $\tilde{s}_{\text{prior}}$ and robots in ${s}_{\text{prior}}$.

Specifically, for a literal $\ap{i}{j}{k}$ in the satisfied clause of $\gamma(\vertex{next})$, we identify $i$ robots of type $j$ in configuration $\tilde{s}_{\text{prior}}$ that satisfy this literal and another  $i$ robots in ${s}_{\text{prior}}$. Then we build a random one-to-one correspondence between these robots, such that every  robot in those $i$ robots associated with $\tilde{s}_{\text{prior}}$ needs to start from its location in $\tilde{s}_{\text{prior}}$ and reach the location in $s_{\text{prior}}$ where its corresponding robot is, without leaving the region $\ell_k$, which maintains the satisfaction of $\gamma(\vertex{next})$. This point-to-point navigation is feasible since those $i$ robots associated with $\tilde{s}_{\text{prior}}$ and their corresponding robots are all in region $\ell_k$ and, according to Assumption~\ref{asmp:env} every region spans consecutive cells. For other robots of type $j$ in $\tilde{s}_{\text{prior}}$ that do not participate in the satisfaction of $\gamma(\vertex{next})$, we can enumerate them and also build a one-to-one correspondence between them and those of type $j$ in $s_{\text{prior}}$ that do not participate in the satisfaction of $\gamma(\vertex{next})$, either. For such a robot in $\tilde{s}_{\text{prior}}$, by Assumption~\ref{asmp:env}, it can leave its region corresponding to its location in $\tilde{s}_\text{prior}$ to a region-free cell without passing through other regions, then take the region-free path to the region where its corresponding robot is located in $s_{\text{prior}}$ and finally reach the specific cell inside that region. Robots traversing inside  regions  do not violate the label $\gamma(\vertex{next})$ since $\tilde{s}_{\text{prior}}$ and $s_{\text{prior}}$ satisfy $\gamma(\vertex{next})$. In this way, robots reach a configuration $\overline{s}_{\text{prior}}$ while the NBA $\auto{subtask}^-( \tilde{s}_{\text{prior}},  {v}_{\text{prior}})$ remains at the vertex $\vertex{next}$.

Note that during the process when robots reach the configuration $\overline{s}_{\text{prior}}$ from $\tilde{s}_{\text{prior}}$, conditions~\hyperref[asmp:a]{\it (a)} and \hyperref[asmp:b]{\it (b)} in Assumption~\ref{asmp:same} are not violated since those robots in $\tilde{s}_{\text{prior}}$ that satisfy the clause do not move out of their respective regions. We append this path segment from $\tilde{s}_{\text{prior}}$ to  $\overline{s}_{\text{prior}}$ to the ongoing $\doverline{\tau}^{\text{suf}}$. After reaching the configuration $\overline{s}_{\text{prior}}$, every robot takes the remaining path segment its paired robot takes in $\overline{\tau}^{\text{suf}}$ after $s_{\text{prior}}$, which finishes the construction of $\doverline{\tau}^{\text{suf}}$. At last, the transition in the sub-NBA $\auto{subtask}^-( \tilde{s}_{\text{prior}},  {v}_{\text{prior}})$ is driven back to $\vertex{accept}$. Note that the last configuration in $\doverline{\tau}^{\text{suf}}$ is not identical to $\tilde{s}_{\text{prior}}$, that is, robot trajectories are not closed yet. Thus, condition~\hyperref[asmp:c]{\it (c)} in Assumption~\ref{asmp:same} is not met. However, in the last configuration of $\doverline{\tau}^{\text{suf}}$ those robots participating in the satisfaction of $\ccalC_{\text{prior}}^+$ return to their respective regions since $\overline{\tau}^{\text{suf}}$ at last returns to $s_{\text{prior}}$, and $s_{\text{prior}}$ and $\tilde{s}_{\text{prior}}$ satisfy the same positive subformula  $\ccalC_{\text{prior}}^+$. Therefore, we can construct a path $\doverline{\tau}^{\text{suf}}$ that meets conditions~\hyperref[asmp:a]{\it (a)} and \hyperref[asmp:b]{\it (b)} in Assumption~\ref{asmp:same} and generates a word $\doverline{w}^{\text{suf}} \in \ccalL_E^{\phi, \vertex{accept}\scriptveryshortarrow \vertex{accept}} (\auto{subtask}^-;  \tilde{s}_{\text{prior}},  {v}_{\text{prior}})$.  More importantly, those robots participating in the satisfaction of $\ccalC_{\text{prior}}^+$ return to  regions corresponding to their initial locations.

Subsequently, we apply Lemma~\ref{prop:suffix_feasibility} to conclude that we can obtain a low-level path and we denote it  by  $\tilde{\tau}^{\text{suf},1}$. We note that Lemma~\ref{prop:suffix_feasibility} assumes that a path exists  satisfying condition~\hyperref[asmp:c]{\it (c)} in Assumption~\ref{asmp:same} which requires robots to return to their initial locations, while in $\doverline{\tau}^{\text{suf}}$ only those robots participating in satisfying $\ccalC_{\text{prior}}^+$  return to their respective regions. Even so, it suffices to establish the feasibility of the MILP (excluding constraint~\eqref{eq:same}) for the suffix part since in the MILP, the clause needed to be satisfied in the last completed subtask is $\ccalC_{\text{prior}}^+$ (see Fig.~\ref{fig:suffix}), i.e., robots are not required to return to their initial locations. After obtaining the path $\tilde{\tau}^{\text{suf},1}$, we can get that the run in $\autop$ induced by $\tilde{\tau}^{\text{suf},1}$ is a cycle around the accepting vertex $\vertex{accept}$.

Finally, we prove that the closing of trajectories in Section~\ref{sec:suf_milp} is feasible. The last configuration in the low-level path $\tilde{\tau}^{\text{suf},1}$ satisfies the clause $\ccalC_{\text{prior}}$, so do the initial locations $\tilde{s}_{\text{prior}}$. Also, those robots in the last configuration of $\tilde{\tau}^{\text{suf},1}$ participating in the satisfaction of $\ccalC_{\text{prior}}^+$ are identical to those in $\tilde{s}_{\text{prior}}$. Therefore, these robots can return to their initial locations in $\tilde{s}_{\text{prior}}$ inside the same regions, while maintaining the truth of $\ccalC_{\text{prior}}^+$. The rest of robots can return to their initial locations by leaving their regions in the last configuration to label-free cells, then taking the label-free path to the regions where their initial locations in $\tilde{s}_{\text{prior}}$ are located, and finally returning to initial locations inside these regions. This  respects the negative subformula $\ccalC_{\text{prior}}^-$ since both the last configuration in $\tilde{\tau}^{\text{suf},1}$ and $\tilde{s}_{\text{prior}}$ satisfy $\ccalC_{\text{prior}}$. We denote by $\tilde{\tau}^{\text{suf,2}}$ the path segment from the last configuration of $\tilde{\tau}^{\text{suf,1}}$ to $\tilde{s}_{\text{prior}}$, which satisfies the clause $\ccalC_{\text{prior}}$, and further satisfies the label $\gamma_\phi(\vertex{prior}, \vertex{next})$ and $\gamma_\phi(\vertex{next})$ according to conditions~\hyperref[cond:d]{\it (d)} and \hyperref[cond:f]{\it (f)} in Definition~\ref{defn:run}.
Therefore, the NBA $\autop$ can remain at vertex $\vertex{next}$ while robots execute  the path segment $\tilde{\tau}^{\text{suf,2}}$. In a nutshell, we leverage the vertex $\vertex{next}$ to reach $\overline{s}_{\text{prior}}$ from $\tilde{s}_{\text{prior}}$ in order to reuse the suffix path $\overline{\tau}^{\text{suf}}$, and similarly we leverage the vertex $\vertex{next}$ to get off the path $\overline{\tau}^{\text{suf}}$ in order to return to $\tilde{s}_{\text{prior}}$. Finally, we can obtain the suffix path by concatenating $\tilde{\tau}^{\text{suf},1}$ with $\tilde{\tau}^{\text{suf},2}$, i.e., $\tilde{\tau}^{\text{suf}} = \tilde{\tau}^{\text{suf},1} \tilde{\tau}^{\text{suf},2}$, which gives rises to a path $\tilde{\tau} = \tilde{\tau}^{\text{pre}} [\tilde{\tau}^{\text{suf}}]^\omega$ that satisfies the specification $\phi$, completing the proof.

%\theendnotes



%%Harvard (name/date)

\end{document}
